========================================
File: ./NabdCare.Api/Configurations/FrontendSettings.cs
========================================
namespace NabdCare.Api.Configurations;

public class FrontendSettings
{
    public string[] AllowedOrigins { get; set; } = [];
}
========================================
File: ./NabdCare.Api/Configurations/SwaggerConfig.cs
========================================
using Microsoft.OpenApi.Models;
using System.Reflection;

namespace NabdCare.Api.Configurations
{
    public static class SwaggerConfig
    {
        public static void AddSwagger(IServiceCollection services)
        {
            services.AddEndpointsApiExplorer();
            services.AddSwaggerGen(options =>
            {
                options.SwaggerDoc("v1", new OpenApiInfo
                {
                    Title = "NabdCare API",
                    Version = "v1",
                    Description = "API documentation for NabdCare"
                });

                // ‚úÖ JWT Authentication for Swagger
                options.AddSecurityDefinition("Bearer", new OpenApiSecurityScheme
                {
                    Description = "JWT Authorization header using the Bearer scheme. Example: \"Bearer {token}\"",
                    Name = "Authorization",
                    In = ParameterLocation.Header,
                    Type = SecuritySchemeType.Http,
                    Scheme = "Bearer"
                });

                options.AddSecurityRequirement(new OpenApiSecurityRequirement
                {
                    {
                        new OpenApiSecurityScheme
                        {
                            Reference = new OpenApiReference
                            {
                                Type = ReferenceType.SecurityScheme,
                                Id = "Bearer"
                            }
                        },
                        Array.Empty<string>()
                    }
                });

                // ‚úÖ Make enums show as strings in Swagger UI
                options.MapType<Enum>(() => new OpenApiSchema
                {
                    Type = "string",
                    Enum = null // Swagger will infer actual enum names
                });

                // Optional: Include XML comments
                var xmlFile = $"{Assembly.GetExecutingAssembly().GetName().Name}.xml";
                var xmlPath = Path.Combine(AppContext.BaseDirectory, xmlFile);
                if (File.Exists(xmlPath))
                    options.IncludeXmlComments(xmlPath);
            });
        }
    }
}
========================================
File: ./NabdCare.Api/Configurations/JwtConfig.cs
========================================
using System.Text;
using Microsoft.AspNetCore.Authentication.JwtBearer;
using Microsoft.IdentityModel.Tokens;

namespace NabdCare.Api.Configurations;

public static class JwtConfig
{
    public static IServiceCollection AddJwtAuthentication(this IServiceCollection services, IConfiguration configuration)
    {
        // ‚úÖ Read from environment first, fallback to appsettings.json
        var key = Environment.GetEnvironmentVariable("JWT_KEY") 
                  ?? configuration["Jwt:Key"];
        
        var issuer = Environment.GetEnvironmentVariable("JWT_ISSUER") 
                     ?? configuration["Jwt:Issuer"];
        
        var audience = Environment.GetEnvironmentVariable("JWT_AUDIENCE") 
                       ?? configuration["Jwt:Audience"];

        // ‚úÖ P0 FIX: Validate configuration
        if (string.IsNullOrWhiteSpace(key))
            throw new InvalidOperationException("JWT Key is not configured. Set JWT_KEY environment variable or Jwt:Key in appsettings.json.");

        if (key.Length < 32)
            throw new InvalidOperationException($"JWT Key is too short ({key.Length} chars). Must be at least 32 characters (256 bits).");

        if (string.IsNullOrWhiteSpace(issuer))
            throw new InvalidOperationException("JWT Issuer is not configured. Set JWT_ISSUER environment variable or Jwt:Issuer in appsettings.json.");

        if (string.IsNullOrWhiteSpace(audience))
            throw new InvalidOperationException("JWT Audience is not configured. Set JWT_AUDIENCE environment variable or Jwt:Audience in appsettings.json.");

        var signingKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(key));

        services.AddAuthentication(options =>
        {
            options.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme;
            options.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme;
        })
        .AddJwtBearer(options =>
        {
            options.TokenValidationParameters = new TokenValidationParameters
            {
                ValidateIssuer = true,
                ValidateAudience = true,
                ValidateLifetime = true,
                ValidateIssuerSigningKey = true,
                ValidIssuer = issuer,
                ValidAudience = audience,
                IssuerSigningKey = signingKey,
                
                // ‚úÖ P0 FIX: Add clock skew tolerance for time sync issues
                ClockSkew = TimeSpan.FromMinutes(5)
            };

            options.Events = new JwtBearerEvents
            {
                OnAuthenticationFailed = context =>
                {
                    var logger = context.HttpContext.RequestServices
                        .GetRequiredService<ILogger<JwtBearerEvents>>();
                    
                    // ‚úÖ P0 FIX: Add token expiry header
                    if (context.Exception.GetType() == typeof(SecurityTokenExpiredException))
                    {
                        context.Response.Headers.Append("X-Token-Expired", "true");
                        logger.LogWarning("‚ö†Ô∏è JWT expired for user");
                    }
                    else
                    {
                        logger.LogError(context.Exception, "‚ùå JWT authentication failed");
                    }

                    return Task.CompletedTask;
                },
                OnTokenValidated = context =>
                {
                    var logger = context.HttpContext.RequestServices
                        .GetRequiredService<ILogger<JwtBearerEvents>>();

                    var userId = context.Principal?.FindFirst("sub")?.Value ?? "unknown";
                    var email = context.Principal?.FindFirst("email")?.Value ?? "unknown";

                    logger.LogInformation("‚úÖ JWT validated for user {UserId} ({Email})", userId, email);
                    return Task.CompletedTask;
                },
                OnChallenge = context =>
                {
                    // ‚úÖ P0 FIX: Provide consistent error response
                    context.HandleResponse();
                    context.Response.StatusCode = StatusCodes.Status401Unauthorized;
                    context.Response.ContentType = "application/json";
                    
                    var traceId = Guid.NewGuid().ToString("N");
                    context.Response.Headers.Append("X-Trace-Id", traceId);
                    
                    var logger = context.HttpContext.RequestServices
                        .GetRequiredService<ILogger<JwtBearerEvents>>();
                    
                    logger.LogWarning("‚ö†Ô∏è JWT challenge triggered. Error={Error}, Description={ErrorDescription}, TraceId={TraceId}",
                        context.Error, context.ErrorDescription, traceId);
                    
                    var result = System.Text.Json.JsonSerializer.Serialize(new
                    {
                        error = new
                        {
                            message = "Authentication failed. Please login again.",
                            type = "Unauthorized",
                            statusCode = 401,
                            traceId
                        }
                    });
                    
                    return context.Response.WriteAsync(result);
                }
            };
        });

        return services;
    }
}
========================================
File: ./NabdCare.Api/Configurations/DependencyInjectionConfig.cs
========================================
using FluentValidation;
using Microsoft.EntityFrameworkCore;
using NabdCare.Application.Common;
using NabdCare.Application.Interfaces;
using NabdCare.Application.Interfaces.Auth;
using NabdCare.Application.Interfaces.Clinics;
using NabdCare.Application.Interfaces.Clinics.Subscriptions;
using NabdCare.Application.Interfaces.Permissions;
using NabdCare.Application.Interfaces.Roles;
using NabdCare.Application.Interfaces.Users;
using NabdCare.Application.mappings;
using NabdCare.Application.Mappings;
using NabdCare.Application.Services;
using NabdCare.Application.Services.Auth;
using NabdCare.Application.Services.Clinics;
using NabdCare.Application.Services.Permissions;
using NabdCare.Application.Services.Roles;
using NabdCare.Application.Services.Users;
using NabdCare.Application.Validator.Users;
using NabdCare.Infrastructure.Persistence;
using NabdCare.Infrastructure.Persistence.DataSeed;
using NabdCare.Infrastructure.Repositories.Auth;
using NabdCare.Infrastructure.Repositories.Clinics;
using NabdCare.Infrastructure.Repositories.Permissions;
using NabdCare.Infrastructure.Repositories.Roles;
using NabdCare.Infrastructure.Repositories.Users;

namespace NabdCare.Api.Configurations;

public static class DependencyInjectionConfig
{
    public static IServiceCollection AddNabdCareServices(this IServiceCollection services, IConfiguration configuration)
    {
        // DbContext
        services.AddDbContext<NabdCareDbContext>(options =>
            options.UseNpgsql(configuration.GetConnectionString("DefaultConnection"))
        );

        // HttpContextAccessor
        services.AddHttpContextAccessor();

        // Tenant & User context
        services.AddScoped<ITenantContext, TenantContext>();
        services.AddScoped<IUserContext, UserContext>();

        // Auth services
        services.AddScoped<IPasswordService, IdentityPasswordService>();
        services.AddScoped<ITokenService, JwtTokenService>();
        services.AddScoped<IAuthRepository, AuthRepository>();
        services.AddScoped<IAuthService, AuthService>();

        // User services
        services.AddScoped<IUserRepository, UserRepository>();
        services.AddScoped<IUserService, UserService>();

        // Permission services
        services.AddScoped<IPermissionRepository, PermissionRepository>();
        services.AddScoped<IPermissionService, PermissionService>();
        
        // ‚úÖ ADD THESE TWO LINES - Role services
        services.AddScoped<IRoleRepository, RoleRepository>();
        services.AddScoped<IRoleService, RoleService>();
        
        // Role repository (already exists, keep it)
        services.AddScoped<IRoleRepository, RoleRepository>();
        
        // Clinic services
        services.AddScoped<IClinicRepository, ClinicRepository>();
        services.AddScoped<IClinicService, ClinicService>();

        // Subscription services
        services.AddScoped<ISubscriptionRepository, SubscriptionRepository>();
        services.AddScoped<ISubscriptionService, SubscriptionService>();

        // AutoMapper - ‚úÖ ADD RoleProfile
        services.AddAutoMapper(_ => { }, 
            typeof(UserProfile), 
            typeof(ClinicProfile), 
            typeof(PermissionProfile), 
            typeof(SubscriptionProfile),
            typeof(RoleProfile));  // ‚úÖ ADD THIS

        // FluentValidation - ‚úÖ This will automatically find Role validators
        services.AddValidatorsFromAssemblyContaining<UserValidator>();

        // Seeder registrations
        services.AddScoped<DbSeeder>();
        services.AddScoped<ISingleSeeder, RolesSeeder>();           // Order 1 - Create roles first
        services.AddScoped<ISingleSeeder, PermissionsSeeder>();     // Order 2 - Create permissions
        services.AddScoped<ISingleSeeder, RolePermissionsSeeder>(); // Order 3 - Assign permissions to roles
        services.AddScoped<ISingleSeeder, SuperAdminSeeder>();      // Order 4 - Create SuperAdmin user

        return services;
    }
}
========================================
File: ./NabdCare.Api/Configurations/RateLimitSettings.cs
========================================
namespace NabdCare.Api.Configurations;

public class RateLimitSettings
{
    public RateLimitPolicySettings Auth { get; set; } = new();
    public RateLimitPolicySettings Api { get; set; } = new();
}

public class RateLimitPolicySettings
{
    /// <summary>
    /// Window size in minutes for fixed-window policies or replenishment period for token-bucket.
    /// </summary>
    public int WindowMinutes { get; set; } = 1;

    /// <summary>
    /// Number of permits allowed per window (fixed-window) or tokens per period (token-bucket).
    /// </summary>
    public int PermitLimit { get; set; } = 100;

    /// <summary>
    /// Optional queue limit for waiting requests (0 = no queue).
    /// </summary>
    public int QueueLimit { get; set; } = 0;
}
========================================
File: ./NabdCare.Api/Middleware/ErrorHandlingMiddleware.cs
========================================
using System.Net;
using System.Text.Json;

namespace NabdCare.Api.Middleware;

public class ErrorHandlingMiddleware
{
    private readonly RequestDelegate _next;
    private readonly ILogger<ErrorHandlingMiddleware> _logger;

    public ErrorHandlingMiddleware(RequestDelegate next, ILogger<ErrorHandlingMiddleware> logger)
    {
        _next = next;
        _logger = logger;
    }

    public async Task InvokeAsync(HttpContext context)
    {
        try
        {
            await _next(context);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "An unhandled exception occurred.");
            await HandleExceptionAsync(context, ex);
        }
    }

    private static async Task HandleExceptionAsync(HttpContext context, Exception exception)
    {
        context.Response.ContentType = "application/json";

        var traceId = Guid.NewGuid().ToString("N");
        context.Response.Headers["X-Trace-Id"] = traceId;

        var isDevelopment = 
            Environment.GetEnvironmentVariable("ASPNETCORE_ENVIRONMENT") == "Development";

        // ‚úÖ P0 FIX: Enhanced exception handling with generic messages for production
        var (statusCode, message, exceptionType) = exception switch
        {
            UnauthorizedAccessException => (
                (int)HttpStatusCode.Unauthorized,
                isDevelopment ? exception.Message : "Authentication failed.",
                "UnauthorizedAccess"
            ),
            ArgumentException => (
                (int)HttpStatusCode.BadRequest,
                isDevelopment ? exception.Message : "Invalid request.",
                "BadRequest"
            ),
            InvalidOperationException => (
                (int)HttpStatusCode.InternalServerError,
                isDevelopment ? exception.Message : "An error occurred processing your request.",
                "InvalidOperation"
            ),
            _ => (
                (int)HttpStatusCode.InternalServerError,
                isDevelopment ? exception.Message : "An unexpected error occurred.",
                "InternalError"
            )
        };

        var errorResponse = new
        {
            error = new
            {
                message,
                type = exceptionType,
                statusCode,
                traceId,
                // ‚úÖ Only include stack trace in development
                stackTrace = isDevelopment ? exception.StackTrace : null
            }
        };

        context.Response.StatusCode = statusCode;
        await context.Response.WriteAsync(JsonSerializer.Serialize(errorResponse, new JsonSerializerOptions
        {
            PropertyNamingPolicy = JsonNamingPolicy.CamelCase,
            DefaultIgnoreCondition = System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingNull
        }));
    }
}
========================================
File: ./NabdCare.Api/Middleware/SubscriptionValidationMiddleware.cs
========================================
// Middleware/SubscriptionValidationMiddleware.cs
using Microsoft.AspNetCore.Http;
using NabdCare.Application.Common;
using NabdCare.Application.Interfaces.Clinics;
using NabdCare.Domain.Enums;

namespace NabdCare.Api.Middleware;

/// <summary>
/// Middleware to block requests from clinics with invalid subscriptions
/// </summary>
public class SubscriptionValidationMiddleware
{
    private readonly RequestDelegate _next;

    public SubscriptionValidationMiddleware(RequestDelegate next)
    {
        _next = next;
    }

    public async Task InvokeAsync(
        HttpContext context,
        ITenantContext tenantContext,
        IClinicRepository clinicRepository)
    {
        // Skip for SuperAdmin
        if (tenantContext.IsSuperAdmin)
        {
            await _next(context);
            return;
        }

        // Skip for auth endpoints
        if (context.Request.Path.StartsWithSegments("/api/auth"))
        {
            await _next(context);
            return;
        }

        // Check clinic subscription status
        if (tenantContext.ClinicId.HasValue)
        {
            var clinic = await clinicRepository.GetByIdAsync(tenantContext.ClinicId.Value);
            
            if (clinic == null || 
                clinic.Status == SubscriptionStatus.Expired ||
                clinic.Status == SubscriptionStatus.Suspended ||
                clinic.Status == SubscriptionStatus.Cancelled)
            {
                context.Response.StatusCode = 403;
                await context.Response.WriteAsJsonAsync(new
                {
                    Error = "Clinic subscription is not active",
                    Status = clinic?.Status.ToString() ?? "Unknown",
                    Message = GetStatusMessage(clinic?.Status)
                });
                return;
            }
        }

        await _next(context);
    }

    private static string GetStatusMessage(SubscriptionStatus? status)
    {
        return status switch
        {
            SubscriptionStatus.Expired => "Your subscription has expired. Please contact support to renew.",
            SubscriptionStatus.Suspended => "Your clinic has been suspended. Please contact support.",
            SubscriptionStatus.Cancelled => "Your subscription has been cancelled.",
            _ => "Your clinic is not active."
        };
    }
}
========================================
File: ./NabdCare.Api/Middleware/SecurityHeadersMiddleware.cs
========================================
using Microsoft.Extensions.Options;
using NabdCare.Api.Configurations;

namespace NabdCare.Api.Middleware
{
    public class SecurityHeadersMiddleware
    {
        private readonly RequestDelegate _next;
        private readonly string[] _allowedOrigins;

        public SecurityHeadersMiddleware(RequestDelegate next, IOptions<FrontendSettings> options)
        {
            _next = next;
            _allowedOrigins = options.Value.AllowedOrigins ?? Array.Empty<string>();
        }

        public async Task InvokeAsync(HttpContext context)
        {
            var headers = context.Response.Headers;

            // üîí Basic security headers
            headers["X-Content-Type-Options"] = "nosniff";
            headers["X-Frame-Options"] = "DENY";
            headers["X-XSS-Protection"] = "1; mode=block";
            headers["Referrer-Policy"] = "strict-origin-when-cross-origin";
            headers["X-Permitted-Cross-Domain-Policies"] = "none";
            headers["Cross-Origin-Embedder-Policy"] = "require-corp";
            headers["Cross-Origin-Opener-Policy"] = "same-origin";
            headers["Cross-Origin-Resource-Policy"] = "same-origin";

            // ‚úÖ Content-Security-Policy with dynamic origins
            var connectSrc = string.Join(" ", _allowedOrigins.Append("'self'"));
            headers["Content-Security-Policy"] =
                $"default-src 'self'; " +
                $"img-src 'self' data: https:; " +
                $"script-src 'self' 'unsafe-inline' 'unsafe-eval'; " +
                $"style-src 'self' 'unsafe-inline' https:; " +
                $"font-src 'self' https: data:; " +
                $"connect-src {connectSrc}; " +
                $"frame-ancestors 'none'; " +
                $"base-uri 'self';";

            await _next(context);
        }
    }

    public static class SecurityHeadersMiddlewareExtensions
    {
        public static IApplicationBuilder UseSecurityHeaders(this IApplicationBuilder app)
        {
            return app.UseMiddleware<SecurityHeadersMiddleware>();
        }
    }
}
========================================
File: ./NabdCare.Api/obj/Debug/net8.0/.NETCoreApp,Version=v8.0.AssemblyAttributes.cs
========================================
// <autogenerated />
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v8.0", FrameworkDisplayName = ".NET 8.0")]

========================================
File: ./NabdCare.Api/obj/Debug/net8.0/NabdCare.Api.GlobalUsings.g.cs
========================================
// <auto-generated/>
global using global::Microsoft.AspNetCore.Builder;
global using global::Microsoft.AspNetCore.Hosting;
global using global::Microsoft.AspNetCore.Http;
global using global::Microsoft.AspNetCore.Routing;
global using global::Microsoft.Extensions.Configuration;
global using global::Microsoft.Extensions.DependencyInjection;
global using global::Microsoft.Extensions.Hosting;
global using global::Microsoft.Extensions.Logging;
global using global::System;
global using global::System.Collections.Generic;
global using global::System.IO;
global using global::System.Linq;
global using global::System.Net.Http;
global using global::System.Net.Http.Json;
global using global::System.Threading;
global using global::System.Threading.Tasks;

========================================
File: ./NabdCare.Api/obj/Debug/net8.0/NabdCare.Api.AssemblyInfo.cs
========================================
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("NabdCare.Api")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+404a61d5f45213b03261a6fc7fff592311d4bbda")]
[assembly: System.Reflection.AssemblyProductAttribute("NabdCare.Api")]
[assembly: System.Reflection.AssemblyTitleAttribute("NabdCare.Api")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]

// Generated by the MSBuild WriteCodeFragment class.


========================================
File: ./NabdCare.Api/obj/Debug/net8.0/NabdCare.Api.MvcApplicationPartsAssemblyInfo.cs
========================================
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: Microsoft.AspNetCore.Mvc.ApplicationParts.ApplicationPartAttribute("Microsoft.AspNetCore.OpenApi")]
[assembly: Microsoft.AspNetCore.Mvc.ApplicationParts.ApplicationPartAttribute("Swashbuckle.AspNetCore.SwaggerGen")]

// Generated by the MSBuild WriteCodeFragment class.


========================================
File: ./NabdCare.Api/Endpoints/UserEndpoints.cs
========================================
Ôªøusing FluentValidation;
using Microsoft.AspNetCore.Mvc;
using NabdCare.Api.Extensions;
using NabdCare.Application.Common;
using NabdCare.Application.DTOs.Users;
using NabdCare.Application.Interfaces.Users;

namespace NabdCare.Api.Endpoints;

/// <summary>
/// Production-ready user management endpoints with consistent permission naming.
/// Error handling is delegated to ErrorHandlingMiddleware.
/// Author: Rabee-Qabaha
/// Updated: 2025-10-23 19:50:00 UTC
/// </summary>
public static class UserEndpoints
{
    public static void MapUserEndpoints(this IEndpointRouteBuilder app)
    {
        var group = app.MapGroup("users")
            .WithTags("Users");

        // ============================================
        // CREATE USER
        // ============================================
        group.MapPost("/", async (
            [FromBody] CreateUserRequestDto dto,
            [FromServices] IUserService userService,
            [FromServices] IValidator<CreateUserRequestDto> validator) =>
        {
            var validation = await validator.ValidateAsync(dto);
            if (!validation.IsValid)
                return Results.BadRequest(new { Errors = validation.Errors.Select(e => e.ErrorMessage) });

            var user = await userService.CreateUserAsync(dto);
            return Results.Created($"/api/users/{user.Id}", user);
        })
        .RequirePermission("Users.Create")
        .WithName("CreateUser")
        .WithSummary("Create a new user")
        .WithDescription("SuperAdmin: Create user in any clinic. ClinicAdmin: Create user in own clinic only.")
        .Produces<UserResponseDto>(StatusCodes.Status201Created)
        .Produces(StatusCodes.Status400BadRequest)
        .Produces(StatusCodes.Status403Forbidden)
        .Produces(StatusCodes.Status409Conflict);

        // ============================================
        // GET ALL USERS (Multi-Tenant Filtered)
        // ============================================
        group.MapGet("/", async (
            [FromServices] IUserService userService,
            [FromServices] ITenantContext tenantContext) =>
        {
            // ‚úÖ FIX: Use correct logic based on tenant context
            IEnumerable<UserResponseDto> users;
            
            if (tenantContext.IsSuperAdmin)
            {
                // SuperAdmin: Get ALL users
                users = await userService.GetUsersByClinicIdAsync(null);
            }
            else if (tenantContext.ClinicId.HasValue)
            {
                // ClinicAdmin: Get only clinic users
                users = await userService.GetUsersByClinicIdAsync(tenantContext.ClinicId.Value);
            }
            else
            {
                return Results.Json(
                    new { Error = "You don't have permission to view users" },
                    statusCode: StatusCodes.Status403Forbidden);
            }

            return Results.Ok(users);
        })
        .RequirePermission("Users.View")
        .WithName("GetAllUsers")
        .WithSummary("Get all users")
        .WithDescription("SuperAdmin: All users. ClinicAdmin: Only clinic users.")
        .Produces<IEnumerable<UserResponseDto>>()
        .Produces(StatusCodes.Status403Forbidden);

        // ============================================
        // GET USER BY ID
        // ============================================
        group.MapGet("/{id:guid}", async (
            Guid id,
            [FromServices] IUserService userService) =>
        {
            if (id == Guid.Empty)
                return Results.BadRequest(new { Error = "Invalid user ID" });

            var user = await userService.GetUserByIdAsync(id);
            return user is not null 
                ? Results.Ok(user) 
                : Results.NotFound(new { Error = $"User {id} not found" });
        })
        .RequirePermission("Users.ViewDetails")
        .WithName("GetUserById")
        .WithSummary("Get user by ID")
        .WithDescription("Returns user details. Multi-tenant filtered automatically.")
        .Produces<UserResponseDto>()
        .Produces(StatusCodes.Status400BadRequest)
        .Produces(StatusCodes.Status403Forbidden)
        .Produces(StatusCodes.Status404NotFound);

        // ============================================
        // GET USERS BY CLINIC (SuperAdmin Only)
        // ============================================
        group.MapGet("/clinic/{clinicId:guid}", async (
            Guid clinicId,
            [FromServices] IUserService userService,
            [FromServices] ITenantContext tenantContext) =>
        {
            if (clinicId == Guid.Empty)
                return Results.BadRequest(new { Error = "Invalid clinic ID" });

            if (!tenantContext.IsSuperAdmin)
                return Results.Json(
                    new { Error = "Missing required permission: Users.ViewAll" },
                    statusCode: StatusCodes.Status403Forbidden);

            var users = await userService.GetUsersByClinicIdAsync(clinicId);
            return Results.Ok(users);
        })
        .RequirePermission("Users.ViewAll")
        .WithName("GetUsersByClinic")
        .WithSummary("Get all users in a specific clinic (SuperAdmin only)")
        .Produces<IEnumerable<UserResponseDto>>()
        .Produces(StatusCodes.Status400BadRequest)
        .Produces(StatusCodes.Status403Forbidden);

        // ============================================
        // GET CURRENT USER (Me)
        // ============================================
        group.MapGet("/me", async (
            [FromServices] IUserService userService,
            [FromServices] IUserContext userContext) =>
        {
            // ‚úÖ FIX: Proper error handling for user ID
            var userIdStr = userContext.GetCurrentUserId();
            
            if (string.IsNullOrEmpty(userIdStr) || userIdStr == "anonymous")
            {
                return Results.Json(
                    new { Error = "User not authenticated" },
                    statusCode: StatusCodes.Status401Unauthorized);
            }

            if (!Guid.TryParse(userIdStr, out var userId))
            {
                return Results.Json(
                    new { Error = "Invalid user ID format" },
                    statusCode: StatusCodes.Status400BadRequest);
            }

            var user = await userService.GetUserByIdAsync(userId);
            
            return user is not null 
                ? Results.Ok(user) 
                : Results.NotFound(new { Error = "User not found" });
        })
        .RequireAuthorization()
        .WithName("GetCurrentUser")
        .WithSummary("Get current authenticated user's details")
        .Produces<UserResponseDto>()
        .Produces(StatusCodes.Status401Unauthorized)
        .Produces(StatusCodes.Status404NotFound);

        // ============================================
        // UPDATE USER
        // ============================================
        group.MapPut("/{id:guid}", async (
            Guid id,
            [FromBody] UpdateUserRequestDto dto,
            [FromServices] IUserService userService,
            [FromServices] IValidator<UpdateUserRequestDto> validator) =>
        {
            if (id == Guid.Empty)
                return Results.BadRequest(new { Error = "Invalid user ID" });

            var validation = await validator.ValidateAsync(dto);
            if (!validation.IsValid)
                return Results.BadRequest(new { Errors = validation.Errors.Select(e => e.ErrorMessage) });

            var updatedUser = await userService.UpdateUserAsync(id, dto);
            return updatedUser is not null 
                ? Results.Ok(updatedUser) 
                : Results.NotFound(new { Error = $"User {id} not found" });
        })
        .RequirePermission("Users.Edit")
        .WithName("UpdateUser")
        .WithSummary("Update user details")
        .WithDescription("Update user information. Multi-tenant access control applied.")
        .Produces<UserResponseDto>()
        .Produces(StatusCodes.Status400BadRequest)
        .Produces(StatusCodes.Status403Forbidden)
        .Produces(StatusCodes.Status404NotFound);

        // ============================================
        // UPDATE USER ROLE
        // ============================================
        group.MapPut("/{id:guid}/role", async (
            Guid id,
            [FromBody] UpdateUserRoleDto dto,
            [FromServices] IUserService userService,
            [FromServices] IValidator<UpdateUserRoleDto> validator) =>
        {
            if (id == Guid.Empty)
                return Results.BadRequest(new { Error = "Invalid user ID" });

            var validation = await validator.ValidateAsync(dto);
            if (!validation.IsValid)
                return Results.BadRequest(new { Errors = validation.Errors.Select(e => e.ErrorMessage) });

            var updatedUser = await userService.UpdateUserRoleAsync(id, dto.RoleId);
            return updatedUser is not null 
                ? Results.Ok(updatedUser) 
                : Results.NotFound(new { Error = $"User {id} not found" });
        })
        .RequirePermission("Users.ChangeRole")  // ‚úÖ FIXED: Changed from Users.ManageRoles
        .WithName("UpdateUserRole")
        .WithSummary("Update user's role")
        .WithDescription("Change a user's role. ClinicAdmin: Only within clinic. SuperAdmin: Any user.")
        .Produces<UserResponseDto>()
        .Produces(StatusCodes.Status400BadRequest)
        .Produces(StatusCodes.Status403Forbidden)
        .Produces(StatusCodes.Status404NotFound);

        // ============================================
        // ACTIVATE USER
        // ============================================
        group.MapPut("/{id:guid}/activate", async (
            Guid id,
            [FromServices] IUserService userService) =>
        {
            if (id == Guid.Empty)
                return Results.BadRequest(new { Error = "Invalid user ID" });

            var user = await userService.ActivateUserAsync(id);
            return user is not null 
                ? Results.Ok(new { Message = $"User {id} activated successfully", User = user }) 
                : Results.NotFound(new { Error = $"User {id} not found" });
        })
        .RequirePermission("Users.Activate")
        .WithName("ActivateUser")
        .WithSummary("Activate a deactivated user")
        .Produces<UserResponseDto>()
        .Produces(StatusCodes.Status400BadRequest)
        .Produces(StatusCodes.Status403Forbidden)
        .Produces(StatusCodes.Status404NotFound);

        // ============================================
        // DEACTIVATE USER
        // ============================================
        group.MapPut("/{id:guid}/deactivate", async (
            Guid id,
            [FromServices] IUserService userService) =>
        {
            if (id == Guid.Empty)
                return Results.BadRequest(new { Error = "Invalid user ID" });

            var user = await userService.DeactivateUserAsync(id);
            return user is not null 
                ? Results.Ok(new { Message = $"User {id} deactivated successfully", User = user }) 
                : Results.NotFound(new { Error = $"User {id} not found" });
        })
        .RequirePermission("Users.Activate")
        .WithName("DeactivateUser")
        .WithSummary("Deactivate a user (prevents login)")
        .Produces<UserResponseDto>()
        .Produces(StatusCodes.Status400BadRequest)
        .Produces(StatusCodes.Status403Forbidden)
        .Produces(StatusCodes.Status404NotFound);

        // ============================================
        // SOFT DELETE USER
        // ============================================
        group.MapDelete("/{id:guid}", async (
            Guid id,
            [FromServices] IUserService userService) =>
        {
            if (id == Guid.Empty)
                return Results.BadRequest(new { Error = "Invalid user ID" });

            var success = await userService.SoftDeleteUserAsync(id);
            return success 
                ? Results.Ok(new { Message = $"User {id} soft deleted successfully" }) 
                : Results.NotFound(new { Error = $"User {id} not found" });
        })
        .RequirePermission("Users.Delete")
        .WithName("SoftDeleteUser")
        .WithSummary("Soft delete a user")
        .WithDescription("Marks user as deleted. Can be restored. ClinicAdmin: Only clinic users.")
        .Produces(StatusCodes.Status200OK)
        .Produces(StatusCodes.Status400BadRequest)
        .Produces(StatusCodes.Status403Forbidden)
        .Produces(StatusCodes.Status404NotFound);

        // ============================================
        // HARD DELETE USER (SuperAdmin Only)
        // ============================================
        group.MapDelete("/{id:guid}/permanent", async (
            Guid id,
            [FromServices] IUserService userService,
            [FromServices] ITenantContext tenantContext) =>
        {
            if (id == Guid.Empty)
                return Results.BadRequest(new { Error = "Invalid user ID" });

            if (!tenantContext.IsSuperAdmin)
                return Results.Json(
                    new { Error = "Missing required permission: Users.Delete" },
                    statusCode: StatusCodes.Status403Forbidden);

            var success = await userService.HardDeleteUserAsync(id);
            return success 
                ? Results.Ok(new { Message = $"User {id} permanently deleted" }) 
                : Results.NotFound(new { Error = $"User {id} not found" });
        })
        .RequirePermission("Users.Delete")  // ‚úÖ FIXED: Uses Users.Delete (not Users.HardDelete)
        .WithName("HardDeleteUser")
        .WithSummary("Permanently delete a user (SuperAdmin only - DANGEROUS)")
        .WithDescription("‚ö†Ô∏è IRREVERSIBLE: Completely removes user from database.")
        .Produces(StatusCodes.Status200OK)
        .Produces(StatusCodes.Status400BadRequest)
        .Produces(StatusCodes.Status403Forbidden)
        .Produces(StatusCodes.Status404NotFound);

        // ============================================
        // CHANGE PASSWORD (Self)
        // ============================================
        group.MapPost("/{id:guid}/change-password", async (
            Guid id,
            [FromBody] ChangePasswordRequestDto dto,
            [FromServices] IUserService userService,
            [FromServices] IValidator<ChangePasswordRequestDto> validator) =>
        {
            if (id == Guid.Empty)
                return Results.BadRequest(new { Error = "Invalid user ID" });

            var validation = await validator.ValidateAsync(dto);
            if (!validation.IsValid)
                return Results.BadRequest(new { Errors = validation.Errors.Select(e => e.ErrorMessage) });

            var updated = await userService.ChangePasswordAsync(id, dto);
            return Results.Ok(new { Message = "Password changed successfully", User = updated });
        })
        .RequireAuthorization()
        .WithName("ChangePassword")
        .WithSummary("Change own password")
        .WithDescription("User changes their own password. Requires current password.")
        .Produces<UserResponseDto>()
        .Produces(StatusCodes.Status400BadRequest)
        .Produces(StatusCodes.Status401Unauthorized)
        .Produces(StatusCodes.Status404NotFound);

        // ============================================
        // RESET PASSWORD (ClinicAdmin)
        // ============================================
        group.MapPost("/{id:guid}/reset-password", async (
            Guid id,
            [FromBody] ResetPasswordRequestDto dto,
            [FromServices] IUserService userService,
            [FromServices] IValidator<ResetPasswordRequestDto> validator) =>
        {
            if (id == Guid.Empty)
                return Results.BadRequest(new { Error = "Invalid user ID" });

            var validation = await validator.ValidateAsync(dto);
            if (!validation.IsValid)
                return Results.BadRequest(new { Errors = validation.Errors.Select(e => e.ErrorMessage) });

            var updated = await userService.ResetPasswordAsync(id, dto);
            return Results.Ok(new { Message = "Password reset successfully", User = updated });
        })
        .RequirePermission("Users.ResetPassword")
        .WithName("ResetUserPassword")
        .WithSummary("Reset user password (ClinicAdmin)")
        .WithDescription("ClinicAdmin resets password for users in their clinic. No current password required.")
        .Produces<UserResponseDto>()
        .Produces(StatusCodes.Status400BadRequest)
        .Produces(StatusCodes.Status403Forbidden)
        .Produces(StatusCodes.Status404NotFound);

        // ============================================
        // ADMIN RESET PASSWORD (SuperAdmin)
        // ============================================
        group.MapPost("/{id:guid}/admin-reset-password", async (
            Guid id,
            [FromBody] ResetPasswordRequestDto dto,
            [FromServices] IUserService userService,
            [FromServices] IValidator<ResetPasswordRequestDto> validator,
            [FromServices] ITenantContext tenantContext) =>
        {
            if (id == Guid.Empty)
                return Results.BadRequest(new { Error = "Invalid user ID" });

            if (!tenantContext.IsSuperAdmin)
                return Results.Json(
                    new { Error = "Missing required permission: Users.ResetPassword" },
                    statusCode: StatusCodes.Status403Forbidden);

            var validation = await validator.ValidateAsync(dto);
            if (!validation.IsValid)
                return Results.BadRequest(new { Errors = validation.Errors.Select(e => e.ErrorMessage) });

            var updated = await userService.AdminResetPasswordAsync(id, dto);
            return Results.Ok(new { Message = "Password reset by SuperAdmin", User = updated });
        })
        .RequirePermission("Users.ResetPassword")  // ‚úÖ FIXED: Uses Users.ResetPassword (not AdminResetPassword)
        .WithName("AdminResetPassword")
        .WithSummary("SuperAdmin resets any user's password")
        .WithDescription("SuperAdmin can reset password for any user in any clinic.")
        .Produces<UserResponseDto>()
        .Produces(StatusCodes.Status400BadRequest)
        .Produces(StatusCodes.Status403Forbidden)
        .Produces(StatusCodes.Status404NotFound);
    }
}
========================================
File: ./NabdCare.Api/Endpoints/ClinicEndpoints.cs
========================================
using FluentValidation;
using Microsoft.AspNetCore.Mvc;
using NabdCare.Api.Extensions;
using NabdCare.Application.Common;
using NabdCare.Application.DTOs.Clinics;
using NabdCare.Application.Interfaces.Clinics;

namespace NabdCare.Api.Endpoints;

/// <summary>
/// Clinic management endpoints with multi-tenant security.
/// No try-catch blocks - exceptions bubble up to middleware.
/// </summary>
public static class ClinicEndpoints
{
    public static void MapClinicEndpoints(this IEndpointRouteBuilder app)
    {
        var group = app.MapGroup("/clinics")
            .WithTags("Clinics");

        // ============================================
        // CREATE CLINIC (SuperAdmin Only)
        // ============================================
        group.MapPost("/", async (
            [FromBody] CreateClinicRequestDto dto,
            [FromServices] IClinicService service,
            [FromServices] IValidator<CreateClinicRequestDto> validator) =>
        {
            var validation = await validator.ValidateAsync(dto);
            if (!validation.IsValid)
                return Results.BadRequest(new { Errors = validation.Errors.Select(e => e.ErrorMessage) });

            var created = await service.CreateClinicAsync(dto);
            return Results.Created($"/api/clinics/{created.Id}", created);
        })
        .RequirePermission("Clinics.Create")
        .WithName("CreateClinic")
        .WithSummary("Create a new clinic (SuperAdmin only)")
        .WithDescription("Creates a new clinic with subscription and initial configuration.")
        .Produces<ClinicResponseDto>(StatusCodes.Status201Created)
        .Produces(StatusCodes.Status400BadRequest)
        .Produces(StatusCodes.Status403Forbidden);

        // ============================================
        // GET CURRENT USER'S CLINIC
        // ============================================
        group.MapGet("/me", async (
            [FromServices] IClinicService service,
            [FromServices] ITenantContext tenantContext) =>
        {
            if (tenantContext.IsSuperAdmin)
                return Results.BadRequest(new { Error = "SuperAdmin does not belong to a clinic" });

            if (!tenantContext.ClinicId.HasValue)
                return Results.BadRequest(new { Error = "You don't belong to any clinic" });

            var clinic = await service.GetClinicByIdAsync(tenantContext.ClinicId.Value);
            
            return clinic != null 
                ? Results.Ok(clinic) 
                : Results.NotFound(new { Error = "Your clinic was not found" });
        })
        .RequireAuthorization()
        .WithName("GetMyClinic")
        .WithSummary("Get current user's clinic")
        .WithDescription("Returns the clinic that the authenticated user belongs to.")
        .Produces<ClinicResponseDto>(StatusCodes.Status200OK)
        .Produces(StatusCodes.Status400BadRequest)
        .Produces(StatusCodes.Status401Unauthorized)
        .Produces(StatusCodes.Status404NotFound);

        // ============================================
        // GET CLINIC BY ID
        // ============================================
        group.MapGet("/{id:guid}", async (
            Guid id,
            [FromServices] IClinicService service,
            [FromServices] ITenantContext tenantContext) =>
        {
            if (id == Guid.Empty)
                return Results.BadRequest(new { Error = "Invalid clinic ID" });

            var clinic = await service.GetClinicByIdAsync(id);
            if (clinic == null)
                return Results.NotFound(new { Error = $"Clinic {id} not found" });

            // SuperAdmin can view all clinics
            if (tenantContext.IsSuperAdmin)
                return Results.Ok(clinic);

            // Clinic users can only view their own clinic
            if (tenantContext.ClinicId.HasValue && tenantContext.ClinicId == id)
                return Results.Ok(clinic);

            return Results.Forbid();
        })
        .RequireAuthorization()
        .WithName("GetClinicById")
        .WithSummary("Get clinic by ID")
        .WithDescription("SuperAdmin: View any clinic. Clinic users: View own clinic only.")
        .Produces<ClinicResponseDto>(StatusCodes.Status200OK)
        .Produces(StatusCodes.Status400BadRequest)
        .Produces(StatusCodes.Status401Unauthorized)
        .Produces(StatusCodes.Status403Forbidden)
        .Produces(StatusCodes.Status404NotFound);

        // ============================================
        // GET ALL CLINICS (SuperAdmin Only)
        // ============================================
        group.MapGet("/", async (
            [FromServices] IClinicService service) =>
        {
            var clinics = await service.GetAllClinicsAsync();
            return Results.Ok(clinics);
        })
        .RequireAuthorization()
        .WithName("GetAllClinics")
        .WithSummary("Get all clinics (SuperAdmin only)")
        .WithDescription("Returns a list of all clinics in the system.")
        .Produces<IEnumerable<ClinicResponseDto>>(StatusCodes.Status200OK)
        .Produces(StatusCodes.Status403Forbidden);

        // ============================================
        // GET ACTIVE CLINICS (SuperAdmin Only)
        // ============================================
        group.MapGet("/active", async (
            [FromServices] IClinicService service) =>
        {
            var clinics = await service.GetActiveClinicsAsync();
            return Results.Ok(clinics);
        })
        .RequireAuthorization()
        .WithName("GetActiveClinics")
        .WithSummary("Get all active clinics (SuperAdmin only)")
        .WithDescription("Returns only clinics with Active status.")
        .Produces<IEnumerable<ClinicResponseDto>>(StatusCodes.Status200OK)
        .Produces(StatusCodes.Status403Forbidden);

        // ============================================
        // SEARCH CLINICS (SuperAdmin Only)
        // ============================================
        group.MapGet("/search", async (
            [FromQuery] string? query,
            [FromServices] IClinicService service) =>
        {
            if (string.IsNullOrWhiteSpace(query))
                return Results.BadRequest(new { Error = "Search query is required" });

            var clinics = await service.SearchClinicsAsync(query);
            return Results.Ok(clinics);
        })
        .RequirePermission("Clinics.ViewAll")
        .WithName("SearchClinics")
        .WithSummary("Search clinics by name, email, or phone (SuperAdmin only)")
        .WithDescription("Searches clinics using name, email, or phone number.")
        .Produces<IEnumerable<ClinicResponseDto>>(StatusCodes.Status200OK)
        .Produces(StatusCodes.Status400BadRequest)
        .Produces(StatusCodes.Status403Forbidden);

        // ============================================
        // UPDATE CLINIC
        // ============================================
        group.MapPut("/{id:guid}", async (
            Guid id,
            [FromBody] UpdateClinicRequestDto dto,
            [FromServices] IClinicService service,
            [FromServices] IValidator<UpdateClinicRequestDto> validator,
            [FromServices] ITenantContext tenantContext) =>
        {
            if (id == Guid.Empty)
                return Results.BadRequest(new { Error = "Invalid clinic ID" });

            var validation = await validator.ValidateAsync(dto);
            if (!validation.IsValid)
                return Results.BadRequest(new { Errors = validation.Errors.Select(e => e.ErrorMessage) });

            // SuperAdmin can update any clinic, ClinicAdmin can only update own clinic
            if (!tenantContext.IsSuperAdmin && tenantContext.ClinicId != id)
                return Results.Forbid();

            var updated = await service.UpdateClinicAsync(id, dto);
            
            return updated != null 
                ? Results.Ok(updated) 
                : Results.NotFound(new { Error = $"Clinic {id} not found" });
        })
        .RequirePermission("Clinics.Edit")
        .WithName("UpdateClinic")
        .WithSummary("Update clinic details")
        .WithDescription("SuperAdmin: Update any clinic. ClinicAdmin: Update own clinic only.")
        .Produces<ClinicResponseDto>(StatusCodes.Status200OK)
        .Produces(StatusCodes.Status400BadRequest)
        .Produces(StatusCodes.Status403Forbidden)
        .Produces(StatusCodes.Status404NotFound);

        // ============================================
        // UPDATE CLINIC STATUS (SuperAdmin Only)
        // ============================================
        group.MapPut("/{id:guid}/status", async (
            Guid id,
            [FromBody] UpdateClinicStatusDto dto,
            [FromServices] IClinicService service,
            [FromServices] IValidator<UpdateClinicStatusDto> validator) =>
        {
            if (id == Guid.Empty)
                return Results.BadRequest(new { Error = "Invalid clinic ID" });

            var validation = await validator.ValidateAsync(dto);
            if (!validation.IsValid)
                return Results.BadRequest(new { Errors = validation.Errors.Select(e => e.ErrorMessage) });

            var updated = await service.UpdateClinicStatusAsync(id, dto);
            
            return updated != null 
                ? Results.Ok(updated) 
                : Results.NotFound(new { Error = $"Clinic {id} not found" });
        })
        .RequirePermission("Clinics.ManageStatus")
        .WithName("UpdateClinicStatus")
        .WithSummary("Update clinic status (SuperAdmin only)")
        .WithDescription("Change clinic status (Active, Suspended, Inactive, Trial).")
        .Produces<ClinicResponseDto>(StatusCodes.Status200OK)
        .Produces(StatusCodes.Status400BadRequest)
        .Produces(StatusCodes.Status403Forbidden)
        .Produces(StatusCodes.Status404NotFound);

        // ============================================
        // ACTIVATE CLINIC (SuperAdmin Only)
        // ============================================
        group.MapPut("/{id:guid}/activate", async (
            Guid id,
            [FromServices] IClinicService service) =>
        {
            if (id == Guid.Empty)
                return Results.BadRequest(new { Error = "Invalid clinic ID" });

            var activated = await service.ActivateClinicAsync(id);
            
            return activated != null 
                ? Results.Ok(new { Message = $"Clinic {id} activated successfully", Clinic = activated }) 
                : Results.NotFound(new { Error = $"Clinic {id} not found" });
        })
        .RequirePermission("Clinics.ManageStatus")
        .WithName("ActivateClinic")
        .WithSummary("Activate a clinic (SuperAdmin only)")
        .WithDescription("Sets clinic status to Active.")
        .Produces<ClinicResponseDto>(StatusCodes.Status200OK)
        .Produces(StatusCodes.Status400BadRequest)
        .Produces(StatusCodes.Status403Forbidden)
        .Produces(StatusCodes.Status404NotFound);

        // ============================================
        // SUSPEND CLINIC (SuperAdmin Only)
        // ============================================
        group.MapPut("/{id:guid}/suspend", async (
            Guid id,
            [FromServices] IClinicService service) =>
        {
            if (id == Guid.Empty)
                return Results.BadRequest(new { Error = "Invalid clinic ID" });

            var suspended = await service.SuspendClinicAsync(id);
            
            return suspended != null 
                ? Results.Ok(new { Message = $"Clinic {id} suspended successfully", Clinic = suspended }) 
                : Results.NotFound(new { Error = $"Clinic {id} not found" });
        })
        .RequirePermission("Clinics.ManageStatus")
        .WithName("SuspendClinic")
        .WithSummary("Suspend a clinic (SuperAdmin only)")
        .WithDescription("Sets clinic status to Suspended. Users cannot login.")
        .Produces<ClinicResponseDto>(StatusCodes.Status200OK)
        .Produces(StatusCodes.Status400BadRequest)
        .Produces(StatusCodes.Status403Forbidden)
        .Produces(StatusCodes.Status404NotFound);

        // ============================================
        // SOFT DELETE CLINIC (SuperAdmin Only)
        // ============================================
        group.MapDelete("/{id:guid}", async (
            Guid id,
            [FromServices] IClinicService service) =>
        {
            if (id == Guid.Empty)
                return Results.BadRequest(new { Error = "Invalid clinic ID" });

            var success = await service.SoftDeleteClinicAsync(id);
            
            return success 
                ? Results.Ok(new { Message = $"Clinic {id} soft deleted successfully" }) 
                : Results.NotFound(new { Error = $"Clinic {id} not found" });
        })
        .RequirePermission("Clinics.Delete")
        .WithName("SoftDeleteClinic")
        .WithSummary("Soft delete a clinic (SuperAdmin only)")
        .WithDescription("Marks clinic as deleted. Can be restored. Users cannot login.")
        .Produces(StatusCodes.Status200OK)
        .Produces(StatusCodes.Status400BadRequest)
        .Produces(StatusCodes.Status403Forbidden)
        .Produces(StatusCodes.Status404NotFound);

        // ============================================
        // HARD DELETE CLINIC (SuperAdmin Only - DANGEROUS)
        // ============================================
        group.MapDelete("/{id:guid}/permanent", async (
            Guid id,
            [FromServices] IClinicService service,
            [FromServices] ITenantContext tenantContext) =>
        {
            if (id == Guid.Empty)
                return Results.BadRequest(new { Error = "Invalid clinic ID" });

            // Only SuperAdmin can hard delete
            if (!tenantContext.IsSuperAdmin)
                return Results.Forbid();

            var success = await service.DeleteClinicAsync(id);
            
            return success 
                ? Results.Ok(new { Message = $"Clinic {id} permanently deleted" }) 
                : Results.NotFound(new { Error = $"Clinic {id} not found" });
        })
        .RequirePermission("Clinics.HardDelete")
        .WithName("HardDeleteClinic")
        .WithSummary("Permanently delete a clinic (SuperAdmin only - IRREVERSIBLE)")
        .WithDescription("‚ö†Ô∏è DANGEROUS: Completely removes clinic and all related data from database.")
        .Produces(StatusCodes.Status200OK)
        .Produces(StatusCodes.Status400BadRequest)
        .Produces(StatusCodes.Status403Forbidden)
        .Produces(StatusCodes.Status404NotFound);

        // ============================================
        // GET CLINIC STATISTICS (SuperAdmin Only)
        // ============================================
        group.MapGet("/{id:guid}/stats", async (
            Guid id,
            [FromServices] IClinicService service) =>
        {
            if (id == Guid.Empty)
                return Results.BadRequest(new { Error = "Invalid clinic ID" });

            var stats = await service.GetClinicStatisticsAsync(id);
            
            return stats != null 
                ? Results.Ok(stats) 
                : Results.NotFound(new { Error = $"Clinic {id} not found" });
        })
        .RequirePermission("Clinics.ViewStats")
        .WithName("GetClinicStatistics")
        .WithSummary("Get clinic statistics (SuperAdmin only)")
        .WithDescription("Returns user count, subscription info, and other statistics.")
        .Produces(StatusCodes.Status200OK)
        .Produces(StatusCodes.Status400BadRequest)
        .Produces(StatusCodes.Status403Forbidden)
        .Produces(StatusCodes.Status404NotFound);
    }
}
========================================
File: ./NabdCare.Api/Endpoints/RoleEndpoints.cs
========================================
using FluentValidation;
using Microsoft.AspNetCore.Mvc;
using NabdCare.Api.Extensions;
using NabdCare.Application.Common;
using NabdCare.Application.DTOs.Roles;
using NabdCare.Application.Interfaces.Roles;

namespace NabdCare.Api.Endpoints;

public static class RoleEndpoints
{
    public static void MapRoleEndpoints(this IEndpointRouteBuilder app)
    {
        var group = app.MapGroup("/roles")
            .WithTags("Roles");

        // ============================================
        // üìã GET ALL ROLES
        // ============================================
        group.MapGet("/", async (
            [FromServices] IRoleService roleService,
            [FromServices] ITenantContext tenantContext) =>
        {
            // SuperAdmin sees all roles (system + templates + all clinic roles)
            // ClinicAdmin sees only their clinic's roles + templates
            var roles = await roleService.GetAllRolesAsync();
            return Results.Ok(roles);
        })
        .RequirePermission("Settings.ManageRoles")
        .WithSummary("Get all roles (filtered by tenant context)");

        // ============================================
        // üìã GET SYSTEM ROLES (SuperAdmin only)
        // ============================================
        group.MapGet("/system", async (
            [FromServices] IRoleService roleService,
            [FromServices] ITenantContext tenantContext) =>
        {
            if (!tenantContext.IsSuperAdmin)
                return Results.Forbid();

            var roles = await roleService.GetSystemRolesAsync();
            return Results.Ok(roles);
        })
        .RequirePermission("System.ManageRoles")
        .WithSummary("Get system roles (SuperAdmin, SupportManager, BillingManager)");

        // ============================================
        // üìã GET TEMPLATE ROLES
        // ============================================
        group.MapGet("/templates", async (
            [FromServices] IRoleService roleService) =>
        {
            var roles = await roleService.GetTemplateRolesAsync();
            return Results.Ok(roles);
        })
        .RequirePermission("Settings.ManageRoles")
        .WithSummary("Get template roles (for cloning to clinics)");

        // ============================================
        // üìã GET CLINIC ROLES
        // ============================================
        group.MapGet("/clinic/{clinicId:guid}", async (
            Guid clinicId,
            [FromServices] IRoleService roleService,
            [FromServices] ITenantContext tenantContext) =>
        {
            // SuperAdmin can view any clinic's roles
            // ClinicAdmin can only view their own clinic's roles (enforced by service)
            var roles = await roleService.GetClinicRolesAsync(clinicId);
            return Results.Ok(roles);
        })
        .RequirePermission("Settings.ManageRoles")
        .WithSummary("Get roles for a specific clinic");

        // ============================================
        // üîç GET ROLE BY ID
        // ============================================
        group.MapGet("/{id:guid}", async (
            Guid id,
            [FromServices] IRoleService roleService) =>
        {
            var role = await roleService.GetRoleByIdAsync(id);
            return role != null ? Results.Ok(role) : Results.NotFound();
        })
        .RequirePermission("Settings.ManageRoles")
        .WithSummary("Get role by ID");

        // ============================================
        // ‚ûï CREATE CUSTOM ROLE (Clinic-specific)
        // ============================================
        group.MapPost("/", async (
            [FromBody] CreateRoleRequestDto dto,
            [FromServices] IRoleService roleService,
            [FromServices] IValidator<CreateRoleRequestDto> validator) =>
        {
            var validation = await validator.ValidateAsync(dto);
            if (!validation.IsValid)
                return Results.BadRequest(new { Errors = validation.Errors.Select(e => e.ErrorMessage) });

            try
            {
                var created = await roleService.CreateRoleAsync(dto);
                return Results.Created($"/api/roles/{created.Id}", created);
            }
            catch (InvalidOperationException ex)
            {
                return Results.Conflict(new { Error = ex.Message });
            }
        })
        .RequirePermission("Settings.ManageRoles")
        .WithSummary("Create a custom clinic role");

        // ============================================
        // üîÑ CLONE TEMPLATE ROLE
        // ============================================
        group.MapPost("/clone/{templateRoleId:guid}", async (
            Guid templateRoleId,
            [FromBody] CloneRoleRequestDto dto,
            [FromServices] IRoleService roleService,
            [FromServices] IValidator<CloneRoleRequestDto> validator) =>
        {
            var validation = await validator.ValidateAsync(dto);
            if (!validation.IsValid)
                return Results.BadRequest(new { Errors = validation.Errors.Select(e => e.ErrorMessage) });

            try
            {
                var cloned = await roleService.CloneRoleAsync(templateRoleId, dto.ClinicId, dto.NewRoleName);
                return Results.Created($"/api/roles/{cloned.Id}", cloned);
            }
            catch (InvalidOperationException ex)
            {
                return Results.BadRequest(new { Error = ex.Message });
            }
        })
        .RequirePermission("Settings.ManageRoles")
        .WithSummary("Clone a template role for a clinic");

        // ============================================
        // ‚úèÔ∏è UPDATE ROLE
        // ============================================
        group.MapPut("/{id:guid}", async (
            Guid id,
            [FromBody] UpdateRoleRequestDto dto,
            [FromServices] IRoleService roleService,
            [FromServices] IValidator<UpdateRoleRequestDto> validator) =>
        {
            var validation = await validator.ValidateAsync(dto);
            if (!validation.IsValid)
                return Results.BadRequest(new { Errors = validation.Errors.Select(e => e.ErrorMessage) });

            try
            {
                var updated = await roleService.UpdateRoleAsync(id, dto);
                return updated != null ? Results.Ok(updated) : Results.NotFound();
            }
            catch (InvalidOperationException ex)
            {
                return Results.BadRequest(new { Error = ex.Message });
            }
        })
        .RequirePermission("Settings.ManageRoles")
        .WithSummary("Update role (cannot update system roles)");

        // ============================================
        // üóëÔ∏è DELETE ROLE
        // ============================================
        group.MapDelete("/{id:guid}", async (
            Guid id,
            [FromServices] IRoleService roleService) =>
        {
            try
            {
                var success = await roleService.DeleteRoleAsync(id);
                return success 
                    ? Results.Ok(new { Message = $"Role {id} deleted successfully" }) 
                    : Results.NotFound();
            }
            catch (InvalidOperationException ex)
            {
                return Results.BadRequest(new { Error = ex.Message });
            }
        })
        .RequirePermission("Settings.ManageRoles")
        .WithSummary("Delete role (cannot delete system roles or roles with users)");

        // ============================================
        // üîê GET ROLE PERMISSIONS
        // ============================================
        group.MapGet("/{id:guid}/permissions", async (
            Guid id,
            [FromServices] IRoleService roleService) =>
        {
            var permissions = await roleService.GetRolePermissionsAsync(id);
            return Results.Ok(permissions);
        })
        .RequirePermission("Permissions.View")
        .WithSummary("Get all permissions assigned to a role");

        // ============================================
        // ‚ûï ASSIGN PERMISSION TO ROLE
        // ============================================
        group.MapPost("/{roleId:guid}/permissions/{permissionId:guid}", async (
            Guid roleId,
            Guid permissionId,
            [FromServices] IRoleService roleService) =>
        {
            try
            {
                var success = await roleService.AssignPermissionToRoleAsync(roleId, permissionId);
                return success 
                    ? Results.Ok(new { Message = "Permission assigned successfully" })
                    : Results.Conflict(new { Message = "Permission already assigned" });
            }
            catch (InvalidOperationException ex)
            {
                return Results.BadRequest(new { Error = ex.Message });
            }
        })
        .RequirePermission("Permissions.Assign")
        .WithSummary("Assign a permission to a role");

        // ============================================
        // ‚ûñ REMOVE PERMISSION FROM ROLE
        // ============================================
        group.MapDelete("/{roleId:guid}/permissions/{permissionId:guid}", async (
            Guid roleId,
            Guid permissionId,
            [FromServices] IRoleService roleService) =>
        {
            try
            {
                var success = await roleService.RemovePermissionFromRoleAsync(roleId, permissionId);
                return success 
                    ? Results.Ok(new { Message = "Permission removed successfully" })
                    : Results.NotFound();
            }
            catch (InvalidOperationException ex)
            {
                return Results.BadRequest(new { Error = ex.Message });
            }
        })
        .RequirePermission("Permissions.Revoke")
        .WithSummary("Remove a permission from a role");
    }
}
========================================
File: ./NabdCare.Api/Endpoints/AuthEndpoints.cs
========================================
using Microsoft.AspNetCore.Mvc;
using NabdCare.Application.DTOs.Auth;
using NabdCare.Application.Interfaces.Auth;

namespace NabdCare.Api.Endpoints;

/// <summary>
/// Authentication endpoints for login, token refresh, and logout.
/// Author: Rabee-Qabaha
/// Updated: 2025-10-23 18:15:32 UTC
/// </summary>
public static class AuthEndpoints
{
    public static void MapAuthEndpoints(this IEndpointRouteBuilder app)
    {
        // ‚úÖ FIX: Remove /auth prefix (will be added by Program.cs)
        var authGroup = app.MapGroup("auth").WithTags("Authentication");
        //                            ‚Üë No leading slash!

        // ============================================
        // LOGIN
        // ============================================
        authGroup.MapPost("login", async (
            [FromBody] LoginRequestDto req,
            [FromServices] IAuthService authService,
            HttpContext http) =>
        {
            // Basic validation
            if (string.IsNullOrWhiteSpace(req.Email) || string.IsNullOrWhiteSpace(req.Password))
            {
                return Results.BadRequest(new
                {
                    error = new
                    {
                        message = "Email and Password are required.",
                        type = "ValidationError",
                        statusCode = 400
                    }
                });
            }

            var ip = GetClientIp(http);
            
            var (accessToken, refreshToken) = await authService.LoginAsync(req.Email, req.Password, ip);

            // Set refresh token as httpOnly cookie
            http.Response.Cookies.Append("refreshToken", refreshToken, new CookieOptions
            {
                HttpOnly = true,
                Secure = true,
                SameSite = SameSiteMode.Strict,
                Expires = DateTime.UtcNow.AddDays(7)
            });

            return Results.Ok(new AuthResponseDto(accessToken));
        })
        .AllowAnonymous() // ‚úÖ ADD THIS - Login doesn't require auth
        .WithName("Login")
        .WithSummary("User login with email and password")
        .WithOpenApi()
        .RequireRateLimiting("auth");

        // ============================================
        // REFRESH TOKEN
        // ============================================
        authGroup.MapPost("refresh", async (
            [FromServices] IAuthService authService,
            HttpContext http) =>
        {
            if (!http.Request.Cookies.TryGetValue("refreshToken", out var refreshToken))
            {
                return Results.Json(
                    new
                    {
                        error = new
                        {
                            message = "Refresh token not found.",
                            type = "UnauthorizedAccess",
                            statusCode = 401
                        }
                    },
                    statusCode: 401
                );
            }

            var ip = GetClientIp(http);
            
            var (newAccessToken, newRefreshToken) = await authService.RefreshTokenAsync(refreshToken, ip);

            // Rotate cookie
            http.Response.Cookies.Append("refreshToken", newRefreshToken, new CookieOptions
            {
                HttpOnly = true,
                Secure = true,
                SameSite = SameSiteMode.Strict,
                Expires = DateTime.UtcNow.AddDays(7)
            });

            return Results.Ok(new AuthResponseDto(newAccessToken));
        })
        .AllowAnonymous() // ‚úÖ ADD THIS - Refresh doesn't require auth
        .WithName("RefreshToken")
        .WithSummary("Refresh access token using refresh token cookie")
        .WithOpenApi()
        .RequireRateLimiting("auth");

        // ============================================
        // LOGOUT
        // ============================================
        authGroup.MapPost("logout", async (
            [FromServices] IAuthService authService,
            HttpContext http) =>
        {
            if (http.Request.Cookies.TryGetValue("refreshToken", out var refreshToken))
            {
                var ip = GetClientIp(http);
                await authService.LogoutAsync(refreshToken, ip);
                http.Response.Cookies.Delete("refreshToken");
            }

            return Results.NoContent();
        })
        .RequireAuthorization() // ‚úÖ Logout requires auth
        .WithName("Logout")
        .WithSummary("Logout and revoke refresh token")
        .WithOpenApi();
    }

    private static string GetClientIp(HttpContext http)
    {
        // X-Forwarded-For header (if behind proxy)
        var xfwd = http.Request.Headers["X-Forwarded-For"].FirstOrDefault();
        if (!string.IsNullOrEmpty(xfwd))
        {
            var first = xfwd.Split(',').Select(s => s.Trim()).FirstOrDefault();
            if (!string.IsNullOrEmpty(first))
                return first;
        }

        // Fallback to connection remote IP
        return http.Connection.RemoteIpAddress?.ToString() ?? "unknown";
    }
}
========================================
File: ./NabdCare.Api/Endpoints/PermissionEndpoints.cs
========================================
Ôªøusing Microsoft.AspNetCore.Mvc;
using NabdCare.Application.Common;
using NabdCare.Application.DTOs.Permissions;
using NabdCare.Application.Interfaces.Permissions;
using NabdCare.Api.Extensions;

namespace NabdCare.Api.Endpoints;

public static class PermissionEndpoints
{
    public static void MapPermissionEndpoints(this IEndpointRouteBuilder app)
    {
        var group = app.MapGroup("/permissions").WithTags("Permissions");

        // ============================================
        // üìã GET ALL PERMISSIONS
        // ============================================
        group.MapGet("/", async (
            [FromServices] IPermissionService service) =>
        {
            var result = await service.GetAllPermissionsAsync();
            return Results.Ok(result);
        })
        .RequirePermission("Permissions.View")
        .WithSummary("Get all permissions");

        // ============================================
        // üìä GET PERMISSIONS GROUPED BY CATEGORY
        // ============================================
        group.MapGet("/grouped", async (
            [FromServices] IPermissionService service) =>
        {
            var permissions = await service.GetAllPermissionsAsync();
            
            var grouped = permissions
                .GroupBy(p => p.Name.Split('.')[0]) // Group by prefix (e.g., "Users", "Patients")
                .OrderBy(g => g.Key)
                .Select(g => new
                {
                    Category = g.Key,
                    Permissions = g.OrderBy(p => p.Name).ToList()
                });

            return Results.Ok(grouped);
        })
        .RequirePermission("Permissions.View")
        .WithSummary("Get permissions grouped by category (Users, Patients, etc.)");

        // ============================================
        // üîç GET PERMISSION BY ID
        // ============================================
        group.MapGet("/{id:guid}", async (
            Guid id,
            [FromServices] IPermissionService service) =>
        {
            var permission = await service.GetPermissionByIdAsync(id);
            return permission != null ? Results.Ok(permission) : Results.NotFound();
        })
        .RequirePermission("Permissions.View")
        .WithSummary("Get permission by ID");

        // ============================================
        // üë§ GET MY PERMISSIONS (Current User)
        // ============================================
        group.MapGet("/me", async (
            [FromServices] IPermissionService service,
            [FromServices] IUserContext userContext) =>
        {
            var userIdStr = userContext.GetCurrentUserId();
            if (!Guid.TryParse(userIdStr, out var userId))
                return Results.Unauthorized();

            var roleIdStr = userContext.GetCurrentUserRoleId();
            if (!Guid.TryParse(roleIdStr, out var roleId))
                return Results.Unauthorized();

            var permissions = await service.GetUserEffectivePermissionsAsync(userId, roleId);
            return Results.Ok(permissions);
        })
        .RequireAuthorization()
        .WithSummary("Get current user's effective permissions (role + user-specific)");

        // ============================================
        // üîê GET PERMISSIONS FOR SPECIFIC USER
        // ============================================
        group.MapGet("/user/{userId:guid}", async (
            Guid userId,
            [FromServices] IPermissionService service,
            [FromServices] IUserContext userContext) =>
        {
            // Get user's role (you'll need to fetch this)
            // For now, returning user-specific permissions only
            var permissions = await service.GetPermissionsByUserAsync(userId);
            return Results.Ok(permissions);
        })
        .RequirePermission("Permissions.View")
        .WithSummary("Get user-specific permission overrides");

        // ============================================
        // üé≠ GET PERMISSIONS FOR ROLE
        // ============================================
        group.MapGet("/role/{roleId:guid}", async (
            Guid roleId,
            [FromServices] IPermissionService service) =>
        {
            var permissions = await service.GetPermissionsByRoleAsync(roleId);
            return Results.Ok(permissions);
        })
        .RequirePermission("Permissions.View")
        .WithSummary("Get all permissions assigned to a role");

        // ============================================
        // ‚ûï CREATE PERMISSION (SuperAdmin only)
        // ============================================
        group.MapPost("/", async (
            [FromBody] CreatePermissionDto dto,
            [FromServices] IPermissionService service) =>
        {
            try
            {
                var created = await service.CreatePermissionAsync(dto);
                return Results.Created($"/api/permissions/{created.Id}", created);
            }
            catch (InvalidOperationException ex)
            {
                return Results.Conflict(new { Error = ex.Message });
            }
        })
        .RequirePermission("System.ManageSettings")
        .WithSummary("Create a new permission (SuperAdmin only)");

        // ============================================
        // ‚úèÔ∏è UPDATE PERMISSION
        // ============================================
        group.MapPut("/{id:guid}", async (
            Guid id,
            [FromBody] UpdatePermissionDto dto,
            [FromServices] IPermissionService service) =>
        {
            var updated = await service.UpdatePermissionAsync(id, dto);
            return updated != null ? Results.Ok(updated) : Results.NotFound();
        })
        .RequirePermission("System.ManageSettings")
        .WithSummary("Update permission details");

        // ============================================
        // üóëÔ∏è DELETE PERMISSION
        // ============================================
        group.MapDelete("/{id:guid}", async (
            Guid id,
            [FromServices] IPermissionService service) =>
        {
            var deleted = await service.DeletePermissionAsync(id);
            return deleted ? Results.NoContent() : Results.NotFound();
        })
        .RequirePermission("System.ManageSettings")
        .WithSummary("Delete a permission (SuperAdmin only)");

        // ============================================
        // ‚ûï ASSIGN PERMISSION TO USER (Override)
        // ============================================
        group.MapPost("/assign-user", async (
            [FromBody] AssignPermissionToUserDto dto,
            [FromServices] IPermissionService service) =>
        {
            try
            {
                var assigned = await service.AssignPermissionToUserAsync(dto.UserId, dto.PermissionId);
                return assigned 
                    ? Results.Ok(new { message = "Permission assigned successfully" }) 
                    : Results.Conflict(new { message = "Permission already assigned to this user" });
            }
            catch (KeyNotFoundException ex)
            {
                return Results.NotFound(new { Error = ex.Message });
            }
        })
        .RequirePermission("Users.ManagePermissions")
        .WithSummary("Assign permission override to a specific user");

        // ============================================
        // ‚ûñ REMOVE PERMISSION FROM USER
        // ============================================
        group.MapDelete("/user/{userId:guid}/permission/{permissionId:guid}", async (
            Guid userId,
            Guid permissionId,
            [FromServices] IPermissionService service) =>
        {
            var removed = await service.RemovePermissionFromUserAsync(userId, permissionId);
            return removed 
                ? Results.Ok(new { message = "Permission removed successfully" })
                : Results.NotFound();
        })
        .RequirePermission("Users.ManagePermissions")
        .WithSummary("Remove permission override from user");
    }
}
========================================
File: ./NabdCare.Api/Endpoints/SubscriptionEndpoints.cs
========================================
Ôªøusing FluentValidation;
using Microsoft.AspNetCore.Mvc;
using NabdCare.Api.Extensions;
using NabdCare.Application.Common;
using NabdCare.Application.DTOs.Clinics.Subscriptions;
using NabdCare.Application.Interfaces.Clinics.Subscriptions;
using NabdCare.Domain.Enums;

namespace NabdCare.Api.Endpoints;

public static class SubscriptionEndpoints
{
    public static void MapSubscriptionEndpoints(this IEndpointRouteBuilder app)
    {
        var group = app.MapGroup("/subscriptions").WithTags("Subscriptions");

        // ============================================
        // GET SUBSCRIPTION BY ID
        // ============================================
        group.MapGet("/{id:guid}", async (
            Guid id,
            [FromServices] ISubscriptionService service) =>
        {
            try
            {
                var subscription = await service.GetByIdAsync(id);
                return subscription != null ? Results.Ok(subscription) : Results.NotFound();
            }
            catch (Exception ex)
            {
                return Results.Problem(detail: ex.Message, title: "Failed to retrieve subscription");
            }
        })
        .RequirePermission("Subscriptions.ViewAll")
        .WithSummary("Get subscription by ID");

        // ============================================
        // GET ACTIVE SUBSCRIPTION FOR CLINIC
        // ============================================
        group.MapGet("/clinic/{clinicId:guid}/active", async (
            Guid clinicId,
            [FromServices] ISubscriptionService service,
            [FromServices] ITenantContext tenantContext) =>
        {
            try
            {
                // Security check
                if (!tenantContext.IsSuperAdmin && tenantContext.ClinicId != clinicId)
                    return Results.Forbid();

                var subscriptions = await service.GetByClinicIdAsync(clinicId, false);
                var subscriptionsList = subscriptions.ToList();
                
                var activeSubscription = subscriptionsList
                    .Where(s => s.Status == SubscriptionStatus.Active && s.EndDate >= DateTime.UtcNow)
                    .OrderByDescending(s => s.StartDate)
                    .FirstOrDefault();

                if (activeSubscription == null)
                    return Results.NotFound(new { Error = "No active subscription found for this clinic" });

                var daysRemaining = (activeSubscription.EndDate - DateTime.UtcNow).Days;
                
                return Results.Ok(new
                {
                    Subscription = activeSubscription,
                    DaysRemaining = daysRemaining,
                    IsExpiringSoon = daysRemaining <= 30 && daysRemaining > 0,
                    IsExpired = daysRemaining < 0
                });
            }
            catch (Exception ex)
            {
                return Results.Problem(detail: ex.Message, title: "Failed to retrieve active subscription");
            }
        })
        .RequireAuthorization()
        .WithSummary("Get active subscription for clinic with expiry info");

        // ============================================
        // GET SUBSCRIPTIONS BY CLINIC
        // ============================================
        group.MapGet("/clinic/{clinicId:guid}", async (
            Guid clinicId,
            [FromQuery] bool includePayments,
            [FromServices] ISubscriptionService service,
            [FromServices] ITenantContext tenantContext) =>
        {
            try
            {
                // Security check
                if (!tenantContext.IsSuperAdmin && tenantContext.ClinicId != clinicId)
                    return Results.Forbid();

                var subscriptions = await service.GetByClinicIdAsync(clinicId, includePayments);
                return Results.Ok(subscriptions);
            }
            catch (Exception ex)
            {
                return Results.Problem(detail: ex.Message, title: "Failed to retrieve subscriptions");
            }
        })
        .RequireAuthorization()
        .WithSummary("Get all subscriptions for a clinic");

        // ============================================
        // CREATE SUBSCRIPTION (SuperAdmin only)
        // ============================================
        group.MapPost("/", async (
            [FromBody] CreateSubscriptionRequestDto dto,
            [FromServices] ISubscriptionService service,
            [FromServices] IValidator<CreateSubscriptionRequestDto> validator) =>
        {
            try
            {
                var validation = await validator.ValidateAsync(dto);
                if (!validation.IsValid)
                    return Results.BadRequest(new { Errors = validation.Errors.Select(e => e.ErrorMessage) });

                var created = await service.CreateSubscriptionAsync(dto);
                return Results.Created($"/api/subscriptions/{created.Id}", created);
            }
            catch (ArgumentException ex)
            {
                return Results.BadRequest(new { Error = ex.Message });
            }
            catch (Exception ex)
            {
                return Results.Problem(detail: ex.Message, title: "Failed to create subscription");
            }
        })
        .RequirePermission("Subscriptions.Create")
        .WithSummary("Create a new subscription (SuperAdmin only)");

        // ============================================
        // UPDATE SUBSCRIPTION
        // ============================================
        group.MapPut("/{id:guid}", async (
            Guid id,
            [FromBody] UpdateSubscriptionRequestDto dto,
            [FromServices] ISubscriptionService service,
            [FromServices] IValidator<UpdateSubscriptionRequestDto> validator) =>
        {
            try
            {
                var validation = await validator.ValidateAsync(dto);
                if (!validation.IsValid)
                    return Results.BadRequest(new { Errors = validation.Errors.Select(e => e.ErrorMessage) });

                var updated = await service.UpdateSubscriptionAsync(id, dto);
                return updated != null ? Results.Ok(updated) : Results.NotFound();
            }
            catch (ArgumentException ex)
            {
                return Results.BadRequest(new { Error = ex.Message });
            }
            catch (Exception ex)
            {
                return Results.Problem(detail: ex.Message, title: "Failed to update subscription");
            }
        })
        .RequirePermission("Subscriptions.Edit")
        .WithSummary("Update subscription");

        // ============================================
        // SOFT DELETE SUBSCRIPTION
        // ============================================
        group.MapDelete("/{id:guid}", async (
            Guid id,
            [FromServices] ISubscriptionService service) =>
        {
            try
            {
                var success = await service.SoftDeleteSubscriptionAsync(id);
                return success 
                    ? Results.Ok(new { Message = $"Subscription {id} soft deleted" }) 
                    : Results.NotFound();
            }
            catch (Exception ex)
            {
                return Results.Problem(detail: ex.Message, title: "Failed to delete subscription");
            }
        })
        .RequirePermission("Subscriptions.Cancel")
        .WithSummary("Soft delete subscription");

        // ============================================
        // HARD DELETE SUBSCRIPTION
        // ============================================
        group.MapDelete("/{id:guid}/hard", async (
            Guid id,
            [FromServices] ISubscriptionService service) =>
        {
            try
            {
                var success = await service.DeleteSubscriptionAsync(id);
                return success 
                    ? Results.Ok(new { Message = $"Subscription {id} permanently deleted" }) 
                    : Results.NotFound();
            }
            catch (Exception ex)
            {
                return Results.Problem(detail: ex.Message, title: "Failed to delete subscription");
            }
        })
        .RequirePermission("Subscriptions.Cancel")
        .WithSummary("Permanently delete subscription (DANGEROUS)");
    }
}
========================================
File: ./NabdCare.Api/Extensions/PermissionEndpointExtensions.cs
========================================
using Microsoft.Extensions.Logging;
using NabdCare.Application.Common;
using NabdCare.Application.Interfaces.Permissions;

namespace NabdCare.Api.Extensions;

/// <summary>
/// Extension methods for requiring permissions on endpoints.
/// Uses endpoint filters for per-route permission checking.
/// Author: Rabee-Qabaha
/// Updated: 2025-10-23 18:03:22 UTC
/// </summary>
public static class PermissionEndpointExtensions
{
    /// <summary>
    /// Requires the authenticated user to have the specified permission.
    /// Returns 401 if user is not authenticated, 403 if permission is denied.
    /// </summary>
    /// <param name="builder">The route handler builder</param>
    /// <param name="permission">Required permission (e.g., "Clinics.Create")</param>
    /// <returns>The route handler builder for chaining</returns>
    /// <exception cref="ArgumentException">Thrown when permission is null or empty</exception>
    public static RouteHandlerBuilder RequirePermission(
        this RouteHandlerBuilder builder,
        string permission)
    {
        if (string.IsNullOrWhiteSpace(permission))
            throw new ArgumentException("Permission cannot be null or empty", nameof(permission));

        return builder.AddEndpointFilter(async (context, next) =>
        {
            var httpContext = context.HttpContext;

            // Get services
            var permissionService = httpContext.RequestServices.GetRequiredService<IPermissionService>();
            var userContext = httpContext.RequestServices.GetRequiredService<IUserContext>();
            var logger = httpContext.RequestServices.GetRequiredService<ILogger<IPermissionService>>();

            // Validate user authentication
            var userIdStr = userContext.GetCurrentUserId();
            if (!Guid.TryParse(userIdStr, out var userId))
            {
                logger.LogWarning("Permission check failed: User not authenticated for permission {Permission}", permission);
                return Results.Json(
                    new { Error = "User not authenticated" },
                    statusCode: StatusCodes.Status401Unauthorized);
            }

            // Get role ID from claims
            var roleIdClaim = httpContext.User.FindFirst("RoleId")?.Value;
            if (string.IsNullOrEmpty(roleIdClaim) || !Guid.TryParse(roleIdClaim, out var roleId))
            {
                logger.LogWarning("Permission check failed: Invalid role claim for user {UserId}, permission {Permission}", 
                    userId, permission);
                return Results.Json(
                    new { Error = "Invalid role claim" },
                    statusCode: StatusCodes.Status401Unauthorized);
            }

            // Check permission
            var hasPermission = await permissionService.UserHasPermissionAsync(userId, roleId, permission);
            if (!hasPermission)
            {
                logger.LogWarning("Permission denied: User {UserId} (Role {RoleId}) attempted to access {Permission}", 
                    userId, roleId, permission);
                return Results.Json(
                    new { Error = $"Missing required permission: {permission}" },
                    statusCode: StatusCodes.Status403Forbidden);
            }

            // Permission granted
            logger.LogDebug("Permission granted: User {UserId} accessed {Permission}", userId, permission);
            return await next(context);
        });
    }
}
========================================
File: ./NabdCare.Api/Extensions/EndpointRegistrar.cs
========================================
using System.Reflection;

namespace NabdCare.Api.Extensions;

public static class EndpointRegistrar
{
    public static void MapAllEndpoints(this IEndpointRouteBuilder builder)
    {
        var methods = typeof(Program).Assembly.GetTypes()
            .Where(t => t.IsSealed && t.IsAbstract && t.IsPublic)
            .Where(t => t.Namespace == "NabdCare.Api.Endpoints") // only endpoints
            .SelectMany(t => t.GetMethods(BindingFlags.Public | BindingFlags.Static))
            .Where(m => m.Name.StartsWith("Map") 
                        && m.GetParameters().Length == 1
                        && m.Name != nameof(MapAllEndpoints));

        foreach (var method in methods)
        {
            method.Invoke(null, new object[] { builder });
        }
    }
}
========================================
File: ./NabdCare.Api/Extensions/RateLimitingExtensions.cs
========================================
using System.Security.Claims;
using System.Threading.RateLimiting;
using NabdCare.Api.Configurations;

namespace NabdCare.Api.Extensions;

public static class RateLimitingExtensions
{
    /// <summary>
    /// Adds rate limiting configuration for the application.
    /// - "auth" policy: fixed window partitioned by client IP (use for login)
    /// - "api" policy: token-bucket partitioned by authenticated user id (use for normal API endpoints)
    /// </summary>
    public static IServiceCollection AddRateLimiting(
        this IServiceCollection services,
        IConfiguration configuration)
    {
        // Bind rate limiting settings from appsettings.json
        var rateLimitSettings = configuration
            .GetSection("RateLimiting")
            .Get<RateLimitSettings>() ?? new RateLimitSettings();

        services.AddRateLimiter(options =>
        {
            // Use a partitioned policy approach so one client cannot exhaust the global quota
            // AUTH: fixed-window per client IP (good for login endpoints)
            options.AddPolicy("auth", httpContext =>
            {
                var authSettings = rateLimitSettings.Auth;
                var partitionKey = httpContext.Connection.RemoteIpAddress?.ToString() ?? "unknown";

                return RateLimitPartition.GetFixedWindowLimiter(
                    partitionKey,
                    _ => new FixedWindowRateLimiterOptions
                    {
                        PermitLimit = Math.Max(1, authSettings.PermitLimit),
                        Window = TimeSpan.FromMinutes(Math.Max(1, authSettings.WindowMinutes)),
                        QueueProcessingOrder = QueueProcessingOrder.OldestFirst,
                        QueueLimit = authSettings.QueueLimit
                    });
            });

            // API: token-bucket per authenticated user id, fallback to IP for anonymous
            options.AddPolicy("api", httpContext =>
            {
                var apiSettings = rateLimitSettings.Api;

                // Partition by user id claim if present, otherwise by client IP
                var userId = httpContext.User?.FindFirst(ClaimTypes.NameIdentifier)?.Value;
                var partitionKey = !string.IsNullOrWhiteSpace(userId)
                    ? $"user:{userId}"
                    : httpContext.Connection.RemoteIpAddress?.ToString() ?? "unknown";

                return RateLimitPartition.GetTokenBucketLimiter(
                    partitionKey,
                    _ => new TokenBucketRateLimiterOptions
                    {
                        TokenLimit = Math.Max(1, apiSettings.PermitLimit),
                        TokensPerPeriod = Math.Max(1, apiSettings.PermitLimit),
                        ReplenishmentPeriod = TimeSpan.FromMinutes(Math.Max(1, apiSettings.WindowMinutes)),
                        QueueProcessingOrder = QueueProcessingOrder.OldestFirst,
                        QueueLimit = apiSettings.QueueLimit
                    });
            });

            // Custom rejection handler with consistent error format
            options.RejectionStatusCode = StatusCodes.Status429TooManyRequests;
            options.OnRejected = async (context, cancellationToken) =>
            {
                // If configuration exists, use its window to compute retry info
                var retryAfterSeconds = (rateLimitSettings.Auth?.WindowMinutes ?? 1) * 60;
                var traceId = Guid.NewGuid().ToString("N");
                context.HttpContext.Response.Headers["X-Trace-Id"] = traceId;
                context.HttpContext.Response.StatusCode = StatusCodes.Status429TooManyRequests;
                context.HttpContext.Response.Headers["Retry-After"] = retryAfterSeconds.ToString();

                await context.HttpContext.Response.WriteAsJsonAsync(new
                {
                    error = new
                    {
                        message = "Too many requests. Please try again later.",
                        type = "RateLimitExceeded",
                        statusCode = 429,
                        traceId,
                        retryAfterSeconds
                    }
                }, cancellationToken);
            };
        });

        return services;
    }
}
========================================
File: ./NabdCare.Api/Program.cs
========================================
using System.Text.Json.Serialization;
using Microsoft.AspNetCore.HttpOverrides;
using Microsoft.AspNetCore.Mvc;
using NabdCare.Api.Configurations;
using NabdCare.Api.Extensions;
using NabdCare.Api.Middleware;
using NabdCare.Infrastructure.Persistence.DataSeed;

DotNetEnv.Env.Load();

var builder = WebApplication.CreateBuilder(args);

// Bind configurations
builder.Services.Configure<FrontendSettings>(builder.Configuration);

// Add services and application wiring (repositories, services, AutoMapper, validators, seeders)
builder.Services.AddNabdCareServices(builder.Configuration);

// Controllers + JSON enum strings
builder.Services.AddControllers()
    .AddJsonOptions(options =>
    {
        options.JsonSerializerOptions.Converters.Add(new JsonStringEnumConverter());
    });

// Centralized model validation response
builder.Services.Configure<ApiBehaviorOptions>(options =>
{
    options.InvalidModelStateResponseFactory = context =>
    {
        var errors = context.ModelState
            .Where(e => e.Value?.Errors.Count > 0)
            .SelectMany(e => e.Value!.Errors.Select(x => x.ErrorMessage))
            .ToList();

        var traceId = Guid.NewGuid().ToString("N");
        context.HttpContext.Response.Headers["X-Trace-Id"] = traceId;

        return new BadRequestObjectResult(new
        {
            error = new
            {
                message = "Validation failed",
                type = "ValidationError",
                statusCode = 400,
                traceId,
                details = errors
            }
        });
    };
});

// Authentication, rate limiting, swagger etc. (extension methods used in your project)
builder.Services.AddJwtAuthentication(builder.Configuration);
builder.Services.AddRateLimiting(builder.Configuration);
SwaggerConfig.AddSwagger(builder.Services);

// CORS
var allowedOrigins = builder.Configuration.GetSection("AllowedOrigins").Get<string[]>() ?? Array.Empty<string>();
builder.Services.AddCors(options =>
{
    options.AddPolicy("AllowFrontend", policy =>
        policy.WithOrigins(allowedOrigins)
            .AllowAnyHeader()
            .AllowAnyMethod()
            .AllowCredentials()
    );
});


// Database seeding (only in Development/Production, not Testing)
if (!builder.Environment.IsEnvironment("Testing"))
{
    // Register the DB seed hosted service once (single registration)
    // This will create a scope and run the DbSeeder during startup.
    builder.Services.AddHostedService<DbSeedHostedService>();
}

var app = builder.Build();

// Middleware pipeline
app.UseMiddleware<ErrorHandlingMiddleware>();
app.UseMiddleware<SubscriptionValidationMiddleware>();

if (!app.Environment.IsDevelopment())
{
    app.UseHttpsRedirection();
}

// Only use rate limiter in non-testing environments
if (!app.Environment.IsEnvironment("Testing"))
{
    app.UseRateLimiter();
}

app.UseSecurityHeaders();
app.UseCors("AllowFrontend");

app.UseForwardedHeaders(new ForwardedHeadersOptions
{
    ForwardedHeaders = ForwardedHeaders.XForwardedFor | ForwardedHeaders.XForwardedProto
});

app.UseAuthentication();
app.UseAuthorization();

// Map API groups
var api = app.MapGroup("/api");
api.MapAllEndpoints();

// Swagger
app.UseSwagger();
app.UseSwaggerUI(options =>
{
    options.SwaggerEndpoint("/swagger/v1/swagger.json", "NabdCare API v1");
    options.RoutePrefix = "swagger";
});

app.Run();

public partial class Program { }
========================================
File: ./NabdCare.Application/obj/Debug/net8.0/NabdCare.Application.AssemblyInfo.cs
========================================
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("NabdCare.Application")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+404a61d5f45213b03261a6fc7fff592311d4bbda")]
[assembly: System.Reflection.AssemblyProductAttribute("NabdCare.Application")]
[assembly: System.Reflection.AssemblyTitleAttribute("NabdCare.Application")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]

// Generated by the MSBuild WriteCodeFragment class.


========================================
File: ./NabdCare.Application/obj/Debug/net8.0/.NETCoreApp,Version=v8.0.AssemblyAttributes.cs
========================================
// <autogenerated />
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v8.0", FrameworkDisplayName = ".NET 8.0")]

========================================
File: ./NabdCare.Application/obj/Debug/net8.0/NabdCare.Application.GlobalUsings.g.cs
========================================
// <auto-generated/>
global using global::System;
global using global::System.Collections.Generic;
global using global::System.IO;
global using global::System.Linq;
global using global::System.Net.Http;
global using global::System.Threading;
global using global::System.Threading.Tasks;

========================================
File: ./NabdCare.Application/Validator/Auth/LoginRequestDtoValidator.cs
========================================
using FluentValidation;
using NabdCare.Application.DTOs.Auth;

namespace NabdCare.Application.Validator.Auth;

public class LoginRequestDtoValidator : AbstractValidator<LoginRequestDto>
{
    public LoginRequestDtoValidator()
    {
        RuleFor(x => x.Email)
            .NotEmpty().WithMessage("Email is required.")
            .EmailAddress().WithMessage("Invalid email format.")
            .MaximumLength(100).WithMessage("Email cannot exceed 100 characters.");

        RuleFor(x => x.Password)
            .NotEmpty().WithMessage("Password is required.")
            .MinimumLength(8).WithMessage("Password must be at least 8 characters.")
            .MaximumLength(128).WithMessage("Password cannot exceed 128 characters.");
    }
}
========================================
File: ./NabdCare.Application/Validator/Roles/CloneRoleValidator.cs
========================================
using FluentValidation;
using NabdCare.Application.DTOs.Roles;

namespace NabdCare.Application.Validator.Roles;

public class CloneRoleValidator : AbstractValidator<CloneRoleRequestDto>
{
    public CloneRoleValidator()
    {
        RuleFor(x => x.NewRoleName)
            .MaximumLength(100).WithMessage("Role name cannot exceed 100 characters")
            .Matches(@"^[a-zA-Z0-9\s\-_]+$")
            .When(x => !string.IsNullOrWhiteSpace(x.NewRoleName))
            .WithMessage("Role name can only contain letters, numbers, spaces, hyphens, and underscores");

        RuleFor(x => x.Description)
            .MaximumLength(500).WithMessage("Description cannot exceed 500 characters");
    }
}
========================================
File: ./NabdCare.Application/Validator/Roles/CreateRoleValidator.cs
========================================
using FluentValidation;
using NabdCare.Application.DTOs.Roles;

namespace NabdCare.Application.Validator.Roles;

public class CreateRoleValidator : AbstractValidator<CreateRoleRequestDto>
{
    public CreateRoleValidator()
    {
        RuleFor(x => x.Name)
            .NotEmpty().WithMessage("Role name is required")
            .MaximumLength(100).WithMessage("Role name cannot exceed 100 characters")
            .Matches(@"^[a-zA-Z0-9\s\-_]+$").WithMessage("Role name can only contain letters, numbers, spaces, hyphens, and underscores");

        RuleFor(x => x.Description)
            .MaximumLength(500).WithMessage("Description cannot exceed 500 characters");

        RuleFor(x => x.DisplayOrder)
            .GreaterThanOrEqualTo(0).WithMessage("Display order must be non-negative");

        RuleFor(x => x.ColorCode)
            .Matches(@"^#[0-9A-Fa-f]{6}$")
            .When(x => !string.IsNullOrWhiteSpace(x.ColorCode))
            .WithMessage("ColorCode must be a valid hex color (e.g., #3B82F6)");

        RuleFor(x => x.IconClass)
            .MaximumLength(50).WithMessage("IconClass cannot exceed 50 characters")
            .Matches(@"^[a-z0-9\-]+$")
            .When(x => !string.IsNullOrWhiteSpace(x.IconClass))
            .WithMessage("IconClass must contain only lowercase letters, numbers, and hyphens");
    }
}
========================================
File: ./NabdCare.Application/Validator/Roles/UpdateRoleValidator.cs
========================================
using FluentValidation;
using NabdCare.Application.DTOs.Roles;

namespace NabdCare.Application.Validator.Roles;

public class UpdateRoleValidator : AbstractValidator<UpdateRoleRequestDto>
{
    public UpdateRoleValidator()
    {
        RuleFor(x => x.Name)
            .NotEmpty().WithMessage("Role name is required")
            .MaximumLength(100).WithMessage("Role name cannot exceed 100 characters")
            .Matches(@"^[a-zA-Z0-9\s\-_]+$").WithMessage("Role name can only contain letters, numbers, spaces, hyphens, and underscores");

        RuleFor(x => x.Description)
            .MaximumLength(500).WithMessage("Description cannot exceed 500 characters");

        RuleFor(x => x.DisplayOrder)
            .GreaterThanOrEqualTo(0).WithMessage("Display order must be non-negative");

        RuleFor(x => x.ColorCode)
            .Matches(@"^#[0-9A-Fa-f]{6}$")
            .When(x => !string.IsNullOrWhiteSpace(x.ColorCode))
            .WithMessage("ColorCode must be a valid hex color (e.g., #3B82F6)");

        RuleFor(x => x.IconClass)
            .MaximumLength(50).WithMessage("IconClass cannot exceed 50 characters")
            .Matches(@"^[a-z0-9\-]+$")
            .When(x => !string.IsNullOrWhiteSpace(x.IconClass))
            .WithMessage("IconClass must contain only lowercase letters, numbers, and hyphens");
    }
}
========================================
File: ./NabdCare.Application/Validator/Clinics/CreateClinicValidator.cs
========================================
using FluentValidation;
using NabdCare.Application.DTOs.Clinics;

namespace NabdCare.Application.Validator.clinics;

public class CreateClinicValidator : AbstractValidator<CreateClinicRequestDto>
{
    public CreateClinicValidator()
    {
        RuleFor(x => x.Name)
            .NotEmpty().WithMessage("Clinic name is required.")
            .MaximumLength(255);

        RuleFor(x => x.Email)
            .NotEmpty().WithMessage("Email is required.")
            .EmailAddress().WithMessage("Invalid email format.")
            .MaximumLength(100);

        RuleFor(x => x.Phone)
            .MaximumLength(15).When(x => !string.IsNullOrWhiteSpace(x.Phone));

        RuleFor(x => x.SubscriptionStartDate)
            .LessThan(x => x.SubscriptionEndDate)
            .WithMessage("Subscription start date must be before end date.");

        RuleFor(x => x.SubscriptionFee)
            .GreaterThanOrEqualTo(0).WithMessage("Subscription fee must be non-negative.");
        
        RuleFor(x => x.SubscriptionType)
            .IsInEnum().WithMessage("Invalid subscription type specified.");

        RuleFor(x => x.BranchCount)
            .GreaterThan(0).WithMessage("Branch count must be greater than zero.");
    }
}
========================================
File: ./NabdCare.Application/Validator/Clinics/Subscriptions/UpdateSubscriptionValidator.cs
========================================
Ôªøusing FluentValidation;
using NabdCare.Application.DTOs.Clinics.Subscriptions;

namespace NabdCare.Application.Validator.Clinics.Subscriptions;
public class UpdateSubscriptionValidator : AbstractValidator<UpdateSubscriptionRequestDto>
{
    public UpdateSubscriptionValidator()
    {
        RuleFor(x => x.StartDate)
            .LessThan(x => x.EndDate)
            .WithMessage("StartDate must be before EndDate.");

        RuleFor(x => x.Fee)
            .GreaterThan(0).WithMessage("Fee must be greater than zero.");

        RuleFor(x => x.Type)
            .IsInEnum().WithMessage("Invalid subscription type.");

        RuleFor(x => x.Status)
            .IsInEnum().WithMessage("Invalid subscription status.");
    }
}
========================================
File: ./NabdCare.Application/Validator/Clinics/Subscriptions/CreateSubscriptionValidator.cs
========================================
Ôªøusing FluentValidation;
using NabdCare.Application.DTOs.Clinics.Subscriptions;

namespace NabdCare.Application.Validator.Clinics.Subscriptions;
public class CreateSubscriptionValidator : AbstractValidator<CreateSubscriptionRequestDto>
{
    public CreateSubscriptionValidator()
    {
        RuleFor(x => x.ClinicId)
            .NotEmpty().WithMessage("ClinicId is required.");

        RuleFor(x => x.StartDate)
            .LessThan(x => x.EndDate)
            .WithMessage("StartDate must be before EndDate.");

        RuleFor(x => x.Fee)
            .GreaterThan(0).WithMessage("Fee must be greater than zero.");

        RuleFor(x => x.Type)
            .IsInEnum().WithMessage("Invalid subscription type.");

        RuleFor(x => x.Status)
            .IsInEnum().WithMessage("Invalid subscription status.");
    }
}

========================================
File: ./NabdCare.Application/Validator/Clinics/UpdateClinicValidator.cs
========================================
using FluentValidation;
using NabdCare.Application.DTOs.Clinics;

namespace NabdCare.Application.Validator.clinics;

public class UpdateClinicValidator : AbstractValidator<UpdateClinicRequestDto>
{
    public UpdateClinicValidator()
    {
        RuleFor(x => x.Name)
            .NotEmpty().WithMessage("Clinic name is required.")
            .MaximumLength(255);

        RuleFor(x => x.Email)
            .NotEmpty().WithMessage("Email is required.")
            .EmailAddress().WithMessage("Invalid email format.")
            .MaximumLength(100);

        RuleFor(x => x.Phone)
            .MaximumLength(15).When(x => !string.IsNullOrWhiteSpace(x.Phone));

        RuleFor(x => x.SubscriptionStartDate)
            .LessThan(x => x.SubscriptionEndDate)
            .WithMessage("Subscription start date must be before end date.");

        RuleFor(x => x.SubscriptionFee)
            .GreaterThanOrEqualTo(0).WithMessage("Subscription fee must be non-negative.");
        
        RuleFor(x => x.SubscriptionType)
            .IsInEnum().WithMessage("Invalid subscription type specified.");

        RuleFor(x => x.BranchCount)
            .GreaterThan(0).WithMessage("Branch count must be greater than zero.");
    }
}
========================================
File: ./NabdCare.Application/Validator/Users/ResetPasswordRequestDtoValidator.cs
========================================
using FluentValidation;
using NabdCare.Application.DTOs.Users;

namespace NabdCare.Application.Validator.Users;

public class ResetPasswordRequestDtoValidator : AbstractValidator<ResetPasswordRequestDto>
{
    public ResetPasswordRequestDtoValidator()
    {
        RuleFor(x => x.NewPassword)
            .NotEmpty().WithMessage("New password is required.")
            .MinimumLength(12).WithMessage("Password must be at least 12 characters long.")
            .Matches(@"[A-Z]").WithMessage("Password must contain at least one uppercase letter.")
            .Matches(@"[a-z]").WithMessage("Password must contain at least one lowercase letter.")
            .Matches(@"[0-9]").WithMessage("Password must contain at least one digit.")
            .Matches(@"[\W_]").WithMessage("Password must contain at least one special character.");
    }
}
========================================
File: ./NabdCare.Application/Validator/Users/ChangePasswordRequestDtoValidator.cs
========================================
using FluentValidation;
using NabdCare.Application.DTOs.Users;

namespace NabdCare.Application.Validator.Users;

public class ChangePasswordRequestDtoValidator : AbstractValidator<ChangePasswordRequestDto>
{
    public ChangePasswordRequestDtoValidator()
    {
        RuleFor(x => x.CurrentPassword)
            .NotEmpty().WithMessage("Current password is required.");
        
        RuleFor(x => x.NewPassword)
            .NotEmpty().WithMessage("New password is required.")
            .MinimumLength(12).WithMessage("Password must be at least 12 characters long.")
            .Matches(@"[A-Z]").WithMessage("Password must contain at least one uppercase letter.")
            .Matches(@"[a-z]").WithMessage("Password must contain at least one lowercase letter.")
            .Matches(@"[0-9]").WithMessage("Password must contain at least one digit.")
            .Matches(@"[\W_]").WithMessage("Password must contain at least one special character.")
            .NotEqual(x => x.CurrentPassword)
            .WithMessage("New password must be different from current password.");
    }
}
========================================
File: ./NabdCare.Application/Validator/Users/UpdateUserRoleDtoValidator.cs
========================================
using FluentValidation;
using NabdCare.Application.DTOs.Users;

namespace NabdCare.Application.Validator.Users;

public class UpdateUserRoleDtoValidator : AbstractValidator<UpdateUserRoleDto>
{
    public UpdateUserRoleDtoValidator()
    {
        RuleFor(x => x.RoleId)
            .IsInEnum().WithMessage("Invalid role specified.");
    }
}
========================================
File: ./NabdCare.Application/Validator/Users/CreateUserRequestDtoValidator.cs
========================================
using FluentValidation;
using NabdCare.Application.DTOs.Users;

namespace NabdCare.Application.Validator.Users;

/// <summary>
/// Validator for CreateUserRequestDto.
/// Only validates input format - business logic validation happens in service layer.
/// </summary>
public class CreateUserRequestDtoValidator : AbstractValidator<CreateUserRequestDto>
{
    public CreateUserRequestDtoValidator()
    {
        RuleFor(x => x.Email)
            .NotEmpty().WithMessage("Email is required.")
            .EmailAddress().WithMessage("Invalid email format.")
            .MaximumLength(100).WithMessage("Email cannot exceed 100 characters.");

        RuleFor(x => x.Password)
            .NotEmpty().WithMessage("Password is required.")
            .MinimumLength(12).WithMessage("Password must be at least 12 characters long.")
            .Matches(@"[A-Z]").WithMessage("Password must contain at least one uppercase letter.")
            .Matches(@"[a-z]").WithMessage("Password must contain at least one lowercase letter.")
            .Matches(@"[0-9]").WithMessage("Password must contain at least one digit.")
            .Matches(@"[\W_]").WithMessage("Password must contain at least one special character.");

        RuleFor(x => x.FullName)
            .NotEmpty().WithMessage("Full name is required.")
            .MinimumLength(2).WithMessage("Full name must be at least 2 characters.")
            .MaximumLength(100).WithMessage("Full name cannot exceed 100 characters.")
            .Matches(@"^[a-zA-Z\s\-'.]+$")
            .WithMessage("Full name can only contain letters, spaces, hyphens, apostrophes, and periods.");

        RuleFor(x => x.RoleId)
            .NotEmpty().WithMessage("Role ID is required.");

        RuleFor(x => x.ClinicId)
            .NotEqual(Guid.Empty).When(x => x.ClinicId.HasValue)
            .WithMessage("Invalid clinic ID.");
    }
}
========================================
File: ./NabdCare.Application/Validator/Users/UserValidator.cs
========================================
Ôªøusing FluentValidation;
using NabdCare.Domain.Entities.Users;

namespace NabdCare.Application.Validator.Users;

public class UserValidator : AbstractValidator<User>
{
    public UserValidator()
    {
        RuleFor(user => user.Email)
            .NotEmpty().WithMessage("Email is required.")
            .EmailAddress().WithMessage("Invalid email format.");

        RuleFor(user => user.PasswordHash)
            .NotEmpty().WithMessage("Password is required.")
            .MinimumLength(6).WithMessage("Password must be at least 6 characters long.");

        RuleFor(user => user.ClinicId)
            .NotEmpty().WithMessage("ClinicId is required.");

        RuleFor(user => user.FullName)
            .NotEmpty().WithMessage("Full name is required.")
            .MaximumLength(100).WithMessage("Full name cannot exceed 100 characters.");

        RuleFor(user => user.Role)
            .NotEmpty().WithMessage("Role is required.")
            .IsInEnum().WithMessage("Invalid role specified.");
    }
}
========================================
File: ./NabdCare.Application/Validator/Users/UpdateUserRequestDtoValidator.cs
========================================
using FluentValidation;
using NabdCare.Application.DTOs.Users;

namespace NabdCare.Application.Validator.Users;

public class UpdateUserRequestDtoValidator : AbstractValidator<UpdateUserRequestDto>
{
    public UpdateUserRequestDtoValidator()
    {
        RuleFor(x => x.FullName)
            .NotEmpty().WithMessage("Full name is required.")
            .MaximumLength(100).WithMessage("Full name cannot exceed 100 characters.");

        RuleFor(x => x.RoleId)
            .NotEmpty().WithMessage("Role ID is required.")
            .NotEqual(Guid.Empty).WithMessage("Invalid role ID.");
    }
}
========================================
File: ./NabdCare.Application/DTOs/Auth/AuthResponseDto.cs
========================================

using TypeGen.Core.TypeAnnotations;

namespace NabdCare.Application.DTOs.Auth;

[ExportTsClass]
public class AuthResponseDto
{
    public string AccessToken { get; set; } = string.Empty;
    public AuthResponseDto(string accessToken)
    {
        AccessToken = accessToken;
    }
}
========================================
File: ./NabdCare.Application/DTOs/Auth/RefreshRequestDto.cs
========================================
Ôªøusing System.ComponentModel.DataAnnotations;
using TypeGen.Core.TypeAnnotations;

namespace NabdCare.Application.DTOs.Auth;

[ExportTsClass]
public class RefreshRequestDto
{
    [Required]
    public string RefreshToken { get; set; } = string.Empty;
}
========================================
File: ./NabdCare.Application/DTOs/Auth/LoginRequestDto.cs
========================================
Ôªøusing System.ComponentModel.DataAnnotations;
using TypeGen.Core.TypeAnnotations;

namespace NabdCare.Application.DTOs.Auth;

[ExportTsClass]
public class LoginRequestDto
{
    [Required]
    [EmailAddress]
    public new string Email { get; set; } = string.Empty;

    [Required]
    public new string Password { get; set; } = string.Empty;
}
========================================
File: ./NabdCare.Application/DTOs/Roles/RoleResponseDto.cs
========================================
using TypeGen.Core.TypeAnnotations;

namespace NabdCare.Application.DTOs.Roles;

[ExportTsClass]
public class RoleResponseDto
{
    public Guid Id { get; set; }
    public string Name { get; set; } = string.Empty;
    public string? Description { get; set; }
    
    /// <summary>
    /// If true, this is a system role (SuperAdmin, SupportManager, etc.).
    /// System roles cannot be modified or deleted.
    /// </summary>
    public bool IsSystemRole { get; set; }
    
    /// <summary>
    /// If true, this role can be cloned by clinics.
    /// </summary>
    public bool IsTemplate { get; set; }
    
    /// <summary>
    /// Clinic this role belongs to. Null for system roles and templates.
    /// </summary>
    public Guid? ClinicId { get; set; }
    
    /// <summary>
    /// Clinic name (if ClinicId is set).
    /// </summary>
    public string? ClinicName { get; set; }
    
    /// <summary>
    /// If this role was cloned from a template, this is the template's ID.
    /// </summary>
    public Guid? TemplateRoleId { get; set; }
    
    /// <summary>
    /// Display order for UI sorting.
    /// </summary>
    public int DisplayOrder { get; set; }
    
    /// <summary>
    /// Hex color code for UI display.
    /// </summary>
    public string? ColorCode { get; set; }
    
    /// <summary>
    /// FontAwesome icon class.
    /// </summary>
    public string? IconClass { get; set; }
    
    /// <summary>
    /// Number of users currently assigned to this role.
    /// </summary>
    public int UserCount { get; set; }
    
    /// <summary>
    /// Number of permissions assigned to this role.
    /// </summary>
    public int PermissionCount { get; set; }
    
    /// <summary>
    /// Audit fields
    /// </summary>
    public DateTime CreatedAt { get; set; }
    public string? CreatedBy { get; set; }
    public DateTime? UpdatedAt { get; set; }
    public string? UpdatedBy { get; set; }
}
========================================
File: ./NabdCare.Application/DTOs/Roles/UpdateRoleRequestDto.cs
========================================
using System.ComponentModel.DataAnnotations;
using TypeGen.Core.TypeAnnotations;

namespace NabdCare.Application.DTOs.Roles;

[ExportTsClass]
public class UpdateRoleRequestDto
{
    [Required]
    [MaxLength(100)]
    public string Name { get; set; } = string.Empty;

    [MaxLength(500)]
    public string? Description { get; set; }

    /// <summary>
    /// Display order for UI sorting.
    /// </summary>
    public int DisplayOrder { get; set; } = 100;

    /// <summary>
    /// Hex color code for UI display.
    /// </summary>
    [MaxLength(7)]
    [RegularExpression(@"^#[0-9A-Fa-f]{6}$", ErrorMessage = "ColorCode must be a valid hex color (e.g., #3B82F6)")]
    public string? ColorCode { get; set; }

    /// <summary>
    /// FontAwesome icon class for UI display.
    /// </summary>
    [MaxLength(50)]
    public string? IconClass { get; set; }

    /// <summary>
    /// Whether this role can be used as a template.
    /// Only SuperAdmin can modify this.
    /// </summary>
    public bool IsTemplate { get; set; }
}
========================================
File: ./NabdCare.Application/DTOs/Roles/CreateRoleRequestDto.cs
========================================
using System.ComponentModel.DataAnnotations;
using TypeGen.Core.TypeAnnotations;

namespace NabdCare.Application.DTOs.Roles;

[ExportTsClass]
public class CreateRoleRequestDto
{
    [Required]
    [MaxLength(100)]
    public string Name { get; set; } = string.Empty;

    [MaxLength(500)]
    public string? Description { get; set; }

    /// <summary>
    /// If null, creates role for current user's clinic (inferred from context).
    /// SuperAdmin can specify any clinicId or null for system-level roles.
    /// </summary>
    public Guid? ClinicId { get; set; }

    /// <summary>
    /// If true, this role can be used as a template for other clinics.
    /// Only SuperAdmin can create template roles.
    /// </summary>
    public bool IsTemplate { get; set; } = false;

    /// <summary>
    /// Display order for UI sorting (lower numbers appear first).
    /// Default: 100
    /// </summary>
    public int DisplayOrder { get; set; } = 100;

    /// <summary>
    /// Hex color code for UI display (e.g., "#3B82F6").
    /// Optional.
    /// </summary>
    [MaxLength(7)]
    [RegularExpression(@"^#[0-9A-Fa-f]{6}$", ErrorMessage = "ColorCode must be a valid hex color (e.g., #3B82F6)")]
    public string? ColorCode { get; set; }

    /// <summary>
    /// FontAwesome icon class for UI display (e.g., "fa-user-md").
    /// Optional.
    /// </summary>
    [MaxLength(50)]
    public string? IconClass { get; set; }

    /// <summary>
    /// Optional: If creating from a template, specify the template role ID.
    /// Permissions will be copied from the template.
    /// </summary>
    public Guid? TemplateRoleId { get; set; }
}
========================================
File: ./NabdCare.Application/DTOs/Roles/CloneRoleRequestDto.cs
========================================
using System.ComponentModel.DataAnnotations;
using TypeGen.Core.TypeAnnotations;

namespace NabdCare.Application.DTOs.Roles;

[ExportTsClass]
public class CloneRoleRequestDto
{
    /// <summary>
    /// Target clinic ID for the cloned role.
    /// If null, uses current user's clinic.
    /// </summary>
    public Guid? ClinicId { get; set; }

    /// <summary>
    /// Name for the cloned role.
    /// If null, uses template name.
    /// </summary>
    [MaxLength(100)]
    public string? NewRoleName { get; set; }

    /// <summary>
    /// Optional custom description.
    /// If null, uses template description.
    /// </summary>
    [MaxLength(500)]
    public string? Description { get; set; }

    /// <summary>
    /// Whether to copy permissions from the template.
    /// Default: true
    /// </summary>
    public bool CopyPermissions { get; set; } = true;
}
========================================
File: ./NabdCare.Application/DTOs/Permissions/AssignPermissionDto.cs
========================================
using System.ComponentModel.DataAnnotations;
using TypeGen.Core.TypeAnnotations;

namespace NabdCare.Application.DTOs.Permissions;

[ExportTsClass]
public class AssignPermissionDto
{
    [Required]
    public Guid PermissionId { get; set; }

    [Required]
    public Guid RoleId { get; set; }
}
========================================
File: ./NabdCare.Application/DTOs/Permissions/PermissionResponseDto.cs
========================================
using TypeGen.Core.TypeAnnotations;

namespace NabdCare.Application.DTOs.Permissions;

[ExportTsClass]
public class PermissionResponseDto
{
    public Guid Id { get; set; }
    public string Name { get; set; } = string.Empty;
    public string? Description { get; set; }
}
========================================
File: ./NabdCare.Application/DTOs/Permissions/UpdatePermissionDto.cs
========================================
using System.ComponentModel.DataAnnotations;
using TypeGen.Core.TypeAnnotations;

namespace NabdCare.Application.DTOs.Permissions;

[ExportTsClass]
public class UpdatePermissionDto
{
    [Required]
    [MaxLength(30)]
    public string Name { get; set; } = string.Empty;

    [MaxLength(255)]
    public string? Description { get; set; }
}
========================================
File: ./NabdCare.Application/DTOs/Permissions/AssignPermissionToUserDto.cs
========================================
using System.ComponentModel.DataAnnotations;
using TypeGen.Core.TypeAnnotations;

namespace NabdCare.Application.DTOs.Permissions;

[ExportTsClass]
public class AssignPermissionToUserDto
{
    [Required]
    public Guid PermissionId { get; set; }

    [Required]
    public Guid UserId { get; set; }
}
========================================
File: ./NabdCare.Application/DTOs/Permissions/CreatePermissionDto.cs
========================================
using System.ComponentModel.DataAnnotations;
using TypeGen.Core.TypeAnnotations;

namespace NabdCare.Application.DTOs.Permissions;

[ExportTsClass]
public class CreatePermissionDto
{
    [Required]
    [MaxLength(30)]
    public string Name { get; set; } = string.Empty;

    [MaxLength(255)]
    public string? Description { get; set; }
}
========================================
File: ./NabdCare.Application/DTOs/Clinics/ClinicStatisticsDto.cs
========================================
using NabdCare.Application.DTOs.Clinics.Subscriptions;
using NabdCare.Domain.Enums;
using TypeGen.Core.TypeAnnotations;

namespace NabdCare.Application.DTOs.Clinics;

[ExportTsClass]
public class ClinicStatisticsDto
{
    public Guid ClinicId { get; set; }
    public string ClinicName { get; set; } = string.Empty;
    public SubscriptionStatus Status { get; set; }
    public int BranchCount { get; set; }
    
    // Subscription stats
    public int TotalSubscriptions { get; set; }
    public SubscriptionResponseDto? CurrentSubscription { get; set; } // ‚úÖ Using your DTO
    public bool IsSubscriptionActive { get; set; }
    public int DaysUntilExpiration { get; set; }
    public bool IsExpiringSoon { get; set; }
    
    // Audit
    public DateTime CreatedAt { get; set; }
}
========================================
File: ./NabdCare.Application/DTOs/Clinics/CreateClinicRequestDto.cs
========================================
using NabdCare.Domain.Enums;
using TypeGen.Core.TypeAnnotations;

namespace NabdCare.Application.DTOs.Clinics;

[ExportTsClass]
public class CreateClinicRequestDto
{
    public string Name { get; set; } = string.Empty;
    public string Email { get; set; }
    public string? Phone { get; set; }
    public string? Address { get; set; }
    public SubscriptionStatus Status { get; set; } = SubscriptionStatus.Active;
    public DateTime SubscriptionStartDate { get; set; }
    public DateTime SubscriptionEndDate { get; set; }
    public SubscriptionType SubscriptionType { get; set; }
    public decimal SubscriptionFee { get; set; }
    public int BranchCount { get; set; } = 1;
}
========================================
File: ./NabdCare.Application/DTOs/Clinics/ClinicResponseDto.cs
========================================
using NabdCare.Domain.Enums;
using TypeGen.Core.TypeAnnotations;

namespace NabdCare.Application.DTOs.Clinics;

[ExportTsClass]
public class ClinicResponseDto
{
    public Guid Id { get; set; }
    public string Name { get; set; } = string.Empty;
    public string? Email { get; set; }
    public string? Phone { get; set; }
    public string? Address { get; set; }
    
    public SubscriptionStatus Status { get; set; }
    
    public DateTime SubscriptionStartDate { get; set; }
    public DateTime SubscriptionEndDate { get; set; }
    
    public SubscriptionType SubscriptionType { get; set; }
    
    public decimal SubscriptionFee { get; set; }
    public int BranchCount { get; set; }
}
========================================
File: ./NabdCare.Application/DTOs/Clinics/Subscriptions/SubscriptionResponseDto.cs
========================================
Ôªøusing NabdCare.Domain.Enums;
using TypeGen.Core.TypeAnnotations;

namespace NabdCare.Application.DTOs.Clinics.Subscriptions;

[ExportTsClass]
public class SubscriptionResponseDto
{
    public Guid Id { get; set; }
    public Guid ClinicId { get; set; }
    public DateTime StartDate { get; set; }
    public DateTime EndDate { get; set; }
    public SubscriptionType Type { get; set; }
    public decimal Fee { get; set; }
    public SubscriptionStatus Status { get; set; }
}
========================================
File: ./NabdCare.Application/DTOs/Clinics/Subscriptions/UpdateSubscriptionRequestDto.cs
========================================
Ôªøusing NabdCare.Domain.Enums;
using TypeGen.Core.TypeAnnotations;

namespace NabdCare.Application.DTOs.Clinics.Subscriptions;

[ExportTsClass]
public class UpdateSubscriptionRequestDto
{
    public DateTime StartDate { get; set; }
    public DateTime EndDate { get; set; }
    public SubscriptionType Type { get; set; }
    public decimal Fee { get; set; }
    public SubscriptionStatus Status { get; set; }
}
========================================
File: ./NabdCare.Application/DTOs/Clinics/Subscriptions/CreateSubscriptionRequestDto.cs
========================================
Ôªøusing NabdCare.Domain.Enums;
using TypeGen.Core.TypeAnnotations;

namespace NabdCare.Application.DTOs.Clinics.Subscriptions;

[ExportTsClass]
public class CreateSubscriptionRequestDto
{
    public Guid ClinicId { get; set; }
    public DateTime StartDate { get; set; }
    public DateTime EndDate { get; set; }
    public SubscriptionType Type { get; set; }
    public decimal Fee { get; set; }
    public SubscriptionStatus Status { get; set; } = SubscriptionStatus.Active;
}
========================================
File: ./NabdCare.Application/DTOs/Clinics/UpdateClinicStatusDto.cs
========================================
using NabdCare.Domain.Enums;
using TypeGen.Core.TypeAnnotations;

namespace NabdCare.Application.DTOs.Clinics;

/// <summary>
/// DTO for updating clinic subscription status only
/// </summary>
[ExportTsClass]
public class UpdateClinicStatusDto
{
    public SubscriptionStatus Status { get; set; }
}
========================================
File: ./NabdCare.Application/DTOs/Clinics/UpdateClinicRequestDto.cs
========================================
using TypeGen.Core.TypeAnnotations;

namespace NabdCare.Application.DTOs.Clinics;

[ExportTsClass]
public class UpdateClinicRequestDto : CreateClinicRequestDto { }
========================================
File: ./NabdCare.Application/DTOs/Users/ChangePasswordRequestDto.cs
========================================
using TypeGen.Core.TypeAnnotations;

namespace NabdCare.Application.DTOs.Users;

[ExportTsClass]
public class ChangePasswordRequestDto
{
    public string CurrentPassword { get; set; } = string.Empty;
    public string NewPassword { get; set; } = string.Empty;
}
========================================
File: ./NabdCare.Application/DTOs/Users/UpdateUserRequestDto.cs
========================================
using TypeGen.Core.TypeAnnotations;

namespace NabdCare.Application.DTOs.Users;

[ExportTsClass]
public class UpdateUserRequestDto
{
    public string FullName { get; set; } = string.Empty;
    public bool IsActive { get; set; } = true;
    public Guid RoleId { get; set; }
}
========================================
File: ./NabdCare.Application/DTOs/Users/ResetPasswordRequestDto.cs
========================================
using TypeGen.Core.TypeAnnotations;

namespace NabdCare.Application.DTOs.Users;

[ExportTsClass]
public class ResetPasswordRequestDto
{
    public string NewPassword { get; set; } = string.Empty;
}
========================================
File: ./NabdCare.Application/DTOs/Users/UserResponseDto.cs
========================================
using TypeGen.Core.TypeAnnotations;

namespace NabdCare.Application.DTOs.Users;

[ExportTsClass]
public class UserResponseDto
{
    public Guid Id { get; set; }
    public string Email { get; set; } = string.Empty;
    public string FullName { get; set; } = string.Empty;
    
    public Guid RoleId { get; set; }
    public string RoleName { get; set; } = string.Empty;
    
    public bool IsActive { get; set; }
    public Guid? ClinicId { get; set; }
    public string? ClinicName { get; set; }
}
========================================
File: ./NabdCare.Application/DTOs/Users/CreateUserRequestDto.cs
========================================
using TypeGen.Core.TypeAnnotations;

namespace NabdCare.Application.DTOs.Users;

[ExportTsClass]
public class CreateUserRequestDto
{
    public string Email { get; set; } = string.Empty;
    public string Password { get; set; } = string.Empty;
    public string FullName { get; set; } = string.Empty;
    public Guid RoleId { get; set; }
    public Guid? ClinicId { get; set; }
}
========================================
File: ./NabdCare.Application/DTOs/Users/UpdateUserRoleDto.cs
========================================
using TypeGen.Core.TypeAnnotations;

namespace NabdCare.Application.DTOs.Users;

[ExportTsClass]
public class UpdateUserRoleDto
{
    public Guid RoleId { get; set; } 
}
========================================
File: ./NabdCare.Application/Common/IUserContext.cs
========================================
Ôªønamespace NabdCare.Application.Common;

public interface IUserContext
{
    // Method to retrieve the current user's ID
    string GetCurrentUserId();
    string? GetCurrentUserRoleId();
}
========================================
File: ./NabdCare.Application/Common/UserContext.cs
========================================
Ôªøusing System.Security.Claims;
using Microsoft.AspNetCore.Http;

namespace NabdCare.Application.Common;

public class UserContext : IUserContext
{
    private readonly IHttpContextAccessor _httpContextAccessor;

    public UserContext(IHttpContextAccessor httpContextAccessor)
    {
        _httpContextAccessor = httpContextAccessor;
    }

    public string GetCurrentUserId()
    {
        return _httpContextAccessor.HttpContext?.User
            .FindFirst(ClaimTypes.NameIdentifier)?.Value ?? "anonymous";
    }

    public string? GetCurrentUserRoleId()
    {
        return _httpContextAccessor.HttpContext?.User
            .FindFirst("RoleId")?.Value;
    }
}
========================================
File: ./NabdCare.Application/Common/ITenantContext.cs
========================================
namespace NabdCare.Application.Common;

/// <summary>
/// Provides request-scoped information about the current authenticated user
/// </summary>
public interface ITenantContext
{
    /// <summary>
    /// The ID of the clinic the current user belongs to (null for SuperAdmin)
    /// </summary>
    Guid? ClinicId { get; }

    /// <summary>
    /// The ID of the currently authenticated user
    /// </summary>
    Guid? UserId { get; }

    /// <summary>
    /// The email of the currently authenticated user
    /// </summary>
    string? UserEmail { get; }

    /// <summary>
    /// Whether the current user is a SuperAdmin
    /// </summary>
    bool IsSuperAdmin { get; }

    /// <summary>
    /// The role of the current user
    /// </summary>
    string? UserRole { get; }

    /// <summary>
    /// Whether there is an authenticated user in the current request
    /// </summary>
    bool IsAuthenticated { get; }
}
========================================
File: ./NabdCare.Application/Common/TenantContext.cs
========================================
using System.Security.Claims;
using Microsoft.AspNetCore.Http;

namespace NabdCare.Application.Common;

public class TenantContext : ITenantContext
{
    private readonly IHttpContextAccessor _httpContextAccessor;

    public TenantContext(IHttpContextAccessor httpContextAccessor)
    {
        _httpContextAccessor = httpContextAccessor;
    }

    private ClaimsPrincipal? User => _httpContextAccessor.HttpContext?.User;

    public bool IsAuthenticated => User?.Identity?.IsAuthenticated ?? false;

    public Guid? ClinicId
    {
        get
        {
            var clinicIdClaim = User?.FindFirst("ClinicId")?.Value;
            return Guid.TryParse(clinicIdClaim, out var clinicId) ? clinicId : null;
        }
    }

    public Guid? UserId
    {
        get
        {
            // Try standard claim first, then custom "sub" claim
            var userIdClaim = User?.FindFirst(ClaimTypes.NameIdentifier)?.Value 
                              ?? User?.FindFirst("sub")?.Value;
            
            return Guid.TryParse(userIdClaim, out var userId) ? userId : null;
        }
    }

    public string? UserEmail =>
        User?.FindFirst(ClaimTypes.Email)?.Value 
        ?? User?.FindFirst("email")?.Value;

    public bool IsSuperAdmin
    {
        get
        {
            var role = User?.FindFirst(ClaimTypes.Role)?.Value 
                       ?? User?.FindFirst("role")?.Value;

            return string.Equals(role, "SuperAdmin", StringComparison.OrdinalIgnoreCase);
        }
    }

    public string? UserRole =>
        User?.FindFirst(ClaimTypes.Role)?.Value 
        ?? User?.FindFirst("role")?.Value;
}
========================================
File: ./NabdCare.Application/Mappings/RoleProfile.cs
========================================
using AutoMapper;
using NabdCare.Application.DTOs.Roles;
using NabdCare.Domain.Entities.Permissions;

namespace NabdCare.Application.Mappings;

public class RoleProfile : Profile
{
    public RoleProfile()
    {
        // Role -> RoleResponseDto
        CreateMap<Role, RoleResponseDto>()
            .ForMember(dest => dest.ClinicName, opt => opt.MapFrom(src => src.Clinic != null ? src.Clinic.Name : null))
            .ForMember(dest => dest.UserCount, opt => opt.Ignore()) // Set manually in service
            .ForMember(dest => dest.PermissionCount, opt => opt.Ignore()); // Set manually in service

        // CreateRoleRequestDto -> Role
        CreateMap<CreateRoleRequestDto, Role>()
            .ForMember(dest => dest.Id, opt => opt.Ignore())
            .ForMember(dest => dest.IsSystemRole, opt => opt.MapFrom(src => false)) // Only seeders create system roles
            .ForMember(dest => dest.CreatedAt, opt => opt.Ignore())
            .ForMember(dest => dest.CreatedBy, opt => opt.Ignore())
            .ForMember(dest => dest.Clinic, opt => opt.Ignore())
            .ForMember(dest => dest.Users, opt => opt.Ignore())
            .ForMember(dest => dest.RolePermissions, opt => opt.Ignore());

        // UpdateRoleRequestDto -> Role
        CreateMap<UpdateRoleRequestDto, Role>()
            .ForMember(dest => dest.Id, opt => opt.Ignore())
            .ForMember(dest => dest.IsSystemRole, opt => opt.Ignore()) // Cannot change
            .ForMember(dest => dest.ClinicId, opt => opt.Ignore()) // Cannot change
            .ForMember(dest => dest.TemplateRoleId, opt => opt.Ignore()) // Cannot change
            .ForMember(dest => dest.CreatedAt, opt => opt.Ignore())
            .ForMember(dest => dest.CreatedBy, opt => opt.Ignore())
            .ForMember(dest => dest.UpdatedAt, opt => opt.Ignore())
            .ForMember(dest => dest.UpdatedBy, opt => opt.Ignore())
            .ForMember(dest => dest.Clinic, opt => opt.Ignore())
            .ForMember(dest => dest.Users, opt => opt.Ignore())
            .ForMember(dest => dest.RolePermissions, opt => opt.Ignore());
    }
}
========================================
File: ./NabdCare.Application/Mappings/UserProfile.cs
========================================
using AutoMapper;
using NabdCare.Application.DTOs.Users;
using NabdCare.Domain.Entities.Users;

namespace NabdCare.Application.Mappings;

public class UserProfile : Profile
{
    public UserProfile()
    {
        // User -> UserResponseDto
        CreateMap<User, UserResponseDto>()
            .ForMember(dest => dest.RoleId, opt => opt.MapFrom(src => src.RoleId))
            .ForMember(dest => dest.RoleName, opt => opt.MapFrom(src => src.Role.Name)) // ‚úÖ Map role name
            .ForMember(dest => dest.ClinicName, opt => opt.MapFrom(src => src.Clinic != null ? src.Clinic.Name : null));

        // CreateUserRequestDto -> User
        CreateMap<CreateUserRequestDto, User>()
            .ForMember(dest => dest.RoleId, opt => opt.MapFrom(src => src.RoleId))
            .ForMember(dest => dest.Id, opt => opt.Ignore())
            .ForMember(dest => dest.PasswordHash, opt => opt.Ignore())
            .ForMember(dest => dest.CreatedAt, opt => opt.Ignore())
            .ForMember(dest => dest.CreatedBy, opt => opt.Ignore());

        // UpdateUserRequestDto -> User
        CreateMap<UpdateUserRequestDto, User>()
            .ForMember(dest => dest.RoleId, opt => opt.MapFrom(src => src.RoleId))
            .ForMember(dest => dest.Id, opt => opt.Ignore())
            .ForMember(dest => dest.Email, opt => opt.Ignore())
            .ForMember(dest => dest.PasswordHash, opt => opt.Ignore())
            .ForMember(dest => dest.ClinicId, opt => opt.Ignore())
            .ForMember(dest => dest.CreatedAt, opt => opt.Ignore())
            .ForMember(dest => dest.CreatedBy, opt => opt.Ignore());
    }
}
========================================
File: ./NabdCare.Application/Mappings/ClinicProfile.cs
========================================
using AutoMapper;
using NabdCare.Application.DTOs.Clinics;
using NabdCare.Application.DTOs.Clinics.Subscriptions;
using NabdCare.Domain.Entities.Clinics;

namespace NabdCare.Application.Mappings;

/// <summary>
/// AutoMapper profile for Clinic and Subscription entities.
/// Updated: 2025-10-22 by Rabee-Qabaha
/// </summary>
public class ClinicProfile : Profile
{
    public ClinicProfile()
    {
        // ============================================
        // CLINIC MAPPINGS
        // ============================================

        // DTO -> Entity (Create)
        CreateMap<CreateClinicRequestDto, Clinic>()
            .ForMember(d => d.Id, opt => opt.Ignore())
            .ForMember(d => d.Subscriptions, opt => opt.Ignore()) // Created separately in service
            .ForMember(d => d.CreatedAt, opt => opt.Ignore())
            .ForMember(d => d.CreatedBy, opt => opt.Ignore())
            .ForMember(d => d.UpdatedAt, opt => opt.Ignore())
            .ForMember(d => d.UpdatedBy, opt => opt.Ignore())
            .ForMember(d => d.IsDeleted, opt => opt.Ignore())
            .ForMember(d => d.DeletedAt, opt => opt.Ignore())
            .ForMember(d => d.DeletedBy, opt => opt.Ignore());

        // DTO -> Entity (Update)
        CreateMap<UpdateClinicRequestDto, Clinic>()
            .ForMember(d => d.Id, opt => opt.Ignore())
            .ForMember(d => d.Subscriptions, opt => opt.Ignore()) // Handled separately in service
            .ForMember(d => d.CreatedAt, opt => opt.Ignore())
            .ForMember(d => d.CreatedBy, opt => opt.Ignore())
            .ForMember(d => d.UpdatedAt, opt => opt.Ignore())
            .ForMember(d => d.UpdatedBy, opt => opt.Ignore())
            .ForMember(d => d.IsDeleted, opt => opt.Ignore())
            .ForMember(d => d.DeletedAt, opt => opt.Ignore())
            .ForMember(d => d.DeletedBy, opt => opt.Ignore());

        // Entity -> Response DTO
        CreateMap<Clinic, ClinicResponseDto>()
            .ForMember(dest => dest.Status, opt => opt.MapFrom(src => src.Status))
            .ForMember(dest => dest.SubscriptionType, opt => opt.MapFrom(src =>
                src.Subscriptions != null && src.Subscriptions.Any(s => !s.IsDeleted)
                    ? src.Subscriptions
                        .Where(s => !s.IsDeleted)
                        .OrderByDescending(s => s.StartDate)
                        .First().Type
                    : default))
            .ForMember(dest => dest.SubscriptionStartDate, opt => opt.MapFrom(src =>
                src.Subscriptions != null && src.Subscriptions.Any(s => !s.IsDeleted)
                    ? src.Subscriptions
                        .Where(s => !s.IsDeleted)
                        .OrderByDescending(s => s.StartDate)
                        .First().StartDate
                    : default(DateTime)))
            .ForMember(dest => dest.SubscriptionEndDate, opt => opt.MapFrom(src =>
                src.Subscriptions != null && src.Subscriptions.Any(s => !s.IsDeleted)
                    ? src.Subscriptions
                        .Where(s => !s.IsDeleted)
                        .OrderByDescending(s => s.StartDate)
                        .First().EndDate
                    : default(DateTime)))
            .ForMember(dest => dest.SubscriptionFee, opt => opt.MapFrom(src =>
                src.Subscriptions != null && src.Subscriptions.Any(s => !s.IsDeleted)
                    ? src.Subscriptions
                        .Where(s => !s.IsDeleted)
                        .OrderByDescending(s => s.StartDate)
                        .First().Fee
                    : 0m));

        // ============================================
        // SUBSCRIPTION MAPPINGS
        // ============================================

        // DTO -> Entity (Create)
        CreateMap<CreateSubscriptionRequestDto, Subscription>()
            .ForMember(d => d.Id, opt => opt.Ignore())
            .ForMember(d => d.Clinic, opt => opt.Ignore())
            .ForMember(d => d.Payments, opt => opt.Ignore())
            .ForMember(d => d.CreatedAt, opt => opt.Ignore())
            .ForMember(d => d.CreatedBy, opt => opt.Ignore())
            .ForMember(d => d.UpdatedAt, opt => opt.Ignore())
            .ForMember(d => d.UpdatedBy, opt => opt.Ignore())
            .ForMember(d => d.IsDeleted, opt => opt.Ignore())
            .ForMember(d => d.DeletedAt, opt => opt.Ignore())
            .ForMember(d => d.DeletedBy, opt => opt.Ignore());

        // DTO -> Entity (Update)
        CreateMap<UpdateSubscriptionRequestDto, Subscription>()
            .ForMember(d => d.Id, opt => opt.Ignore())
            .ForMember(d => d.ClinicId, opt => opt.Ignore())
            .ForMember(d => d.Clinic, opt => opt.Ignore())
            .ForMember(d => d.Payments, opt => opt.Ignore())
            .ForMember(d => d.CreatedAt, opt => opt.Ignore())
            .ForMember(d => d.CreatedBy, opt => opt.Ignore())
            .ForMember(d => d.UpdatedAt, opt => opt.Ignore())
            .ForMember(d => d.UpdatedBy, opt => opt.Ignore())
            .ForMember(d => d.IsDeleted, opt => opt.Ignore())
            .ForMember(d => d.DeletedAt, opt => opt.Ignore())
            .ForMember(d => d.DeletedBy, opt => opt.Ignore());

        // Entity -> Response DTO
        CreateMap<Subscription, SubscriptionResponseDto>();
    }
}
========================================
File: ./NabdCare.Application/Mappings/PermissionProfile.cs
========================================
using AutoMapper;
using NabdCare.Application.DTOs.Permissions;
using NabdCare.Domain.Entities.Permissions;

namespace NabdCare.Application.mappings;

public class PermissionProfile : Profile
{
    public PermissionProfile()
    {
        CreateMap<AppPermission, PermissionResponseDto>();
        CreateMap<CreatePermissionDto, AppPermission>();
        CreateMap<UpdatePermissionDto, AppPermission>();
    }
}
========================================
File: ./NabdCare.Application/Mappings/SubscriptionProfile.cs
========================================
Ôªøusing AutoMapper;
using NabdCare.Application.DTOs.Clinics.Subscriptions;
using NabdCare.Domain.Entities.Clinics;

namespace NabdCare.Application.Mappings;

/// <summary>
/// AutoMapper profile for Subscription entity mappings.
/// Author: Rabee-Qabaha
/// Updated: 2025-10-22 20:48:34 UTC
/// </summary>
public class SubscriptionProfile : Profile
{
    public SubscriptionProfile()
    {
        // ============================================
        // CREATE SUBSCRIPTION (DTO -> Entity)
        // ============================================
        CreateMap<CreateSubscriptionRequestDto, Subscription>()
            .ForMember(dest => dest.Id, opt => opt.Ignore())
            .ForMember(dest => dest.Clinic, opt => opt.Ignore())
            .ForMember(dest => dest.Payments, opt => opt.Ignore())
            .ForMember(dest => dest.CreatedAt, opt => opt.Ignore())
            .ForMember(dest => dest.CreatedBy, opt => opt.Ignore())
            .ForMember(dest => dest.UpdatedAt, opt => opt.Ignore())
            .ForMember(dest => dest.UpdatedBy, opt => opt.Ignore())
            .ForMember(dest => dest.IsDeleted, opt => opt.Ignore())
            .ForMember(dest => dest.DeletedAt, opt => opt.Ignore())
            .ForMember(dest => dest.DeletedBy, opt => opt.Ignore());

        // ============================================
        // UPDATE SUBSCRIPTION (DTO -> Entity)
        // ============================================
        CreateMap<UpdateSubscriptionRequestDto, Subscription>()
            .ForMember(dest => dest.Id, opt => opt.Ignore())
            .ForMember(dest => dest.ClinicId, opt => opt.Ignore())
            .ForMember(dest => dest.Clinic, opt => opt.Ignore())
            .ForMember(dest => dest.Payments, opt => opt.Ignore())
            .ForMember(dest => dest.CreatedAt, opt => opt.Ignore())
            .ForMember(dest => dest.CreatedBy, opt => opt.Ignore())
            .ForMember(dest => dest.UpdatedAt, opt => opt.Ignore())
            .ForMember(dest => dest.UpdatedBy, opt => opt.Ignore())
            .ForMember(dest => dest.IsDeleted, opt => opt.Ignore())
            .ForMember(dest => dest.DeletedAt, opt => opt.Ignore())
            .ForMember(dest => dest.DeletedBy, opt => opt.Ignore());

        // ============================================
        // SUBSCRIPTION RESPONSE (Entity -> DTO)
        // ============================================
        CreateMap<Subscription, SubscriptionResponseDto>();
    }
}
========================================
File: ./NabdCare.Application/Services/Auth/AuthService.cs
========================================
using System.Security.Cryptography;
using Microsoft.Extensions.Logging;
using NabdCare.Application.Interfaces;
using NabdCare.Application.Interfaces.Auth;
using NabdCare.Domain.Entities.Permissions;

namespace NabdCare.Application.Services.Auth;

public class AuthService : IAuthService
{
    private readonly IAuthRepository _authRepository;
    private readonly ITokenService _tokenService;
    private readonly ILogger<AuthService> _logger;

    private const int RefreshTokenDays = 7;

    public AuthService(IAuthRepository authRepository, ITokenService tokenService, ILogger<AuthService> logger)
    {
        _authRepository = authRepository;
        _tokenService = tokenService;
        _logger = logger;
    }

    public async Task<(string accessToken, string refreshToken)> LoginAsync(string email, string password, string requestIp)
    {
        try
        {
            var user = await _authRepository.AuthenticateUserAsync(email, password);
            if (user == null)
            {
                _logger.LogWarning("Login failed from IP {IP}", requestIp);
                throw new UnauthorizedAccessException("Invalid credentials.");
            }

            // ‚úÖ OPTIONAL: Revoke all existing refresh tokens for this user
            // Might annoy users with multiple devices
            await _authRepository.RevokeAllUserTokensAsync(user.Id, requestIp, "New login");

            var token = _tokenService.GenerateToken(
                user.Id.ToString(),
                user.Email,
                user.Role.Name,
                user.Role.Id,
                user.ClinicId,
                user.FullName
            );

            var refreshToken = new RefreshToken
            {
                UserId = user.Id,
                Token = Convert.ToBase64String(RandomNumberGenerator.GetBytes(64)),
                ExpiresAt = DateTime.UtcNow.AddDays(RefreshTokenDays),
                CreatedAt = DateTime.UtcNow,
                CreatedByIp = requestIp,
                IsRevoked = false
            };

            await _authRepository.SaveRefreshTokenAsync(user, refreshToken);
            _logger.LogInformation("User {UserId} logged in successfully from IP {IP}", user.Id, requestIp);

            return (token, refreshToken.Token);
        }
        catch (UnauthorizedAccessException)
        {
            throw;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Unexpected error during login from IP {IP}", requestIp);
            throw new InvalidOperationException("An error occurred during login. Please try again later.");
        }
    }

    public async Task<(string accessToken, string refreshToken)> RefreshTokenAsync(string refreshTokenValue, string requestIp)
    {
        try
        {
            var refreshToken = await _authRepository.GetRefreshTokenIncludingRevokedAsync(refreshTokenValue);
            
            if (refreshToken == null || refreshToken.ExpiresAt <= DateTime.UtcNow)
            {
                _logger.LogWarning("Invalid or expired refresh token from IP {IP}", requestIp);
                throw new UnauthorizedAccessException("Refresh token is invalid or expired.");
            }

            // Token reuse detection with family revocation
            if (refreshToken.IsRevoked)
            {
                _logger.LogWarning("‚ö†Ô∏è Token reuse detected for user {UserId} from IP {IP} - Revoking token family", 
                    refreshToken.UserId, requestIp);
                await _authRepository.RevokeTokenFamilyAsync(refreshToken);
                throw new UnauthorizedAccessException("Token reuse detected. All tokens have been revoked for security.");
            }

            var user = await _authRepository.AuthenticateUserByIdAsync(refreshToken.UserId);
            if (user == null || !user.IsActive)
            {
                _logger.LogWarning("Refresh attempted for inactive user {UserId}", refreshToken.UserId);
                throw new UnauthorizedAccessException("User is not active.");
            }

            // Revoke old token (rotation)
            await _authRepository.RevokeRefreshTokenAsync(refreshTokenValue, requestIp, "Rotated");

            //  Create new token with parent tracking
            var newToken = new RefreshToken
            {
                UserId = user.Id,
                Token = Convert.ToBase64String(RandomNumberGenerator.GetBytes(64)),
                ExpiresAt = DateTime.UtcNow.AddDays(RefreshTokenDays),
                CreatedAt = DateTime.UtcNow,
                CreatedByIp = requestIp,
                IsRevoked = false,
                ReplacedByToken = refreshToken.Token
            };

            await _authRepository.SaveRefreshTokenAsync(user, newToken);

            var token = _tokenService.GenerateToken(
                user.Id.ToString(),
                user.Email,
                user.Role.Name,
                user.Role.Id,
                user.ClinicId,
                user.FullName
            );
            
            _logger.LogInformation("Refresh token rotated for user {UserId} from IP {IP}", user.Id, requestIp);

            return (token, newToken.Token);
        }
        catch (UnauthorizedAccessException)
        {
            // Re-throw auth exceptions
            throw;
        }
        catch (Exception ex)
        {
            // Log but throw generic error
            _logger.LogError(ex, "Unexpected error during token refresh from IP {IP}", requestIp);
            throw new InvalidOperationException("An error occurred during token refresh. Please login again.");
        }
    }

    public async Task LogoutAsync(string refreshTokenValue, string requestIp)
    {
        try
        {
            await _authRepository.RevokeRefreshTokenAsync(refreshTokenValue, requestIp, "Logout");
            _logger.LogInformation("Logout successful from IP {IP}", requestIp);
        }
        catch (Exception ex)
        {
            // Log error but don't throw (logout should always succeed from client perspective)
            _logger.LogError(ex, "Error during logout from IP {IP} - ignoring", requestIp);
        }
    }
}
========================================
File: ./NabdCare.Application/Services/Roles/RoleService.cs
========================================
using AutoMapper;
using Microsoft.Extensions.Logging;
using NabdCare.Application.Common;
using NabdCare.Application.DTOs.Roles;
using NabdCare.Application.Interfaces.Roles;
using NabdCare.Domain.Entities.Permissions;

namespace NabdCare.Application.Services.Roles;

/// <summary>
/// Production-ready service for managing roles in the multi-tenant system.
/// Implements comprehensive error handling, validation, and logging.
/// Zero compiler warnings. Optimized for performance.
/// </summary>
public class RoleService : IRoleService
{
    private readonly IRoleRepository _roleRepository;
    private readonly ITenantContext _tenantContext;
    private readonly IUserContext _userContext;
    private readonly IMapper _mapper;
    private readonly ILogger<RoleService> _logger;

    public RoleService(
        IRoleRepository roleRepository,
        ITenantContext tenantContext,
        IUserContext userContext,
        IMapper mapper,
        ILogger<RoleService> logger)
    {
        _roleRepository = roleRepository ?? throw new ArgumentNullException(nameof(roleRepository));
        _tenantContext = tenantContext ?? throw new ArgumentNullException(nameof(tenantContext));
        _userContext = userContext ?? throw new ArgumentNullException(nameof(userContext));
        _mapper = mapper ?? throw new ArgumentNullException(nameof(mapper));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }

    #region QUERY METHODS

    public async Task<IEnumerable<RoleResponseDto>> GetAllRolesAsync()
    {
        try
        {
            var userId = _userContext.GetCurrentUserId();
            _logger.LogInformation("Getting all roles for user {UserId}", userId);

            IEnumerable<Role> roles;

            if (_tenantContext.IsSuperAdmin)
            {
                roles = await _roleRepository.GetAllRolesAsync();
                var rolesList = roles.ToList(); // ‚úÖ FIX: Materialize once to avoid multiple enumeration
                _logger.LogInformation("SuperAdmin {UserId} retrieved {Count} roles", userId, rolesList.Count);
                return await MapRolesToDtos(rolesList);
            }
            
            if (_tenantContext.ClinicId.HasValue)
            {
                var templates = await _roleRepository.GetTemplateRolesAsync();
                var clinicRoles = await _roleRepository.GetClinicRolesAsync(_tenantContext.ClinicId.Value);
                roles = templates.Concat(clinicRoles).DistinctBy(r => r.Id);
                var rolesList = roles.ToList(); // ‚úÖ FIX: Materialize once
                _logger.LogInformation("Clinic user {UserId} retrieved {Count} roles for clinic {ClinicId}", 
                    userId, rolesList.Count, _tenantContext.ClinicId.Value);
                return await MapRolesToDtos(rolesList);
            }
            
            _logger.LogWarning("User {UserId} has no tenant context, returning empty role list", userId);
            return Enumerable.Empty<RoleResponseDto>();
        }
        catch (Exception ex) when (ex is not UnauthorizedAccessException)
        {
            _logger.LogError(ex, "Error retrieving all roles for user {UserId}", _userContext.GetCurrentUserId());
            throw new InvalidOperationException("Failed to retrieve roles. Please try again.", ex);
        }
    }

    public async Task<IEnumerable<RoleResponseDto>> GetSystemRolesAsync()
    {
        try
        {
            var userId = _userContext.GetCurrentUserId();
            
            if (!_tenantContext.IsSuperAdmin)
            {
                _logger.LogWarning("Non-SuperAdmin user {UserId} attempted to access system roles", userId);
                throw new UnauthorizedAccessException("Only SuperAdmin can view system roles");
            }

            _logger.LogInformation("SuperAdmin {UserId} retrieving system roles", userId);
            var roles = await _roleRepository.GetSystemRolesAsync();
            var rolesList = roles.ToList(); // ‚úÖ FIX: Materialize once
            
            _logger.LogInformation("SuperAdmin {UserId} retrieved {Count} system roles", userId, rolesList.Count);
            return await MapRolesToDtos(rolesList);
        }
        catch (UnauthorizedAccessException)
        {
            throw; // Re-throw authorization exceptions
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error retrieving system roles for user {UserId}", _userContext.GetCurrentUserId());
            throw new InvalidOperationException("Failed to retrieve system roles. Please try again.", ex);
        }
    }

    public async Task<IEnumerable<RoleResponseDto>> GetTemplateRolesAsync()
    {
        try
        {
            _logger.LogInformation("User {UserId} retrieving template roles", _userContext.GetCurrentUserId());
            
            var roles = await _roleRepository.GetTemplateRolesAsync();
            var rolesList = roles.ToList(); // ‚úÖ FIX: Materialize once
            
            _logger.LogInformation("Retrieved {Count} template roles", rolesList.Count);
            return await MapRolesToDtos(rolesList);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error retrieving template roles");
            throw new InvalidOperationException("Failed to retrieve template roles. Please try again.", ex);
        }
    }

    public async Task<IEnumerable<RoleResponseDto>> GetClinicRolesAsync(Guid clinicId)
    {
        try
        {
            // Input validation
            if (clinicId == Guid.Empty)
            {
                throw new ArgumentException("Clinic ID cannot be empty", nameof(clinicId));
            }

            var userId = _userContext.GetCurrentUserId();
            _logger.LogInformation("User {UserId} retrieving roles for clinic {ClinicId}", userId, clinicId);

            // Authorization check
            if (!_tenantContext.IsSuperAdmin && _tenantContext.ClinicId != clinicId)
            {
                _logger.LogWarning("User {UserId} attempted to access roles for clinic {ClinicId} without permission", 
                    userId, clinicId);
                throw new UnauthorizedAccessException("You can only view roles for your own clinic");
            }

            var roles = await _roleRepository.GetClinicRolesAsync(clinicId);
            var rolesList = roles.ToList(); // ‚úÖ FIX: Materialize once
            
            _logger.LogInformation("Retrieved {Count} roles for clinic {ClinicId}", rolesList.Count, clinicId);
            return await MapRolesToDtos(rolesList);
        }
        catch (ArgumentException)
        {
            throw; // Re-throw validation exceptions
        }
        catch (UnauthorizedAccessException)
        {
            throw; // Re-throw authorization exceptions
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error retrieving roles for clinic {ClinicId}", clinicId);
            throw new InvalidOperationException($"Failed to retrieve roles for clinic {clinicId}. Please try again.", ex);
        }
    }

    public async Task<RoleResponseDto?> GetRoleByIdAsync(Guid id)
    {
        try
        {
            // Input validation
            if (id == Guid.Empty)
            {
                throw new ArgumentException("Role ID cannot be empty", nameof(id));
            }

            var userId = _userContext.GetCurrentUserId();
            _logger.LogInformation("User {UserId} retrieving role {RoleId}", userId, id);

            var role = await _roleRepository.GetRoleByIdAsync(id);
            if (role == null)
            {
                _logger.LogWarning("Role {RoleId} not found", id);
                return null;
            }

            // Authorization check
            if (!CanAccessRole(role))
            {
                _logger.LogWarning("User {UserId} attempted to access role {RoleId} without permission", userId, id);
                throw new UnauthorizedAccessException("You don't have permission to view this role");
            }

            var dto = _mapper.Map<RoleResponseDto>(role);
            dto.UserCount = await _roleRepository.GetRoleUserCountAsync(id);
            dto.PermissionCount = await _roleRepository.GetRolePermissionCountAsync(id);

            _logger.LogInformation("User {UserId} successfully retrieved role {RoleId}", userId, id);
            return dto;
        }
        catch (ArgumentException)
        {
            throw; // Re-throw validation exceptions
        }
        catch (UnauthorizedAccessException)
        {
            throw; // Re-throw authorization exceptions
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error retrieving role {RoleId}", id);
            throw new InvalidOperationException($"Failed to retrieve role {id}. Please try again.", ex);
        }
    }

    public async Task<IEnumerable<string>> GetRolePermissionsAsync(Guid roleId)
    {
        try
        {
            // Input validation
            if (roleId == Guid.Empty)
            {
                throw new ArgumentException("Role ID cannot be empty", nameof(roleId));
            }

            var userId = _userContext.GetCurrentUserId();
            _logger.LogInformation("User {UserId} retrieving permissions for role {RoleId}", userId, roleId);

            var role = await _roleRepository.GetRoleByIdAsync(roleId);
            if (role == null)
            {
                _logger.LogWarning("Role {RoleId} not found", roleId);
                throw new KeyNotFoundException($"Role {roleId} not found");
            }

            // Authorization check
            if (!CanAccessRole(role))
            {
                _logger.LogWarning("User {UserId} attempted to access permissions for role {RoleId} without permission", 
                    userId, roleId);
                throw new UnauthorizedAccessException("You don't have permission to view this role's permissions");
            }

            var permissionIds = await _roleRepository.GetRolePermissionIdsAsync(roleId);
            var permissionIdsList = permissionIds.ToList(); // ‚úÖ FIX: Materialize once
            
            _logger.LogInformation("Retrieved {Count} permissions for role {RoleId}", permissionIdsList.Count, roleId);
            return permissionIdsList.Select(p => p.ToString());
        }
        catch (ArgumentException)
        {
            throw; // Re-throw validation exceptions
        }
        catch (KeyNotFoundException)
        {
            throw; // Re-throw not found exceptions
        }
        catch (UnauthorizedAccessException)
        {
            throw; // Re-throw authorization exceptions
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error retrieving permissions for role {RoleId}", roleId);
            throw new InvalidOperationException($"Failed to retrieve permissions for role {roleId}. Please try again.", ex);
        }
    }

    #endregion

    #region COMMAND METHODS

    public async Task<RoleResponseDto> CreateRoleAsync(CreateRoleRequestDto dto)
    {
        try
        {
            // Input validation
            if (dto == null)
            {
                throw new ArgumentNullException(nameof(dto));
            }

            if (string.IsNullOrWhiteSpace(dto.Name))
            {
                throw new ArgumentException("Role name is required", nameof(dto.Name));
            }

            var userId = _userContext.GetCurrentUserId();
            _logger.LogInformation("User {UserId} creating role {RoleName}", userId, dto.Name);

            // Determine target clinic and validate permissions
            var targetClinicId = await ValidateCreateRolePermissions(dto);

            // Check for duplicate name
            if (await _roleRepository.RoleNameExistsAsync(dto.Name, targetClinicId))
            {
                _logger.LogWarning("Role with name '{RoleName}' already exists in context {ClinicId}", 
                    dto.Name, targetClinicId);
                throw new InvalidOperationException($"A role with name '{dto.Name}' already exists in this context");
            }

            // Map and create
            var role = _mapper.Map<Role>(dto);
            role.Id = Guid.NewGuid();
            role.ClinicId = targetClinicId;
            role.IsSystemRole = false;
            role.CreatedAt = DateTime.UtcNow;
            role.CreatedBy = userId;
            role.IsDeleted = false;

            var created = await _roleRepository.CreateRoleAsync(role);

            // Copy permissions from template if specified
            if (dto.TemplateRoleId.HasValue)
            {
                await CopyPermissionsFromTemplate(created.Id, dto.TemplateRoleId.Value);
            }

            _logger.LogInformation("User {UserId} successfully created role {RoleId} ({RoleName})", 
                userId, created.Id, created.Name);

            var responseDto = _mapper.Map<RoleResponseDto>(created);
            responseDto.UserCount = 0;
            responseDto.PermissionCount = await _roleRepository.GetRolePermissionCountAsync(created.Id);

            return responseDto;
        }
        catch (ArgumentException)
        {
            throw; // Re-throw validation exceptions
        }
        catch (InvalidOperationException)
        {
            throw; // Re-throw business logic exceptions
        }
        catch (UnauthorizedAccessException)
        {
            throw; // Re-throw authorization exceptions
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error creating role {RoleName} for user {UserId}", 
                dto.Name, _userContext.GetCurrentUserId());
            throw new InvalidOperationException("Failed to create role. Please try again.", ex);
        }
    }

    public async Task<RoleResponseDto> CloneRoleAsync(Guid templateRoleId, Guid? targetClinicId, string? newRoleName)
    {
        try
        {
            // Input validation
            if (templateRoleId == Guid.Empty)
            {
                throw new ArgumentException("Template role ID cannot be empty", nameof(templateRoleId));
            }

            var userId = _userContext.GetCurrentUserId();
            _logger.LogInformation("User {UserId} cloning role {TemplateRoleId} to clinic {ClinicId}", 
                userId, templateRoleId, targetClinicId);

            // Get and validate template role
            var templateRole = await _roleRepository.GetRoleByIdAsync(templateRoleId);
            if (templateRole == null)
            {
                _logger.LogWarning("Template role {TemplateRoleId} not found", templateRoleId);
                throw new KeyNotFoundException($"Template role {templateRoleId} not found");
            }

            if (!templateRole.IsTemplate)
            {
                _logger.LogWarning("Role {RoleId} is not a template role", templateRoleId);
                throw new InvalidOperationException("Can only clone template roles");
            }

            // Determine actual target clinic and validate permissions
            var actualTargetClinicId = await ValidateCloneRolePermissions(targetClinicId);

            // Generate role name
            var roleName = string.IsNullOrWhiteSpace(newRoleName) ? templateRole.Name : newRoleName.Trim();

            // Check for duplicate
            if (await _roleRepository.RoleNameExistsAsync(roleName, actualTargetClinicId))
            {
                _logger.LogWarning("Role with name '{RoleName}' already exists in clinic {ClinicId}", 
                    roleName, actualTargetClinicId);
                throw new InvalidOperationException($"A role with name '{roleName}' already exists in this clinic");
            }

            // Clone role
            var clonedRole = new Role
            {
                Id = Guid.NewGuid(),
                Name = roleName,
                Description = templateRole.Description,
                ClinicId = actualTargetClinicId,
                IsSystemRole = false,
                IsTemplate = false,
                TemplateRoleId = templateRoleId,
                DisplayOrder = templateRole.DisplayOrder,
                ColorCode = templateRole.ColorCode,
                IconClass = templateRole.IconClass,
                CreatedAt = DateTime.UtcNow,
                CreatedBy = userId,
                IsDeleted = false
            };

            var created = await _roleRepository.CreateRoleAsync(clonedRole);

            // Copy permissions from template
            await CopyPermissionsFromTemplate(created.Id, templateRoleId);

            _logger.LogInformation("User {UserId} successfully cloned role {TemplateRoleId} to {NewRoleId} for clinic {ClinicId}", 
                userId, templateRoleId, created.Id, actualTargetClinicId);

            var responseDto = _mapper.Map<RoleResponseDto>(created);
            responseDto.UserCount = 0;
            responseDto.PermissionCount = await _roleRepository.GetRolePermissionCountAsync(created.Id);

            return responseDto;
        }
        catch (ArgumentException)
        {
            throw; // Re-throw validation exceptions
        }
        catch (KeyNotFoundException)
        {
            throw; // Re-throw not found exceptions
        }
        catch (InvalidOperationException)
        {
            throw; // Re-throw business logic exceptions
        }
        catch (UnauthorizedAccessException)
        {
            throw; // Re-throw authorization exceptions
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error cloning role {TemplateRoleId} for user {UserId}", 
                templateRoleId, _userContext.GetCurrentUserId());
            throw new InvalidOperationException("Failed to clone role. Please try again.", ex);
        }
    }

    public async Task<RoleResponseDto?> UpdateRoleAsync(Guid id, UpdateRoleRequestDto dto)
    {
        try
        {
            // Input validation
            if (id == Guid.Empty)
            {
                throw new ArgumentException("Role ID cannot be empty", nameof(id));
            }

            if (dto == null)
            {
                throw new ArgumentNullException(nameof(dto));
            }

            if (string.IsNullOrWhiteSpace(dto.Name))
            {
                throw new ArgumentException("Role name is required", nameof(dto.Name));
            }

            var userId = _userContext.GetCurrentUserId();
            _logger.LogInformation("User {UserId} updating role {RoleId}", userId, id);

            var role = await _roleRepository.GetRoleByIdAsync(id);
            if (role == null)
            {
                _logger.LogWarning("Role {RoleId} not found", id);
                return null;
            }

            // Business rule validation
            if (role.IsSystemRole)
            {
                _logger.LogWarning("User {UserId} attempted to update system role {RoleId}", userId, id);
                throw new InvalidOperationException("Cannot update system roles");
            }

            // Authorization check
            if (!CanAccessRole(role))
            {
                _logger.LogWarning("User {UserId} attempted to update role {RoleId} without permission", userId, id);
                throw new UnauthorizedAccessException("You don't have permission to update this role");
            }

            // Check for duplicate name (excluding current role)
            if (await _roleRepository.RoleNameExistsAsync(dto.Name, role.ClinicId, id))
            {
                _logger.LogWarning("Role with name '{RoleName}' already exists", dto.Name);
                throw new InvalidOperationException($"A role with name '{dto.Name}' already exists");
            }

            // Only SuperAdmin can change IsTemplate
            if (!_tenantContext.IsSuperAdmin && dto.IsTemplate != role.IsTemplate)
            {
                _logger.LogWarning("Non-SuperAdmin user {UserId} attempted to change template status for role {RoleId}", 
                    userId, id);
                throw new UnauthorizedAccessException("Only SuperAdmin can change template status");
            }

            // Update fields
            role.Name = dto.Name.Trim();
            role.Description = dto.Description?.Trim();
            role.DisplayOrder = dto.DisplayOrder;
            role.ColorCode = dto.ColorCode?.Trim();
            role.IconClass = dto.IconClass?.Trim();
            role.IsTemplate = dto.IsTemplate;
            role.UpdatedAt = DateTime.UtcNow;
            role.UpdatedBy = userId;

            var updated = await _roleRepository.UpdateRoleAsync(role);

            _logger.LogInformation("User {UserId} successfully updated role {RoleId}", userId, id);

            // ‚úÖ FIX: Handle nullable properly
            if (updated == null)
            {
                _logger.LogWarning("Role {RoleId} disappeared after update", id);
                return null;
            }

            var responseDto = _mapper.Map<RoleResponseDto>(updated);
            responseDto.UserCount = await _roleRepository.GetRoleUserCountAsync(id);
            responseDto.PermissionCount = await _roleRepository.GetRolePermissionCountAsync(id);

            return responseDto;
        }
        catch (ArgumentException)
        {
            throw; // Re-throw validation exceptions
        }
        catch (InvalidOperationException)
        {
            throw; // Re-throw business logic exceptions
        }
        catch (UnauthorizedAccessException)
        {
            throw; // Re-throw authorization exceptions
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error updating role {RoleId} for user {UserId}", 
                id, _userContext.GetCurrentUserId());
            throw new InvalidOperationException($"Failed to update role {id}. Please try again.", ex);
        }
    }

    public async Task<bool> DeleteRoleAsync(Guid id)
    {
        try
        {
            // Input validation
            if (id == Guid.Empty)
            {
                throw new ArgumentException("Role ID cannot be empty", nameof(id));
            }

            var userId = _userContext.GetCurrentUserId();
            _logger.LogInformation("User {UserId} deleting role {RoleId}", userId, id);

            var role = await _roleRepository.GetRoleByIdAsync(id);
            if (role == null)
            {
                _logger.LogWarning("Role {RoleId} not found", id);
                return false;
            }

            // Business rule validations
            if (role.IsSystemRole)
            {
                _logger.LogWarning("User {UserId} attempted to delete system role {RoleId}", userId, id);
                throw new InvalidOperationException("Cannot delete system roles");
            }

            // Authorization check
            if (!CanAccessRole(role))
            {
                _logger.LogWarning("User {UserId} attempted to delete role {RoleId} without permission", userId, id);
                throw new UnauthorizedAccessException("You don't have permission to delete this role");
            }

            // Check for assigned users
            var userCount = await _roleRepository.GetRoleUserCountAsync(id);
            if (userCount > 0)
            {
                _logger.LogWarning("Cannot delete role {RoleId} with {UserCount} assigned users", id, userCount);
                throw new InvalidOperationException(
                    $"Cannot delete role with {userCount} assigned user(s). Reassign users first.");
            }

            // Check template status
            if (role.IsTemplate)
            {
                _logger.LogWarning("Cannot delete template role {RoleId}", id);
                throw new InvalidOperationException(
                    "Cannot delete template roles. Set IsTemplate to false first.");
            }

            var deleted = await _roleRepository.DeleteRoleAsync(id);

            if (deleted)
            {
                _logger.LogInformation("User {UserId} successfully deleted role {RoleId}", userId, id);
            }
            else
            {
                _logger.LogWarning("Failed to delete role {RoleId}", id);
            }

            return deleted;
        }
        catch (ArgumentException)
        {
            throw; // Re-throw validation exceptions
        }
        catch (InvalidOperationException)
        {
            throw; // Re-throw business logic exceptions
        }
        catch (UnauthorizedAccessException)
        {
            throw; // Re-throw authorization exceptions
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error deleting role {RoleId} for user {UserId}", 
                id, _userContext.GetCurrentUserId());
            throw new InvalidOperationException($"Failed to delete role {id}. Please try again.", ex);
        }
    }

    #endregion

    #region PERMISSION MANAGEMENT

    public async Task<bool> AssignPermissionToRoleAsync(Guid roleId, Guid permissionId)
    {
        try
        {
            // Input validation
            if (roleId == Guid.Empty)
            {
                throw new ArgumentException("Role ID cannot be empty", nameof(roleId));
            }

            if (permissionId == Guid.Empty)
            {
                throw new ArgumentException("Permission ID cannot be empty", nameof(permissionId));
            }

            var userId = _userContext.GetCurrentUserId();
            _logger.LogInformation("User {UserId} assigning permission {PermissionId} to role {RoleId}", 
                userId, permissionId, roleId);

            var role = await _roleRepository.GetRoleByIdAsync(roleId);
            if (role == null)
            {
                _logger.LogWarning("Role {RoleId} not found", roleId);
                throw new KeyNotFoundException($"Role {roleId} not found");
            }

            // Authorization checks
            if (role.IsSystemRole && !_tenantContext.IsSuperAdmin)
            {
                _logger.LogWarning("Non-SuperAdmin user {UserId} attempted to modify system role {RoleId} permissions", 
                    userId, roleId);
                throw new UnauthorizedAccessException("Only SuperAdmin can modify system role permissions");
            }

            if (!CanAccessRole(role))
            {
                _logger.LogWarning("User {UserId} attempted to modify role {RoleId} without permission", userId, roleId);
                throw new UnauthorizedAccessException("You don't have permission to modify this role");
            }

            var assigned = await _roleRepository.AssignPermissionToRoleAsync(roleId, permissionId);

            if (assigned)
            {
                _logger.LogInformation("User {UserId} successfully assigned permission {PermissionId} to role {RoleId}", 
                    userId, permissionId, roleId);
            }
            else
            {
                _logger.LogInformation("Permission {PermissionId} already assigned to role {RoleId}", 
                    permissionId, roleId);
            }

            return assigned;
        }
        catch (ArgumentException)
        {
            throw; // Re-throw validation exceptions
        }
        catch (KeyNotFoundException)
        {
            throw; // Re-throw not found exceptions
        }
        catch (UnauthorizedAccessException)
        {
            throw; // Re-throw authorization exceptions
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error assigning permission {PermissionId} to role {RoleId}", 
                permissionId, roleId);
            throw new InvalidOperationException(
                $"Failed to assign permission {permissionId} to role {roleId}. Please try again.", ex);
        }
    }

    public async Task<bool> RemovePermissionFromRoleAsync(Guid roleId, Guid permissionId)
    {
        try
        {
            // Input validation
            if (roleId == Guid.Empty)
            {
                throw new ArgumentException("Role ID cannot be empty", nameof(roleId));
            }

            if (permissionId == Guid.Empty)
            {
                throw new ArgumentException("Permission ID cannot be empty", nameof(permissionId));
            }

            var userId = _userContext.GetCurrentUserId();
            _logger.LogInformation("User {UserId} removing permission {PermissionId} from role {RoleId}", 
                userId, permissionId, roleId);

            var role = await _roleRepository.GetRoleByIdAsync(roleId);
            if (role == null)
            {
                _logger.LogWarning("Role {RoleId} not found", roleId);
                throw new KeyNotFoundException($"Role {roleId} not found");
            }

            // Authorization checks
            if (role.IsSystemRole && !_tenantContext.IsSuperAdmin)
            {
                _logger.LogWarning("Non-SuperAdmin user {UserId} attempted to modify system role {RoleId} permissions", 
                    userId, roleId);
                throw new UnauthorizedAccessException("Only SuperAdmin can modify system role permissions");
            }

            if (!CanAccessRole(role))
            {
                _logger.LogWarning("User {UserId} attempted to modify role {RoleId} without permission", userId, roleId);
                throw new UnauthorizedAccessException("You don't have permission to modify this role");
            }

            var removed = await _roleRepository.RemovePermissionFromRoleAsync(roleId, permissionId);

            if (removed)
            {
                _logger.LogInformation("User {UserId} successfully removed permission {PermissionId} from role {RoleId}", 
                    userId, permissionId, roleId);
            }
            else
            {
                _logger.LogWarning("Permission {PermissionId} not found in role {RoleId}", permissionId, roleId);
            }

            return removed;
        }
        catch (ArgumentException)
        {
            throw; // Re-throw validation exceptions
        }
        catch (KeyNotFoundException)
        {
            throw; // Re-throw not found exceptions
        }
        catch (UnauthorizedAccessException)
        {
            throw; // Re-throw authorization exceptions
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error removing permission {PermissionId} from role {RoleId}", 
                permissionId, roleId);
            throw new InvalidOperationException(
                $"Failed to remove permission {permissionId} from role {roleId}. Please try again.", ex);
        }
    }

    public async Task<int> BulkAssignPermissionsAsync(Guid roleId, IEnumerable<Guid> permissionIds)
    {
        try
        {
            // Input validation
            if (roleId == Guid.Empty)
            {
                throw new ArgumentException("Role ID cannot be empty", nameof(roleId));
            }

            if (permissionIds == null)
            {
                throw new ArgumentNullException(nameof(permissionIds));
            }

            var permissionIdsList = permissionIds.Where(p => p != Guid.Empty).ToList();
            if (permissionIdsList.Count == 0)
            {
                throw new ArgumentException("At least one valid permission ID is required", nameof(permissionIds));
            }

            var userId = _userContext.GetCurrentUserId();
            _logger.LogInformation("User {UserId} bulk assigning {Count} permissions to role {RoleId}", 
                userId, permissionIdsList.Count, roleId);

            var role = await _roleRepository.GetRoleByIdAsync(roleId);
            if (role == null)
            {
                _logger.LogWarning("Role {RoleId} not found", roleId);
                throw new KeyNotFoundException($"Role {roleId} not found");
            }

            // Authorization checks
            if (role.IsSystemRole && !_tenantContext.IsSuperAdmin)
            {
                _logger.LogWarning("Non-SuperAdmin user {UserId} attempted to modify system role {RoleId} permissions", 
                    userId, roleId);
                throw new UnauthorizedAccessException("Only SuperAdmin can modify system role permissions");
            }

            if (!CanAccessRole(role))
            {
                _logger.LogWarning("User {UserId} attempted to modify role {RoleId} without permission", userId, roleId);
                throw new UnauthorizedAccessException("You don't have permission to modify this role");
            }

            var count = await _roleRepository.BulkAssignPermissionsAsync(roleId, permissionIdsList);

            _logger.LogInformation("User {UserId} successfully assigned {Count} permissions to role {RoleId}", 
                userId, count, roleId);

            return count;
        }
        catch (ArgumentException)
        {
            throw; // Re-throw validation exceptions
        }
        catch (KeyNotFoundException)
        {
            throw; // Re-throw not found exceptions
        }
        catch (UnauthorizedAccessException)
        {
            throw; // Re-throw authorization exceptions
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error bulk assigning permissions to role {RoleId}", roleId);
            throw new InvalidOperationException(
                $"Failed to bulk assign permissions to role {roleId}. Please try again.", ex);
        }
    }

    public async Task<bool> SyncRolePermissionsAsync(Guid roleId, IEnumerable<Guid> permissionIds)
    {
        try
        {
            // Input validation
            if (roleId == Guid.Empty)
            {
                throw new ArgumentException("Role ID cannot be empty", nameof(roleId));
            }

            if (permissionIds == null)
            {
                throw new ArgumentNullException(nameof(permissionIds));
            }

            var permissionIdsList = permissionIds.Where(p => p != Guid.Empty).ToList();

            var userId = _userContext.GetCurrentUserId();
            _logger.LogInformation("User {UserId} syncing permissions for role {RoleId} ({Count} permissions)", 
                userId, roleId, permissionIdsList.Count);

            var role = await _roleRepository.GetRoleByIdAsync(roleId);
            if (role == null)
            {
                _logger.LogWarning("Role {RoleId} not found", roleId);
                throw new KeyNotFoundException($"Role {roleId} not found");
            }

            // Authorization checks
            if (role.IsSystemRole && !_tenantContext.IsSuperAdmin)
            {
                _logger.LogWarning("Non-SuperAdmin user {UserId} attempted to modify system role {RoleId} permissions", 
                    userId, roleId);
                throw new UnauthorizedAccessException("Only SuperAdmin can modify system role permissions");
            }

            if (!CanAccessRole(role))
            {
                _logger.LogWarning("User {UserId} attempted to modify role {RoleId} without permission", userId, roleId);
                throw new UnauthorizedAccessException("You don't have permission to modify this role");
            }

            var synced = await _roleRepository.SyncRolePermissionsAsync(roleId, permissionIdsList);

            _logger.LogInformation("User {UserId} successfully synced permissions for role {RoleId}", userId, roleId);

            return synced;
        }
        catch (ArgumentException)
        {
            throw; // Re-throw validation exceptions
        }
        catch (KeyNotFoundException)
        {
            throw; // Re-throw not found exceptions
        }
        catch (UnauthorizedAccessException)
        {
            throw; // Re-throw authorization exceptions
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error syncing permissions for role {RoleId}", roleId);
            throw new InvalidOperationException(
                $"Failed to sync permissions for role {roleId}. Please try again.", ex);
        }
    }

    #endregion

    #region HELPER METHODS

    private async Task<IEnumerable<RoleResponseDto>> MapRolesToDtos(IEnumerable<Role> roles)
    {
        var dtos = new List<RoleResponseDto>();
        var rolesList = roles.ToList(); // ‚úÖ FIX: Materialize to avoid multiple enumeration

        foreach (var role in rolesList)
        {
            try
            {
                var dto = _mapper.Map<RoleResponseDto>(role);
                dto.UserCount = await _roleRepository.GetRoleUserCountAsync(role.Id);
                dto.PermissionCount = await _roleRepository.GetRolePermissionCountAsync(role.Id);
                dtos.Add(dto);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error mapping role {RoleId} to DTO", role.Id);
                // Continue with other roles instead of failing completely
            }
        }

        return dtos;
    }

    private bool CanAccessRole(Role? role) // ‚úÖ FIX: Nullable parameter to match actual usage
    {
        if (role == null)
        {
            return false;
        }

        // SuperAdmin can access all roles
        if (_tenantContext.IsSuperAdmin)
        {
            return true;
        }

        // System roles: only SuperAdmin
        if (role.IsSystemRole)
        {
            return false;
        }

        // Template roles: everyone can view
        if (role.IsTemplate)
        {
            return true;
        }

        // Clinic-specific roles: only if in same clinic
        return role.ClinicId.HasValue && role.ClinicId == _tenantContext.ClinicId;
    }

    private async Task CopyPermissionsFromTemplate(Guid targetRoleId, Guid templateRoleId)
    {
        try
        {
            var permissionIds = await _roleRepository.GetRolePermissionIdsAsync(templateRoleId);
            var permissionIdsList = permissionIds.ToList(); // ‚úÖ FIX: Materialize once
            
            if (permissionIdsList.Count > 0)
            {
                var count = await _roleRepository.BulkAssignPermissionsAsync(targetRoleId, permissionIdsList);
                _logger.LogInformation(
                    "Copied {Count} permissions from template {TemplateRoleId} to role {RoleId}", 
                    count, templateRoleId, targetRoleId);
            }
            else
            {
                _logger.LogInformation(
                    "No permissions to copy from template {TemplateRoleId} to role {RoleId}", 
                    templateRoleId, targetRoleId);
            }
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, 
                "Error copying permissions from template {TemplateRoleId} to role {RoleId}", 
                templateRoleId, targetRoleId);
            // Don't throw - role creation should succeed even if permission copy fails
            // Permissions can be added manually later
        }
    }

    private async Task<Guid?> ValidateCreateRolePermissions(CreateRoleRequestDto dto)
    {
        Guid? targetClinicId = dto.ClinicId;

        if (_tenantContext.IsSuperAdmin)
        {
            // SuperAdmin can create roles for any clinic or system-level
            if (dto.IsTemplate && dto.ClinicId.HasValue)
            {
                throw new InvalidOperationException("Template roles cannot belong to a specific clinic");
            }
        }
        else
        {
            // ClinicAdmin can only create roles for their clinic
            if (!_tenantContext.ClinicId.HasValue)
            {
                throw new UnauthorizedAccessException("You must belong to a clinic to create roles");
            }

            if (dto.ClinicId.HasValue && dto.ClinicId != _tenantContext.ClinicId)
            {
                throw new UnauthorizedAccessException("You can only create roles for your own clinic");
            }

            if (dto.IsTemplate)
            {
                throw new UnauthorizedAccessException("Only SuperAdmin can create template roles");
            }

            targetClinicId = _tenantContext.ClinicId.Value;
        }

        return await Task.FromResult(targetClinicId);
    }

    private async Task<Guid?> ValidateCloneRolePermissions(Guid? targetClinicId)
    {
        Guid? actualTargetClinicId = targetClinicId;

        if (_tenantContext.IsSuperAdmin)
        {
            // SuperAdmin must specify target clinic
            if (!targetClinicId.HasValue)
            {
                throw new InvalidOperationException("SuperAdmin must specify target clinic ID when cloning");
            }
        }
        else
        {
            // ClinicAdmin can only clone to their own clinic
            if (!_tenantContext.ClinicId.HasValue)
            {
                throw new UnauthorizedAccessException("You must belong to a clinic to clone roles");
            }

            if (targetClinicId.HasValue && targetClinicId != _tenantContext.ClinicId)
            {
                throw new UnauthorizedAccessException("You can only clone roles to your own clinic");
            }

            actualTargetClinicId = _tenantContext.ClinicId.Value;
        }

        return await Task.FromResult(actualTargetClinicId);
    }

    #endregion
}
========================================
File: ./NabdCare.Application/Services/Permissions/PermissionService.cs
========================================
Ôªøusing AutoMapper;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Logging;
using NabdCare.Application.DTOs.Permissions;
using NabdCare.Application.Interfaces.Permissions;
using NabdCare.Application.Interfaces.Roles;
using NabdCare.Domain.Entities.Permissions;

namespace NabdCare.Application.Services.Permissions;

public class PermissionService : IPermissionService
{
    private readonly IPermissionRepository _permissionRepository;
    private readonly IRoleRepository _roleRepository;
    private readonly IMapper _mapper;
    private readonly ILogger<PermissionService> _logger;

    public PermissionService(
        IPermissionRepository permissionRepository,
        IRoleRepository roleRepository, // ‚úÖ Inject role repository
        IMapper mapper,
        ILogger<PermissionService> logger)
    {
        _permissionRepository = permissionRepository;
        _roleRepository = roleRepository;
        _mapper = mapper;
        _logger = logger;
    }

    #region Permission CRUD

    public async Task<IEnumerable<PermissionResponseDto>> GetAllPermissionsAsync()
    {
        try
        {
            var permissions = await _permissionRepository.GetAllPermissionsAsync();
            return _mapper.Map<IEnumerable<PermissionResponseDto>>(permissions);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to retrieve all permissions.");
            throw new InvalidOperationException("Failed to retrieve permissions.", ex);
        }
    }

    public async Task<PermissionResponseDto?> GetPermissionByIdAsync(Guid id)
    {
        try
        {
            var permission = await _permissionRepository.GetPermissionByIdAsync(id);
            return permission == null ? null : _mapper.Map<PermissionResponseDto>(permission);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to retrieve permission {PermissionId}.", id);
            throw new InvalidOperationException($"Failed to retrieve permission {id}.", ex);
        }
    }

    public async Task<PermissionResponseDto> CreatePermissionAsync(CreatePermissionDto dto)
    {
        if (string.IsNullOrWhiteSpace(dto.Name))
            throw new ArgumentException("Permission name is required.", nameof(dto.Name));

        try
        {
            var entity = _mapper.Map<AppPermission>(dto);
            var created = await _permissionRepository.CreatePermissionAsync(entity);
            return _mapper.Map<PermissionResponseDto>(created);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to create permission {PermissionName}.", dto.Name);
            throw new InvalidOperationException($"Failed to create permission {dto.Name}.", ex);
        }
    }

    public async Task<PermissionResponseDto?> UpdatePermissionAsync(Guid id, UpdatePermissionDto dto)
    {
        try
        {
            var entity = _mapper.Map<AppPermission>(dto);
            var updated = await _permissionRepository.UpdatePermissionAsync(id, entity);
            return updated == null ? null : _mapper.Map<PermissionResponseDto>(updated);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to update permission {PermissionId}.", id);
            throw new InvalidOperationException($"Failed to update permission {id}.", ex);
        }
    }

    public async Task<bool> DeletePermissionAsync(Guid id)
    {
        try
        {
            return await _permissionRepository.DeletePermissionAsync(id);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to delete permission {PermissionId}.", id);
            throw new InvalidOperationException($"Failed to delete permission {id}.", ex);
        }
    }

    #endregion

    #region Role/User Permission Management

    public async Task<bool> AssignPermissionToRoleAsync(Guid roleId, Guid permissionId)
    {
        try
        {
            // ‚úÖ Validate role exists
            var role = await _roleRepository.GetRoleByIdAsync(roleId);
            if (role == null)
                throw new KeyNotFoundException($"Role {roleId} not found.");

            return await _permissionRepository.AssignPermissionToRoleAsync(roleId, permissionId);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to assign permission {PermissionId} to role {RoleId}.", permissionId, roleId);
            throw new InvalidOperationException($"Failed to assign permission to role.", ex);
        }
    }

    public async Task<bool> RemovePermissionFromRoleAsync(Guid roleId, Guid permissionId)
    {
        try
        {
            // ‚úÖ Validate role exists
            var role = await _roleRepository.GetRoleByIdAsync(roleId);
            if (role == null)
                throw new KeyNotFoundException($"Role {roleId} not found.");

            return await _permissionRepository.RemovePermissionFromRoleAsync(roleId, permissionId);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to remove permission {PermissionId} from role {RoleId}.", permissionId, roleId);
            throw new InvalidOperationException($"Failed to remove permission from role.", ex);
        }
    }

    public async Task<bool> AssignPermissionToUserAsync(Guid userId, Guid permissionId)
    {
        try
        {
            return await _permissionRepository.AssignPermissionToUserAsync(userId, permissionId);
        }
        catch (DbUpdateException ex)
        {
            var errorMessage = ex.InnerException?.Message ?? ex.Message;
        
            // Check for foreign key violations
            if (errorMessage.Contains("Users") && errorMessage.Contains("foreign key"))
            {
                _logger.LogWarning("User {UserId} not found when assigning permission.", userId);
                throw new KeyNotFoundException($"User with ID {userId} does not exist.");
            }
        
            if (errorMessage.Contains("Permissions") && errorMessage.Contains("foreign key"))
            {
                _logger.LogWarning("Permission {PermissionId} not found.", permissionId);
                throw new KeyNotFoundException($"Permission with ID {permissionId} does not exist.");
            }
        
            _logger.LogError(ex, "Database error assigning permission {PermissionId} to user {UserId}.", permissionId, userId);
            throw new InvalidOperationException("Failed to assign permission to user.", ex);
        }
    }

    public async Task<bool> RemovePermissionFromUserAsync(Guid userId, Guid permissionId)
    {
        try
        {
            return await _permissionRepository.RemovePermissionFromUserAsync(userId, permissionId);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to remove permission {PermissionId} from user {UserId}.", permissionId, userId);
            throw new InvalidOperationException("Failed to remove permission from user.", ex);
        }
    }
    
    public async Task<IEnumerable<PermissionResponseDto>> GetPermissionsByRoleAsync(Guid roleId)
    {
        var permissions = await _permissionRepository.GetPermissionsByRoleAsync(roleId);
        return _mapper.Map<IEnumerable<PermissionResponseDto>>(permissions);
    }

    public async Task<IEnumerable<PermissionResponseDto>> GetPermissionsByUserAsync(Guid userId)
    {
        var permissions = await _permissionRepository.GetPermissionsByUserAsync(userId);
        return _mapper.Map<IEnumerable<PermissionResponseDto>>(permissions);
    }

    #endregion

    #region Effective Permissions

    public async Task<IEnumerable<PermissionResponseDto>> GetUserEffectivePermissionsAsync(Guid userId, Guid roleId)
    {
        try
        {
            var rolePerms = await _permissionRepository.GetPermissionsByRoleAsync(roleId);
            var userPerms = await _permissionRepository.GetPermissionsByUserAsync(userId);

            var combined = rolePerms.Concat(userPerms)
                                    .GroupBy(p => p.Id)
                                    .Select(g => g.First());

            return _mapper.Map<IEnumerable<PermissionResponseDto>>(combined);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to fetch effective permissions for user {UserId}.", userId);
            throw new InvalidOperationException("Failed to fetch effective permissions.", ex);
        }
    }

    public async Task<bool> UserHasPermissionAsync(Guid userId, Guid roleId, string permissionName)
    {
        if (string.IsNullOrWhiteSpace(permissionName))
            throw new ArgumentException("Permission name is required.", nameof(permissionName));

        var effective = await GetUserEffectivePermissionsAsync(userId, roleId);
        return effective.Any(p => p.Name.Equals(permissionName, StringComparison.OrdinalIgnoreCase));
    }

    #endregion
}
========================================
File: ./NabdCare.Application/Services/Clinics/ClinicService.cs
========================================
using AutoMapper;
using Microsoft.Extensions.Logging;
using NabdCare.Application.Common;
using NabdCare.Application.DTOs.Clinics;
using NabdCare.Application.DTOs.Clinics.Subscriptions;
using NabdCare.Application.Interfaces.Clinics;
using NabdCare.Domain.Entities.Clinics;
using NabdCare.Domain.Enums;

namespace NabdCare.Application.Services.Clinics;

/// <summary>
/// Production-ready clinic service following clean architecture.
/// No try-catch blocks - exceptions bubble up to middleware.
/// </summary>
public class ClinicService : IClinicService
{
    private readonly IClinicRepository _clinicRepository;
    private readonly ITenantContext _tenantContext;
    private readonly IUserContext _userContext;
    private readonly IMapper _mapper;
    private readonly ILogger<ClinicService> _logger;

    public ClinicService(
        IClinicRepository clinicRepository,
        ITenantContext tenantContext,
        IUserContext userContext,
        IMapper mapper,
        ILogger<ClinicService> logger)
    {
        _clinicRepository = clinicRepository ?? throw new ArgumentNullException(nameof(clinicRepository));
        _tenantContext = tenantContext ?? throw new ArgumentNullException(nameof(tenantContext));
        _userContext = userContext ?? throw new ArgumentNullException(nameof(userContext));
        _mapper = mapper ?? throw new ArgumentNullException(nameof(mapper));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }

    #region QUERY METHODS

    public async Task<ClinicResponseDto?> GetClinicByIdAsync(Guid id)
    {
        if (id == Guid.Empty)
            throw new ArgumentException("Clinic ID cannot be empty", nameof(id));

        var currentUserId = _userContext.GetCurrentUserId();
        _logger.LogInformation("User {CurrentUserId} retrieving clinic {ClinicId}", currentUserId, id);

        var clinic = await _clinicRepository.GetByIdAsync(id);
        if (clinic == null)
        {
            _logger.LogWarning("Clinic {ClinicId} not found", id);
            return null;
        }

        // Multi-tenant security: SuperAdmin can view all, others only their own
        if (!_tenantContext.IsSuperAdmin && _tenantContext.ClinicId != id)
        {
            _logger.LogWarning("User {CurrentUserId} (ClinicId: {UserClinicId}) attempted to access clinic {ClinicId} without permission",
                currentUserId, _tenantContext.ClinicId, id);
            throw new UnauthorizedAccessException("You can only view your own clinic");
        }

        return _mapper.Map<ClinicResponseDto>(clinic);
    }

    public async Task<IEnumerable<ClinicResponseDto>> GetAllClinicsAsync()
    {
        var currentUserId = _userContext.GetCurrentUserId();

        if (!_tenantContext.IsSuperAdmin)
        {
            _logger.LogWarning("Non-SuperAdmin user {CurrentUserId} attempted to view all clinics", currentUserId);
            throw new UnauthorizedAccessException("Only SuperAdmin can view all clinics");
        }

        _logger.LogInformation("SuperAdmin {CurrentUserId} retrieving all clinics", currentUserId);

        var clinics = await _clinicRepository.GetAllAsync();
        var clinicsList = clinics.ToList();

        _logger.LogInformation("SuperAdmin {CurrentUserId} retrieved {Count} clinics", currentUserId, clinicsList.Count);

        return _mapper.Map<IEnumerable<ClinicResponseDto>>(clinicsList);
    }

    public async Task<IEnumerable<ClinicResponseDto>> GetClinicsByStatusAsync(SubscriptionStatus status)
    {
        var currentUserId = _userContext.GetCurrentUserId();

        if (!_tenantContext.IsSuperAdmin)
        {
            _logger.LogWarning("Non-SuperAdmin user {CurrentUserId} attempted to view clinics by status", currentUserId);
            throw new UnauthorizedAccessException("Only SuperAdmin can view clinics by status");
        }

        _logger.LogInformation("SuperAdmin {CurrentUserId} retrieving clinics with status {Status}", currentUserId, status);

        var clinics = await _clinicRepository.GetByStatusAsync(status);
        var clinicsList = clinics.ToList();

        _logger.LogInformation("Retrieved {Count} clinics with status {Status}", clinicsList.Count, status);

        return _mapper.Map<IEnumerable<ClinicResponseDto>>(clinicsList);
    }

    public async Task<IEnumerable<ClinicResponseDto>> GetActiveClinicsAsync()
    {
        var currentUserId = _userContext.GetCurrentUserId();

        if (!_tenantContext.IsSuperAdmin)
        {
            _logger.LogWarning("Non-SuperAdmin user {CurrentUserId} attempted to view active clinics", currentUserId);
            throw new UnauthorizedAccessException("Only SuperAdmin can view all clinics");
        }

        _logger.LogInformation("SuperAdmin {CurrentUserId} retrieving active clinics with valid subscriptions", currentUserId);

        var clinics = await _clinicRepository.GetActiveWithValidSubscriptionAsync();
        var clinicsList = clinics.ToList();

        _logger.LogInformation("SuperAdmin {CurrentUserId} retrieved {Count} active clinics", currentUserId, clinicsList.Count);

        return _mapper.Map<IEnumerable<ClinicResponseDto>>(clinicsList);
    }

    public async Task<IEnumerable<ClinicResponseDto>> GetClinicsWithExpiringSubscriptionsAsync(int withinDays)
    {
        var currentUserId = _userContext.GetCurrentUserId();

        if (!_tenantContext.IsSuperAdmin)
        {
            _logger.LogWarning("Non-SuperAdmin user {CurrentUserId} attempted to view expiring subscriptions", currentUserId);
            throw new UnauthorizedAccessException("Only SuperAdmin can view expiring subscriptions");
        }

        if (withinDays < 1 || withinDays > 365)
            throw new ArgumentException("Days must be between 1 and 365", nameof(withinDays));

        _logger.LogInformation("SuperAdmin {CurrentUserId} retrieving clinics with subscriptions expiring within {Days} days", 
            currentUserId, withinDays);

        var clinics = await _clinicRepository.GetWithExpiringSubscriptionsAsync(withinDays);
        var clinicsList = clinics.ToList();

        _logger.LogInformation("Retrieved {Count} clinics with expiring subscriptions", clinicsList.Count);

        return _mapper.Map<IEnumerable<ClinicResponseDto>>(clinicsList);
    }

    public async Task<IEnumerable<ClinicResponseDto>> GetClinicsWithExpiredSubscriptionsAsync()
    {
        var currentUserId = _userContext.GetCurrentUserId();

        if (!_tenantContext.IsSuperAdmin)
        {
            _logger.LogWarning("Non-SuperAdmin user {CurrentUserId} attempted to view expired subscriptions", currentUserId);
            throw new UnauthorizedAccessException("Only SuperAdmin can view expired subscriptions");
        }

        _logger.LogInformation("SuperAdmin {CurrentUserId} retrieving clinics with expired subscriptions", currentUserId);

        var clinics = await _clinicRepository.GetWithExpiredSubscriptionsAsync();
        var clinicsList = clinics.ToList();

        _logger.LogInformation("Retrieved {Count} clinics with expired subscriptions", clinicsList.Count);

        return _mapper.Map<IEnumerable<ClinicResponseDto>>(clinicsList);
    }

    public async Task<IEnumerable<ClinicResponseDto>> GetPagedClinicsAsync(int page, int pageSize)
    {
        var currentUserId = _userContext.GetCurrentUserId();

        if (!_tenantContext.IsSuperAdmin)
        {
            _logger.LogWarning("Non-SuperAdmin user {CurrentUserId} attempted to view paged clinics", currentUserId);
            throw new UnauthorizedAccessException("Only SuperAdmin can view all clinics");
        }

        if (page < 1) page = 1;
        if (pageSize < 1 || pageSize > 100) pageSize = 20;

        _logger.LogInformation("SuperAdmin {CurrentUserId} retrieving clinics page {Page} (size {PageSize})",
            currentUserId, page, pageSize);

        var clinics = await _clinicRepository.GetPagedAsync(page, pageSize);
        var clinicsList = clinics.ToList();

        _logger.LogInformation("Retrieved {Count} clinics for page {Page}", clinicsList.Count, page);

        return _mapper.Map<IEnumerable<ClinicResponseDto>>(clinicsList);
    }

    public async Task<IEnumerable<ClinicResponseDto>> SearchClinicsAsync(string query)
    {
        var currentUserId = _userContext.GetCurrentUserId();

        if (!_tenantContext.IsSuperAdmin)
        {
            _logger.LogWarning("Non-SuperAdmin user {CurrentUserId} attempted to search clinics", currentUserId);
            throw new UnauthorizedAccessException("Only SuperAdmin can search clinics");
        }

        if (string.IsNullOrWhiteSpace(query))
            throw new ArgumentException("Search query cannot be empty", nameof(query));

        _logger.LogInformation("SuperAdmin {CurrentUserId} searching clinics with query: {Query}", currentUserId, query);

        var clinics = await _clinicRepository.SearchAsync(query);
        var clinicsList = clinics.ToList();

        _logger.LogInformation("Search returned {Count} clinics", clinicsList.Count);

        return _mapper.Map<IEnumerable<ClinicResponseDto>>(clinicsList);
    }

    #endregion

    #region COMMAND METHODS

    public async Task<ClinicResponseDto> CreateClinicAsync(CreateClinicRequestDto dto)
    {
        if (dto == null)
            throw new ArgumentNullException(nameof(dto));

        ValidateCreateClinicDto(dto);

        var currentUserId = _userContext.GetCurrentUserId();
        _logger.LogInformation("User {CurrentUserId} creating clinic {ClinicName}", currentUserId, dto.Name);

        // Check uniqueness
        if (await _clinicRepository.ExistsByNameAsync(dto.Name))
        {
            _logger.LogWarning("Attempted to create clinic with duplicate name: {Name}", dto.Name);
            throw new InvalidOperationException($"A clinic with name '{dto.Name}' already exists");
        }

        if (!string.IsNullOrWhiteSpace(dto.Email) && await _clinicRepository.ExistsByEmailAsync(dto.Email))
        {
            _logger.LogWarning("Attempted to create clinic with duplicate email: {Email}", dto.Email);
            throw new InvalidOperationException($"A clinic with email '{dto.Email}' already exists");
        }

        // Create clinic entity
        var clinic = _mapper.Map<Clinic>(dto);
        clinic.Id = Guid.NewGuid();
        clinic.Status = dto.Status;
        clinic.CreatedAt = DateTime.UtcNow;
        clinic.CreatedBy = currentUserId;
        clinic.IsDeleted = false;

        // Create initial subscription
        var subscriptionId = Guid.NewGuid();
        clinic.Subscriptions = new List<Subscription>
        {
            new Subscription
            {
                Id = subscriptionId,
                ClinicId = clinic.Id,
                StartDate = dto.SubscriptionStartDate,
                EndDate = dto.SubscriptionEndDate,
                Fee = dto.SubscriptionFee,
                Type = dto.SubscriptionType,
                Status = dto.Status,
                CreatedAt = DateTime.UtcNow,
                CreatedBy = currentUserId,
                IsDeleted = false
            }
        };

        var created = await _clinicRepository.CreateAsync(clinic);

        _logger.LogInformation("User {CurrentUserId} successfully created clinic {ClinicId} ({ClinicName}) with subscription {SubscriptionId}",
            currentUserId, created.Id, created.Name, subscriptionId);

        return _mapper.Map<ClinicResponseDto>(created);
    }

    public async Task<ClinicResponseDto?> UpdateClinicAsync(Guid id, UpdateClinicRequestDto dto)
    {
        if (id == Guid.Empty)
            throw new ArgumentException("Clinic ID cannot be empty", nameof(id));

        if (dto == null)
            throw new ArgumentNullException(nameof(dto));

        ValidateUpdateClinicDto(dto);

        var currentUserId = _userContext.GetCurrentUserId();
        _logger.LogInformation("User {CurrentUserId} updating clinic {ClinicId}", currentUserId, id);

        var clinic = await _clinicRepository.GetByIdAsync(id);
        if (clinic == null)
        {
            _logger.LogWarning("Clinic {ClinicId} not found for update", id);
            return null;
        }

        // Multi-tenant security: SuperAdmin can update all, others only their own
        if (!_tenantContext.IsSuperAdmin && _tenantContext.ClinicId != id)
        {
            _logger.LogWarning("User {CurrentUserId} attempted to update clinic {ClinicId} without permission", currentUserId, id);
            throw new UnauthorizedAccessException("You can only update your own clinic");
        }

        // Check uniqueness (excluding current clinic)
        if (await _clinicRepository.ExistsByNameAsync(dto.Name, id))
        {
            _logger.LogWarning("Attempted to update clinic with duplicate name: {Name}", dto.Name);
            throw new InvalidOperationException($"A clinic with name '{dto.Name}' already exists");
        }

        if (!string.IsNullOrWhiteSpace(dto.Email) && await _clinicRepository.ExistsByEmailAsync(dto.Email, id))
        {
            _logger.LogWarning("Attempted to update clinic with duplicate email: {Email}", dto.Email);
            throw new InvalidOperationException($"A clinic with email '{dto.Email}' already exists");
        }

        // Update clinic fields
        clinic.Name = dto.Name.Trim();
        clinic.Email = dto.Email?.Trim();
        clinic.Phone = dto.Phone?.Trim();
        clinic.Address = dto.Address?.Trim();
        clinic.BranchCount = dto.BranchCount;
        clinic.Status = dto.Status;
        clinic.UpdatedAt = DateTime.UtcNow;
        clinic.UpdatedBy = currentUserId;

        // Update latest subscription
        var latestSubscription = clinic.Subscriptions?
            .Where(s => !s.IsDeleted)
            .OrderByDescending(s => s.StartDate)
            .FirstOrDefault();

        if (latestSubscription != null)
        {
            latestSubscription.StartDate = dto.SubscriptionStartDate;
            latestSubscription.EndDate = dto.SubscriptionEndDate;
            latestSubscription.Fee = dto.SubscriptionFee;
            latestSubscription.Type = dto.SubscriptionType;
            latestSubscription.Status = dto.Status;
            latestSubscription.UpdatedAt = DateTime.UtcNow;
            latestSubscription.UpdatedBy = currentUserId;
        }
        else
        {
            // Create subscription if none exists
            clinic.Subscriptions ??= new List<Subscription>();
            clinic.Subscriptions.Add(new Subscription
            {
                Id = Guid.NewGuid(),
                ClinicId = clinic.Id,
                StartDate = dto.SubscriptionStartDate,
                EndDate = dto.SubscriptionEndDate,
                Fee = dto.SubscriptionFee,
                Type = dto.SubscriptionType,
                Status = dto.Status,
                CreatedAt = DateTime.UtcNow,
                CreatedBy = currentUserId,
                IsDeleted = false
            });
        }

        var updated = await _clinicRepository.UpdateAsync(clinic);

        _logger.LogInformation("User {CurrentUserId} successfully updated clinic {ClinicId} ({ClinicName})",
            currentUserId, id, updated.Name);

        return _mapper.Map<ClinicResponseDto>(updated);
    }

    public async Task<ClinicResponseDto?> UpdateClinicStatusAsync(Guid id, UpdateClinicStatusDto dto)
    {
        if (id == Guid.Empty)
            throw new ArgumentException("Clinic ID cannot be empty", nameof(id));

        if (dto == null)
            throw new ArgumentNullException(nameof(dto));

        var currentUserId = _userContext.GetCurrentUserId();

        if (!_tenantContext.IsSuperAdmin)
        {
            _logger.LogWarning("Non-SuperAdmin user {CurrentUserId} attempted to update clinic status", currentUserId);
            throw new UnauthorizedAccessException("Only SuperAdmin can update clinic status");
        }

        _logger.LogInformation("SuperAdmin {CurrentUserId} updating status for clinic {ClinicId} to {Status}",
            currentUserId, id, dto.Status);

        var clinic = await _clinicRepository.GetByIdAsync(id);
        if (clinic == null)
        {
            _logger.LogWarning("Clinic {ClinicId} not found for status update", id);
            return null;
        }

        clinic.Status = dto.Status;
        clinic.UpdatedAt = DateTime.UtcNow;
        clinic.UpdatedBy = currentUserId;

        // Also update latest subscription status
        var latestSubscription = clinic.Subscriptions?
            .Where(s => !s.IsDeleted)
            .OrderByDescending(s => s.StartDate)
            .FirstOrDefault();

        if (latestSubscription != null)
        {
            latestSubscription.Status = dto.Status;
            latestSubscription.UpdatedAt = DateTime.UtcNow;
            latestSubscription.UpdatedBy = currentUserId;
        }

        var updated = await _clinicRepository.UpdateAsync(clinic);

        _logger.LogInformation("SuperAdmin {CurrentUserId} successfully updated status for clinic {ClinicId} to {Status}",
            currentUserId, id, dto.Status);

        return _mapper.Map<ClinicResponseDto>(updated);
    }

    public async Task<ClinicResponseDto?> ActivateClinicAsync(Guid id)
    {
        if (id == Guid.Empty)
            throw new ArgumentException("Clinic ID cannot be empty", nameof(id));

        var currentUserId = _userContext.GetCurrentUserId();

        if (!_tenantContext.IsSuperAdmin)
        {
            _logger.LogWarning("Non-SuperAdmin user {CurrentUserId} attempted to activate clinic {ClinicId}", currentUserId, id);
            throw new UnauthorizedAccessException("Only SuperAdmin can activate clinics");
        }

        _logger.LogInformation("SuperAdmin {CurrentUserId} activating clinic {ClinicId}", currentUserId, id);

        var clinic = await _clinicRepository.GetByIdAsync(id);
        if (clinic == null)
        {
            _logger.LogWarning("Clinic {ClinicId} not found for activation", id);
            return null;
        }

        if (clinic.Status == SubscriptionStatus.Active)
        {
            _logger.LogInformation("Clinic {ClinicId} is already active", id);
            return _mapper.Map<ClinicResponseDto>(clinic);
        }

        clinic.Status = SubscriptionStatus.Active;
        clinic.UpdatedAt = DateTime.UtcNow;
        clinic.UpdatedBy = currentUserId;

        // Activate latest subscription
        var latestSubscription = clinic.Subscriptions?
            .Where(s => !s.IsDeleted)
            .OrderByDescending(s => s.StartDate)
            .FirstOrDefault();

        if (latestSubscription != null)
        {
            latestSubscription.Status = SubscriptionStatus.Active;
            latestSubscription.UpdatedAt = DateTime.UtcNow;
            latestSubscription.UpdatedBy = currentUserId;
        }

        var updated = await _clinicRepository.UpdateAsync(clinic);

        _logger.LogInformation("SuperAdmin {CurrentUserId} successfully activated clinic {ClinicId} ({ClinicName})",
            currentUserId, id, updated.Name);

        return _mapper.Map<ClinicResponseDto>(updated);
    }

    public async Task<ClinicResponseDto?> SuspendClinicAsync(Guid id)
    {
        if (id == Guid.Empty)
            throw new ArgumentException("Clinic ID cannot be empty", nameof(id));

        var currentUserId = _userContext.GetCurrentUserId();

        if (!_tenantContext.IsSuperAdmin)
        {
            _logger.LogWarning("Non-SuperAdmin user {CurrentUserId} attempted to suspend clinic {ClinicId}", currentUserId, id);
            throw new UnauthorizedAccessException("Only SuperAdmin can suspend clinics");
        }

        _logger.LogInformation("SuperAdmin {CurrentUserId} suspending clinic {ClinicId}", currentUserId, id);

        var clinic = await _clinicRepository.GetByIdAsync(id);
        if (clinic == null)
        {
            _logger.LogWarning("Clinic {ClinicId} not found for suspension", id);
            return null;
        }

        if (clinic.Status == SubscriptionStatus.Suspended)
        {
            _logger.LogInformation("Clinic {ClinicId} is already suspended", id);
            return _mapper.Map<ClinicResponseDto>(clinic);
        }

        clinic.Status = SubscriptionStatus.Suspended;
        clinic.UpdatedAt = DateTime.UtcNow;
        clinic.UpdatedBy = currentUserId;

        // Suspend latest subscription
        var latestSubscription = clinic.Subscriptions?
            .Where(s => !s.IsDeleted)
            .OrderByDescending(s => s.StartDate)
            .FirstOrDefault();

        if (latestSubscription != null)
        {
            latestSubscription.Status = SubscriptionStatus.Suspended;
            latestSubscription.UpdatedAt = DateTime.UtcNow;
            latestSubscription.UpdatedBy = currentUserId;
        }

        var updated = await _clinicRepository.UpdateAsync(clinic);

        _logger.LogWarning("SuperAdmin {CurrentUserId} suspended clinic {ClinicId} ({ClinicName})",
            currentUserId, id, updated.Name);

        return _mapper.Map<ClinicResponseDto>(updated);
    }

    public async Task<bool> SoftDeleteClinicAsync(Guid id)
    {
        if (id == Guid.Empty)
            throw new ArgumentException("Clinic ID cannot be empty", nameof(id));

        var currentUserId = _userContext.GetCurrentUserId();

        if (!_tenantContext.IsSuperAdmin)
        {
            _logger.LogWarning("Non-SuperAdmin user {CurrentUserId} attempted to delete clinic {ClinicId}", currentUserId, id);
            throw new UnauthorizedAccessException("Only SuperAdmin can delete clinics");
        }

        _logger.LogInformation("SuperAdmin {CurrentUserId} soft deleting clinic {ClinicId}", currentUserId, id);

        var clinic = await _clinicRepository.GetByIdAsync(id);
        if (clinic == null)
        {
            _logger.LogWarning("Clinic {ClinicId} not found for soft delete", id);
            return false;
        }

        var success = await _clinicRepository.SoftDeleteAsync(id);

        if (success)
        {
            _logger.LogInformation("SuperAdmin {CurrentUserId} successfully soft deleted clinic {ClinicId} ({ClinicName})",
                currentUserId, id, clinic.Name);
        }

        return success;
    }

    public async Task<bool> DeleteClinicAsync(Guid id)
    {
        if (id == Guid.Empty)
            throw new ArgumentException("Clinic ID cannot be empty", nameof(id));

        var currentUserId = _userContext.GetCurrentUserId();

        if (!_tenantContext.IsSuperAdmin)
        {
            _logger.LogWarning("Non-SuperAdmin user {CurrentUserId} attempted to permanently delete clinic {ClinicId}", currentUserId, id);
            throw new UnauthorizedAccessException("Only SuperAdmin can permanently delete clinics");
        }

        _logger.LogWarning("SuperAdmin {CurrentUserId} permanently deleting clinic {ClinicId}", currentUserId, id);

        var clinic = await _clinicRepository.GetByIdAsync(id);
        if (clinic == null)
        {
            _logger.LogWarning("Clinic {ClinicId} not found for permanent delete", id);
            return false;
        }

        var success = await _clinicRepository.DeleteAsync(id);

        if (success)
        {
            _logger.LogWarning("‚ö†Ô∏è SuperAdmin {CurrentUserId} PERMANENTLY DELETED clinic {ClinicId} ({ClinicName})",
                currentUserId, id, clinic.Name);
        }

        return success;
    }

    #endregion

    #region STATISTICS

    public async Task<ClinicStatisticsDto?> GetClinicStatisticsAsync(Guid id)
    {
        if (id == Guid.Empty)
            throw new ArgumentException("Clinic ID cannot be empty", nameof(id));

        var currentUserId = _userContext.GetCurrentUserId();

        if (!_tenantContext.IsSuperAdmin)
        {
            _logger.LogWarning("Non-SuperAdmin user {CurrentUserId} attempted to view clinic statistics", currentUserId);
            throw new UnauthorizedAccessException("Only SuperAdmin can view clinic statistics");
        }

        _logger.LogInformation("SuperAdmin {CurrentUserId} retrieving statistics for clinic {ClinicId}", currentUserId, id);

        var clinic = await _clinicRepository.GetByIdAsync(id);
        if (clinic == null)
        {
            _logger.LogWarning("Clinic {ClinicId} not found for statistics", id);
            return null;
        }

        var now = DateTime.UtcNow;
        var latestSubscription = clinic.Subscriptions?
            .Where(s => !s.IsDeleted)
            .OrderByDescending(s => s.StartDate)
            .FirstOrDefault();

        var daysUntilExpiration = latestSubscription != null 
            ? (int)(latestSubscription.EndDate - now).TotalDays 
            : 0;

        var statistics = new ClinicStatisticsDto
        {
            ClinicId = clinic.Id,
            ClinicName = clinic.Name,
            Status = clinic.Status,
            BranchCount = clinic.BranchCount,
            TotalSubscriptions = clinic.Subscriptions?.Count(s => !s.IsDeleted) ?? 0,
            CurrentSubscription = latestSubscription != null 
                ? _mapper.Map<SubscriptionResponseDto>(latestSubscription) 
                : null,
            IsSubscriptionActive = latestSubscription != null 
                                   && latestSubscription.EndDate > now 
                                   && latestSubscription.Status == SubscriptionStatus.Active,
            DaysUntilExpiration = daysUntilExpiration,
            IsExpiringSoon = daysUntilExpiration > 0 && daysUntilExpiration <= 30,
            CreatedAt = clinic.CreatedAt
        };

        return statistics;
    }

    #endregion

    #region HELPER METHODS

    private void ValidateCreateClinicDto(CreateClinicRequestDto dto)
    {
        if (string.IsNullOrWhiteSpace(dto.Name))
            throw new ArgumentException("Clinic name is required", nameof(dto.Name));

        if (dto.SubscriptionStartDate >= dto.SubscriptionEndDate)
            throw new ArgumentException("Subscription start date must be before end date", nameof(dto.SubscriptionStartDate));

        if (dto.SubscriptionFee < 0)
            throw new ArgumentException("Subscription fee cannot be negative", nameof(dto.SubscriptionFee));

        if (dto.BranchCount < 1)
            throw new ArgumentException("Branch count must be at least 1", nameof(dto.BranchCount));
    }

    private void ValidateUpdateClinicDto(UpdateClinicRequestDto dto)
    {
        if (string.IsNullOrWhiteSpace(dto.Name))
            throw new ArgumentException("Clinic name is required", nameof(dto.Name));

        if (dto.SubscriptionStartDate >= dto.SubscriptionEndDate)
            throw new ArgumentException("Subscription start date must be before end date", nameof(dto.SubscriptionStartDate));

        if (dto.SubscriptionFee < 0)
            throw new ArgumentException("Subscription fee cannot be negative", nameof(dto.SubscriptionFee));

        if (dto.BranchCount < 1)
            throw new ArgumentException("Branch count must be at least 1", nameof(dto.BranchCount));
    }

    #endregion
}
========================================
File: ./NabdCare.Application/Services/Clinics/SubscriptionService.cs
========================================
Ôªøusing AutoMapper;
using Microsoft.Extensions.Logging;
using NabdCare.Application.DTOs.Clinics.Subscriptions;
using NabdCare.Application.Interfaces.Clinics.Subscriptions;
using NabdCare.Domain.Entities.Clinics;

namespace NabdCare.Application.Services.Clinics;

public class SubscriptionService : ISubscriptionService
{
    private readonly ISubscriptionRepository _repository;
    private readonly IMapper _mapper;
    private readonly ILogger<SubscriptionService> _logger;

    public SubscriptionService(
        ISubscriptionRepository repository,
        IMapper mapper,
        ILogger<SubscriptionService> logger)
    {
        _repository = repository;
        _mapper = mapper;
        _logger = logger;
    }

    public async Task<SubscriptionResponseDto> CreateSubscriptionAsync(CreateSubscriptionRequestDto dto)
    {
        if (dto.StartDate >= dto.EndDate)
            throw new ArgumentException("StartDate must be before EndDate.");

        var subscription = _mapper.Map<Subscription>(dto);

        try
        {
            var created = await _repository.CreateAsync(subscription);
            _logger.LogInformation("Subscription {SubscriptionId} created for Clinic {ClinicId}.", created.Id, created.ClinicId);
            return _mapper.Map<SubscriptionResponseDto>(created);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to create subscription for Clinic {ClinicId}.", dto.ClinicId);
            throw;
        }
    }

    public async Task<SubscriptionResponseDto?> GetByIdAsync(Guid id, bool includePayments = false)
    {
        var subscription = await _repository.GetByIdAsync(id, includePayments);
        return subscription == null ? null : _mapper.Map<SubscriptionResponseDto>(subscription);
    }

    public async Task<IEnumerable<SubscriptionResponseDto>> GetByClinicIdAsync(Guid clinicId, bool includePayments = false)
    {
        var subscriptions = await _repository.GetByClinicIdAsync(clinicId, includePayments);
        return _mapper.Map<IEnumerable<SubscriptionResponseDto>>(subscriptions);
    }

    public async Task<IEnumerable<SubscriptionResponseDto>> GetPagedAsync(int page, int pageSize, bool includePayments = false)
    {
        var subscriptions = await _repository.GetPagedAsync(page, pageSize, includePayments);
        return _mapper.Map<IEnumerable<SubscriptionResponseDto>>(subscriptions);
    }

    public async Task<SubscriptionResponseDto?> UpdateSubscriptionAsync(Guid id, UpdateSubscriptionRequestDto dto)
    {
        var existing = await _repository.GetByIdAsync(id, includePayments: false);
        if (existing == null) return null;

        if (dto.StartDate >= dto.EndDate)
            throw new ArgumentException("StartDate must be before EndDate.");

        _mapper.Map(dto, existing);

        try
        {
            var updated = await _repository.UpdateAsync(existing);
            _logger.LogInformation("Subscription {SubscriptionId} updated.", id);
            return _mapper.Map<SubscriptionResponseDto>(updated);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to update subscription {SubscriptionId}.", id);
            throw;
        }
    }

    public async Task<bool> SoftDeleteSubscriptionAsync(Guid id)
    {
        var success = await _repository.SoftDeleteAsync(id);
        if (success) _logger.LogInformation("Subscription {SubscriptionId} soft-deleted.", id);
        return success;
    }

    public async Task<bool> DeleteSubscriptionAsync(Guid id)
    {
        var success = await _repository.DeleteAsync(id);
        if (success) _logger.LogInformation("Subscription {SubscriptionId} permanently deleted.", id);
        return success;
    }
}

========================================
File: ./NabdCare.Application/Services/IdentityPasswordService.cs
========================================
Ôªøusing Microsoft.AspNetCore.Identity;
using NabdCare.Application.Interfaces;
using NabdCare.Domain.Entities.Users;

namespace NabdCare.Application.Services;

public class IdentityPasswordService : IPasswordService
{
    private readonly PasswordHasher<User> _hasher;

    public IdentityPasswordService()
    {
        _hasher = new PasswordHasher<User>();
    }

    /// <summary>
    /// Hashes the given password using ASP.NET Core Identity's PasswordHasher.
    /// </summary>
    /// <param name="user">The user entity</param>
    /// <param name="password">Plain text password</param>
    /// <returns>Hashed password string</returns>
    public string HashPassword(User user, string password)
    {
        if (user == null)
            throw new ArgumentNullException(nameof(user));
        
        if (string.IsNullOrWhiteSpace(password))
            throw new ArgumentException("Password cannot be empty.", nameof(password));

        return _hasher.HashPassword(user, password);
    }

    /// <summary>
    /// Verifies a plaintext password against the user's stored hashed password.
    /// </summary>
    /// <param name="user">The user entity with PasswordHash property</param>
    /// <param name="password">Plain text password to verify</param>
    /// <returns>True if password is valid, false otherwise</returns>
    public bool VerifyPassword(User user, string password)
    {
        if (user == null)
            throw new ArgumentNullException(nameof(user));

        if (string.IsNullOrWhiteSpace(password))
            return false;

        if (string.IsNullOrWhiteSpace(user.PasswordHash))
            return false;

        var result = _hasher.VerifyHashedPassword(user, user.PasswordHash, password);

        return result != PasswordVerificationResult.Failed;
    }
}
========================================
File: ./NabdCare.Application/Services/Users/UserService.cs
========================================
Ôªøusing AutoMapper;
using Microsoft.Extensions.Logging;
using NabdCare.Application.Common;
using NabdCare.Application.DTOs.Users;
using NabdCare.Application.Interfaces;
using NabdCare.Application.Interfaces.Roles;
using NabdCare.Application.Interfaces.Users;
using NabdCare.Domain.Entities.Users;

namespace NabdCare.Application.Services.Users;

/// <summary>
/// Production-ready user service with comprehensive error handling, audit logging,
/// multi-tenant security, and clean architecture principles.
/// </summary>
public class UserService : IUserService
{
    private readonly IUserRepository _userRepository;
    private readonly IRoleRepository _roleRepository;
    private readonly IPasswordService _passwordService;
    private readonly ITenantContext _tenantContext;
    private readonly IUserContext _userContext;
    private readonly IMapper _mapper;
    private readonly ILogger<UserService> _logger;

    public UserService(
        IUserRepository userRepository,
        IRoleRepository roleRepository,
        IPasswordService passwordService,
        ITenantContext tenantContext,
        IUserContext userContext,
        IMapper mapper,
        ILogger<UserService> logger)
    {
        _userRepository = userRepository ?? throw new ArgumentNullException(nameof(userRepository));
        _roleRepository = roleRepository ?? throw new ArgumentNullException(nameof(roleRepository));
        _passwordService = passwordService ?? throw new ArgumentNullException(nameof(passwordService));
        _tenantContext = tenantContext ?? throw new ArgumentNullException(nameof(tenantContext));
        _userContext = userContext ?? throw new ArgumentNullException(nameof(userContext));
        _mapper = mapper ?? throw new ArgumentNullException(nameof(mapper));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }

    #region QUERY METHODS

    public async Task<UserResponseDto?> GetUserByIdAsync(Guid id)
    {
        if (id == Guid.Empty)
            throw new ArgumentException("User ID cannot be empty", nameof(id));

        var currentUserId = _userContext.GetCurrentUserId();
        _logger.LogInformation("User {CurrentUserId} retrieving user {UserId}", currentUserId, id);

        var user = await _userRepository.GetByIdAsync(id);
        if (user == null)
        {
            _logger.LogWarning("User {UserId} not found", id);
            return null;
        }

        // Multi-tenant security check
        if (!CanAccessUser(user))
        {
            _logger.LogWarning("User {CurrentUserId} attempted to access user {UserId} without permission", 
                currentUserId, id);
            throw new UnauthorizedAccessException("You don't have permission to view this user");
        }

        return _mapper.Map<UserResponseDto>(user);
    }

    public async Task<IEnumerable<UserResponseDto>> GetUsersByClinicIdAsync(Guid? clinicId)
    {
        var currentUserId = _userContext.GetCurrentUserId();
        _logger.LogInformation("User {CurrentUserId} retrieving users for clinic {ClinicId}", 
            currentUserId, clinicId);

        IEnumerable<User> users;

        if (_tenantContext.IsSuperAdmin)
        {
            // SuperAdmin can view all users or filter by clinic
            users = clinicId.HasValue 
                ? await _userRepository.GetByClinicIdAsync(clinicId.Value)
                : await _userRepository.GetAllAsync();
            
            var usersList = users.ToList();
            _logger.LogInformation("SuperAdmin {CurrentUserId} retrieved {Count} users", 
                currentUserId, usersList.Count);
        }
        else if (_tenantContext.ClinicId.HasValue)
        {
            // ClinicAdmin can only view users in their clinic
            users = await _userRepository.GetByClinicIdAsync(_tenantContext.ClinicId.Value);
            
            var usersList = users.ToList();
            _logger.LogInformation("Clinic user {CurrentUserId} retrieved {Count} users from clinic {ClinicId}", 
                currentUserId, usersList.Count, _tenantContext.ClinicId.Value);
        }
        else
        {
            _logger.LogWarning("User {CurrentUserId} has no tenant context", currentUserId);
            throw new UnauthorizedAccessException("You don't have permission to view users");
        }

        return _mapper.Map<IEnumerable<UserResponseDto>>(users);
    }

    public async Task<UserResponseDto?> GetCurrentUserAsync()
    {
        var currentUserId = _userContext.GetCurrentUserId();
        
        if (string.IsNullOrEmpty(currentUserId) || !Guid.TryParse(currentUserId, out var userId))
        {
            _logger.LogWarning("Invalid current user ID: {CurrentUserId}", currentUserId);
            throw new UnauthorizedAccessException("User is not authenticated");
        }

        return await GetUserByIdAsync(userId);
    }

    #endregion

    #region COMMAND METHODS

    public async Task<UserResponseDto> CreateUserAsync(CreateUserRequestDto dto)
    {
        // Input validation
        if (dto == null)
            throw new ArgumentNullException(nameof(dto));

        ValidateUserCreationDto(dto);

        var currentUserId = _userContext.GetCurrentUserId();
        _logger.LogInformation("User {CurrentUserId} creating user {Email}", currentUserId, dto.Email);

        // Determine target clinic
        var targetClinicId = await ValidateAndGetTargetClinicId(dto.ClinicId, dto.RoleId);

        // Check if email already exists
        if (await _userRepository.EmailExistsAsync(dto.Email))
        {
            _logger.LogWarning("Attempted to create user with duplicate email: {Email}", dto.Email);
            throw new InvalidOperationException($"A user with email '{dto.Email}' already exists");
        }

        // Validate role exists and user can assign it
        await ValidateRoleAssignment(dto.RoleId, targetClinicId);

        // Create user entity first (without password hash)
        var user = new User
        {
            Id = Guid.NewGuid(),
            Email = dto.Email.Trim().ToLower(),
            FullName = dto.FullName.Trim(),
            RoleId = dto.RoleId,
            ClinicId = targetClinicId,
            IsActive = true,
            CreatedAt = DateTime.UtcNow,
            CreatedBy = currentUserId,
            IsDeleted = false
        };

        // Hash password with user entity
        user.PasswordHash = _passwordService.HashPassword(user, dto.Password);

        var created = await _userRepository.CreateAsync(user);
        
        _logger.LogInformation("User {CurrentUserId} successfully created user {NewUserId} ({Email}) in clinic {ClinicId}", 
            currentUserId, created.Id, created.Email, targetClinicId);

        return _mapper.Map<UserResponseDto>(created);
    }

    public async Task<UserResponseDto?> UpdateUserAsync(Guid id, UpdateUserRequestDto dto)
    {
        // Input validation
        if (id == Guid.Empty)
            throw new ArgumentException("User ID cannot be empty", nameof(id));

        if (dto == null)
            throw new ArgumentNullException(nameof(dto));

        if (string.IsNullOrWhiteSpace(dto.FullName))
            throw new ArgumentException("Full name is required", nameof(dto.FullName));

        var currentUserId = _userContext.GetCurrentUserId();
        _logger.LogInformation("User {CurrentUserId} updating user {UserId}", currentUserId, id);

        var user = await _userRepository.GetByIdAsync(id);
        if (user == null)
        {
            _logger.LogWarning("User {UserId} not found for update", id);
            return null;
        }

        // Multi-tenant authorization check
        if (!CanManageUser(user.ClinicId))
        {
            _logger.LogWarning("User {CurrentUserId} attempted to update user {UserId} without permission", 
                currentUserId, id);
            throw new UnauthorizedAccessException("You don't have permission to update this user");
        }

        // Update fields
        user.FullName = dto.FullName.Trim();
        user.UpdatedAt = DateTime.UtcNow;
        user.UpdatedBy = currentUserId;

        var updated = await _userRepository.UpdateAsync(user);
        
        _logger.LogInformation("User {CurrentUserId} successfully updated user {UserId}", currentUserId, id);

        return _mapper.Map<UserResponseDto>(updated);
    }

    public async Task<UserResponseDto?> UpdateUserRoleAsync(Guid id, Guid roleId)
    {
        // Input validation
        if (id == Guid.Empty)
            throw new ArgumentException("User ID cannot be empty", nameof(id));

        if (roleId == Guid.Empty)
            throw new ArgumentException("Role ID cannot be empty", nameof(roleId));

        var currentUserId = _userContext.GetCurrentUserId();
        _logger.LogInformation("User {CurrentUserId} updating role for user {UserId} to {RoleId}", 
            currentUserId, id, roleId);

        var user = await _userRepository.GetByIdAsync(id);
        if (user == null)
        {
            _logger.LogWarning("User {UserId} not found for role update", id);
            return null;
        }

        // Multi-tenant authorization check
        if (!CanManageUser(user.ClinicId))
        {
            _logger.LogWarning("User {CurrentUserId} attempted to update role for user {UserId} without permission", 
                currentUserId, id);
            throw new UnauthorizedAccessException("You don't have permission to update this user's role");
        }

        // Validate new role
        await ValidateRoleAssignment(roleId, user.ClinicId);

        // Update role
        user.RoleId = roleId;
        user.UpdatedAt = DateTime.UtcNow;
        user.UpdatedBy = currentUserId;

        var updated = await _userRepository.UpdateAsync(user);
        
        _logger.LogInformation("User {CurrentUserId} successfully updated role for user {UserId} to {RoleId}", 
            currentUserId, id, roleId);

        return _mapper.Map<UserResponseDto>(updated);
    }

    public async Task<UserResponseDto?> ActivateUserAsync(Guid id)
    {
        // Input validation
        if (id == Guid.Empty)
            throw new ArgumentException("User ID cannot be empty", nameof(id));

        var currentUserId = _userContext.GetCurrentUserId();
        _logger.LogInformation("User {CurrentUserId} activating user {UserId}", currentUserId, id);

        var user = await _userRepository.GetByIdAsync(id);
        if (user == null)
        {
            _logger.LogWarning("User {UserId} not found for activation", id);
            return null;
        }

        // Multi-tenant authorization check
        if (!CanManageUser(user.ClinicId))
        {
            _logger.LogWarning("User {CurrentUserId} attempted to activate user {UserId} without permission", 
                currentUserId, id);
            throw new UnauthorizedAccessException("You don't have permission to activate this user");
        }

        // Check if already active
        if (user.IsActive)
        {
            _logger.LogInformation("User {UserId} is already active", id);
            return _mapper.Map<UserResponseDto>(user);
        }

        // Activate user
        user.IsActive = true;
        user.UpdatedAt = DateTime.UtcNow;
        user.UpdatedBy = currentUserId;

        var updated = await _userRepository.UpdateAsync(user);
        
        _logger.LogInformation("User {CurrentUserId} successfully activated user {UserId} ({Email})", 
            currentUserId, id, user.Email);

        return _mapper.Map<UserResponseDto>(updated);
    }

    public async Task<UserResponseDto?> DeactivateUserAsync(Guid id)
    {
        // Input validation
        if (id == Guid.Empty)
            throw new ArgumentException("User ID cannot be empty", nameof(id));

        var currentUserId = _userContext.GetCurrentUserId();
        _logger.LogInformation("User {CurrentUserId} deactivating user {UserId}", currentUserId, id);

        var user = await _userRepository.GetByIdAsync(id);
        if (user == null)
        {
            _logger.LogWarning("User {UserId} not found for deactivation", id);
            return null;
        }

        // Prevent self-deactivation
        if (user.Id.ToString() == currentUserId)
        {
            _logger.LogWarning("User {CurrentUserId} attempted to deactivate themselves", currentUserId);
            throw new InvalidOperationException("You cannot deactivate your own account");
        }

        // Multi-tenant authorization check
        if (!CanManageUser(user.ClinicId))
        {
            _logger.LogWarning("User {CurrentUserId} attempted to deactivate user {UserId} without permission", 
                currentUserId, id);
            throw new UnauthorizedAccessException("You don't have permission to deactivate this user");
        }

        // Check if already inactive
        if (!user.IsActive)
        {
            _logger.LogInformation("User {UserId} is already inactive", id);
            return _mapper.Map<UserResponseDto>(user);
        }

        // Deactivate user
        user.IsActive = false;
        user.UpdatedAt = DateTime.UtcNow;
        user.UpdatedBy = currentUserId;

        var updated = await _userRepository.UpdateAsync(user);
        
        _logger.LogInformation("User {CurrentUserId} successfully deactivated user {UserId} ({Email})", 
            currentUserId, id, user.Email);

        return _mapper.Map<UserResponseDto>(updated);
    }

    public async Task<bool> SoftDeleteUserAsync(Guid id)
    {
        // Input validation
        if (id == Guid.Empty)
            throw new ArgumentException("User ID cannot be empty", nameof(id));

        var currentUserId = _userContext.GetCurrentUserId();
        _logger.LogInformation("User {CurrentUserId} soft deleting user {UserId}", currentUserId, id);

        var user = await _userRepository.GetByIdAsync(id);
        if (user == null)
        {
            _logger.LogWarning("User {UserId} not found for soft delete", id);
            return false;
        }

        // Prevent self-deletion
        if (user.Id.ToString() == currentUserId)
        {
            _logger.LogWarning("User {CurrentUserId} attempted to delete themselves", currentUserId);
            throw new InvalidOperationException("You cannot delete your own account");
        }

        // Multi-tenant authorization check
        if (!CanManageUser(user.ClinicId))
        {
            _logger.LogWarning("User {CurrentUserId} attempted to delete user {UserId} without permission", 
                currentUserId, id);
            throw new UnauthorizedAccessException("You don't have permission to delete this user");
        }

        // Set audit fields before soft delete
        user.IsDeleted = true;
        user.DeletedAt = DateTime.UtcNow;
        user.DeletedBy = currentUserId;

        await _userRepository.UpdateAsync(user);
        
        _logger.LogInformation("User {CurrentUserId} successfully soft deleted user {UserId} ({Email})", 
            currentUserId, id, user.Email);

        return true;
    }

    public async Task<bool> HardDeleteUserAsync(Guid id)
    {
        // Input validation
        if (id == Guid.Empty)
            throw new ArgumentException("User ID cannot be empty", nameof(id));

        var currentUserId = _userContext.GetCurrentUserId();

        // Only SuperAdmin can hard delete
        if (!_tenantContext.IsSuperAdmin)
        {
            _logger.LogWarning("Non-SuperAdmin user {CurrentUserId} attempted to hard delete user {UserId}", 
                currentUserId, id);
            throw new UnauthorizedAccessException("Only SuperAdmin can permanently delete users");
        }

        _logger.LogWarning("SuperAdmin {CurrentUserId} permanently deleting user {UserId}", currentUserId, id);

        var user = await _userRepository.GetByIdAsync(id);
        if (user == null)
        {
            _logger.LogWarning("User {UserId} not found for hard delete", id);
            return false;
        }

        // Prevent self-deletion
        if (user.Id.ToString() == currentUserId)
        {
            _logger.LogWarning("SuperAdmin {CurrentUserId} attempted to permanently delete themselves", currentUserId);
            throw new InvalidOperationException("You cannot permanently delete your own account");
        }

        // Permanently delete
        var deleted = await _userRepository.DeleteAsync(id);
        
        if (deleted)
        {
            _logger.LogWarning("‚ö†Ô∏è SuperAdmin {CurrentUserId} PERMANENTLY DELETED user {UserId} ({Email})", 
                currentUserId, id, user.Email);
        }

        return deleted;
    }

    #endregion

    #region PASSWORD MANAGEMENT

    public async Task<UserResponseDto> ChangePasswordAsync(Guid id, ChangePasswordRequestDto dto)
    {
        // Input validation
        if (id == Guid.Empty)
            throw new ArgumentException("User ID cannot be empty", nameof(id));

        if (dto == null)
            throw new ArgumentNullException(nameof(dto));

        var currentUserId = _userContext.GetCurrentUserId();
        
        // Users can only change their own password
        if (id.ToString() != currentUserId)
        {
            _logger.LogWarning("User {CurrentUserId} attempted to change password for user {UserId}", 
                currentUserId, id);
            throw new UnauthorizedAccessException("You can only change your own password");
        }

        _logger.LogInformation("User {UserId} changing their password", id);

        var user = await _userRepository.GetByIdAsync(id);
        if (user == null)
        {
            _logger.LogWarning("User {UserId} not found for password change", id);
            throw new KeyNotFoundException($"User {id} not found");
        }

        // Verify current password
        if (!_passwordService.VerifyPassword(user, dto.CurrentPassword))
        {
            _logger.LogWarning("User {UserId} provided incorrect current password", id);
            throw new UnauthorizedAccessException("Current password is incorrect");
        }

        // Hash new password
        user.PasswordHash = _passwordService.HashPassword(user, dto.NewPassword);
        user.UpdatedAt = DateTime.UtcNow;
        user.UpdatedBy = currentUserId;

        var updated = await _userRepository.UpdateAsync(user);
        
        _logger.LogInformation("User {UserId} successfully changed their password", id);

        return _mapper.Map<UserResponseDto>(updated);
    }

    public async Task<UserResponseDto> ResetPasswordAsync(Guid id, ResetPasswordRequestDto dto)
    {
        // Input validation
        if (id == Guid.Empty)
            throw new ArgumentException("User ID cannot be empty", nameof(id));

        if (dto == null)
            throw new ArgumentNullException(nameof(dto));

        var currentUserId = _userContext.GetCurrentUserId();
        _logger.LogInformation("User {CurrentUserId} resetting password for user {UserId}", currentUserId, id);

        var user = await _userRepository.GetByIdAsync(id);
        if (user == null)
        {
            _logger.LogWarning("User {UserId} not found for password reset", id);
            throw new KeyNotFoundException($"User {id} not found");
        }

        // Multi-tenant authorization check
        if (!CanManageUser(user.ClinicId))
        {
            _logger.LogWarning("User {CurrentUserId} attempted to reset password for user {UserId} without permission", 
                currentUserId, id);
            throw new UnauthorizedAccessException("You don't have permission to reset this user's password");
        }

        // Hash new password
        user.PasswordHash = _passwordService.HashPassword(user, dto.NewPassword);
        user.UpdatedAt = DateTime.UtcNow;
        user.UpdatedBy = currentUserId;

        var updated = await _userRepository.UpdateAsync(user);
        
        _logger.LogInformation("User {CurrentUserId} successfully reset password for user {UserId}", 
            currentUserId, id);

        return _mapper.Map<UserResponseDto>(updated);
    }

    public async Task<UserResponseDto> AdminResetPasswordAsync(Guid id, ResetPasswordRequestDto dto)
    {
        // Input validation
        if (id == Guid.Empty)
            throw new ArgumentException("User ID cannot be empty", nameof(id));

        if (dto == null)
            throw new ArgumentNullException(nameof(dto));

        var currentUserId = _userContext.GetCurrentUserId();

        // Only SuperAdmin can use admin reset
        if (!_tenantContext.IsSuperAdmin)
        {
            _logger.LogWarning("Non-SuperAdmin user {CurrentUserId} attempted admin password reset for user {UserId}", 
                currentUserId, id);
            throw new UnauthorizedAccessException("Only SuperAdmin can use admin password reset");
        }

        _logger.LogWarning("SuperAdmin {CurrentUserId} resetting password for user {UserId}", currentUserId, id);

        var user = await _userRepository.GetByIdAsync(id);
        if (user == null)
        {
            _logger.LogWarning("User {UserId} not found for admin password reset", id);
            throw new KeyNotFoundException($"User {id} not found");
        }

        // Hash new password
        user.PasswordHash = _passwordService.HashPassword(user, dto.NewPassword);
        user.UpdatedAt = DateTime.UtcNow;
        user.UpdatedBy = currentUserId;

        var updated = await _userRepository.UpdateAsync(user);
        
        _logger.LogWarning("‚ö†Ô∏è SuperAdmin {CurrentUserId} reset password for user {UserId} ({Email}) in clinic {ClinicId}", 
            currentUserId, id, user.Email, user.ClinicId);

        return _mapper.Map<UserResponseDto>(updated);
    }

    #endregion

    #region HELPER METHODS

    /// <summary>
    /// Check if current user can access the specified user
    /// </summary>
    private bool CanAccessUser(User? user)
    {
        if (user == null)
            return false;

        // SuperAdmin can access all users
        if (_tenantContext.IsSuperAdmin)
            return true;

        // ClinicAdmin can only access users in their clinic
        return user.ClinicId.HasValue && user.ClinicId == _tenantContext.ClinicId;
    }

    /// <summary>
    /// Check if current user can manage users in the specified clinic
    /// </summary>
    private bool CanManageUser(Guid? targetClinicId)
    {
        // SuperAdmin can manage all users
        if (_tenantContext.IsSuperAdmin)
            return true;

        // ClinicAdmin can only manage users in their clinic
        return targetClinicId.HasValue && targetClinicId == _tenantContext.ClinicId;
    }

    /// <summary>
    /// Validate user creation DTO
    /// </summary>
    private void ValidateUserCreationDto(CreateUserRequestDto dto)
    {
        if (string.IsNullOrWhiteSpace(dto.Email))
            throw new ArgumentException("Email is required", nameof(dto.Email));

        if (string.IsNullOrWhiteSpace(dto.Password))
            throw new ArgumentException("Password is required", nameof(dto.Password));

        if (string.IsNullOrWhiteSpace(dto.FullName))
            throw new ArgumentException("Full name is required", nameof(dto.FullName));

        if (dto.RoleId == Guid.Empty)
            throw new ArgumentException("Role ID is required", nameof(dto.RoleId));
    }

    /// <summary>
    /// Validate and get target clinic ID for user creation
    /// </summary>
    private async Task<Guid?> ValidateAndGetTargetClinicId(Guid? requestedClinicId, Guid roleId)
    {
        var role = await _roleRepository.GetRoleByIdAsync(roleId);
        if (role == null)
            throw new InvalidOperationException($"Role {roleId} does not exist");

        if (_tenantContext.IsSuperAdmin)
        {
            if (role.IsSystemRole)
            {
                // For system roles, clinicId must be null
                if (requestedClinicId.HasValue)
                    throw new ArgumentException("System users must not have a clinic ID");

                return null;
            }
            else
            {
                // For clinic/template roles, clinicId is required
                if (!requestedClinicId.HasValue)
                    throw new ArgumentException("SuperAdmin must specify clinic ID when creating clinic users");

                return requestedClinicId.Value;
            }
        }
    
        // ClinicAdmin can only create users in their own clinic
        if (!_tenantContext.ClinicId.HasValue)
            throw new UnauthorizedAccessException("You must belong to a clinic to create users");

        if (requestedClinicId.HasValue && requestedClinicId != _tenantContext.ClinicId)
            throw new UnauthorizedAccessException("You can only create users in your own clinic");

        return _tenantContext.ClinicId.Value;
    }

    /// <summary>
    /// Validate role assignment
    /// </summary>
    private async Task ValidateRoleAssignment(Guid roleId, Guid? clinicId)
    {
        var role = await _roleRepository.GetRoleByIdAsync(roleId);
        if (role == null)
            throw new InvalidOperationException($"Role {roleId} does not exist");

        if (role.IsSystemRole)
        {
            // Only SuperAdmin can assign system roles, and only for system users (clinicId == null)
            if (!_tenantContext.IsSuperAdmin)
                throw new UnauthorizedAccessException("Only SuperAdmin can assign system roles");

            if (clinicId != null)
                throw new InvalidOperationException("System users must not have a clinic ID");

            // All good: SuperAdmin creating a system user
            return;
        }

        // For non-system roles:
        // Role must belong to the same clinic (or be a template)
        if (!role.IsTemplate && role.ClinicId != clinicId)
            throw new InvalidOperationException("Role does not belong to the specified clinic");
    }

    #endregion
}
========================================
File: ./NabdCare.Application/Interfaces/Payments/IPaymentRepository.cs
========================================
Ôªøusing NabdCare.Domain.Entities.Payments;

namespace NabdCare.Application.Interfaces.Payments;

public interface IPaymentRepository
{
    Task<Payment?> GetByIdAsync(Guid paymentId, bool includeChequeDetails = false);
    Task<IEnumerable<Payment>> GetBySubscriptionIdAsync(Guid subscriptionId, bool includeChequeDetails = false);
    Task<IEnumerable<Payment>> GetAllAsync(bool includeChequeDetails = false);
    Task<IEnumerable<Payment>> GetPagedAsync(int page, int pageSize, bool includeChequeDetails = false);

    Task<Payment> CreateAsync(Payment payment);
    Task<Payment> UpdateAsync(Payment payment);
    Task<bool> SoftDeleteAsync(Guid paymentId);
    Task<bool> DeleteAsync(Guid paymentId);
}
========================================
File: ./NabdCare.Application/Interfaces/Auth/IAuthService.cs
========================================
using NabdCare.Domain.Entities.Users;

namespace NabdCare.Application.Interfaces.Auth;

public interface IAuthService
{
    /// <summary>
    /// Logs in a user with email & password.
    /// Returns access token + refresh token.
    /// </summary>
    /// <param name="email">User email</param>
    /// <param name="password">User password (plain)</param>
    /// <param name="requestIp">IP address of the request (for audit)</param>
    Task<(string accessToken, string refreshToken)> LoginAsync(string email, string password, string requestIp);

    /// <summary>
    /// Refreshes tokens using a refresh token string.
    /// Implements rotation: revokes old, issues new.
    /// </summary>
    /// <param name="refreshToken">The old refresh token value</param>
    /// <param name="requestIp">IP address of the request (for audit)</param>
    Task<(string accessToken, string refreshToken)> RefreshTokenAsync(string refreshToken, string requestIp);

    /// <summary>
    /// Logs out (revokes) the given refresh token.
    /// </summary>
    /// <param name="refreshToken">Token to revoke</param>
    /// <param name="requestIp">IP address of the request (for audit)</param>
    Task LogoutAsync(string refreshToken, string requestIp);
}
========================================
File: ./NabdCare.Application/Interfaces/Auth/IAuthRepository.cs
========================================
using NabdCare.Domain.Entities.Permissions;
using NabdCare.Domain.Entities.Users;

namespace NabdCare.Application.Interfaces.Auth;
/// <summary>
/// Repository interface for authentication and refresh token management.
/// </summary>
public interface IAuthRepository
{
    Task<User?> AuthenticateUserAsync(string email, string password);
    Task<User?> AuthenticateUserByIdAsync(Guid userId);
    Task SaveRefreshTokenAsync(User user, RefreshToken token);
    Task<RefreshToken?> GetRefreshTokenIncludingRevokedAsync(string token);
    Task RevokeRefreshTokenAsync(string token, string revokedByIp, string reason);
    Task RevokeTokenFamilyAsync(RefreshToken token);
    Task RevokeAllUserTokensAsync(Guid userId, string revokedByIp, string reason);

    Task<RefreshToken?> GetRefreshTokenAsync(string token);
}
========================================
File: ./NabdCare.Application/Interfaces/Roles/IRoleService.cs
========================================
using NabdCare.Application.DTOs.Roles;

namespace NabdCare.Application.Interfaces.Roles;

/// <summary>
/// Service for managing roles in the multi-tenant system.
/// Handles system roles, template roles, and clinic-specific roles.
/// </summary>
public interface IRoleService
{
    // ============================================
    // QUERY METHODS
    // ============================================
    
    /// <summary>
    /// Get all roles accessible to current user.
    /// SuperAdmin: All roles (system, templates, clinic-specific)
    /// ClinicAdmin: Template roles + their clinic's roles
    /// </summary>
    Task<IEnumerable<RoleResponseDto>> GetAllRolesAsync();
    
    /// <summary>
    /// Get system roles (SuperAdmin, SupportManager, BillingManager).
    /// Only accessible to SuperAdmin.
    /// </summary>
    Task<IEnumerable<RoleResponseDto>> GetSystemRolesAsync();
    
    /// <summary>
    /// Get template roles that can be cloned by clinics.
    /// </summary>
    Task<IEnumerable<RoleResponseDto>> GetTemplateRolesAsync();
    
    /// <summary>
    /// Get roles for a specific clinic.
    /// </summary>
    Task<IEnumerable<RoleResponseDto>> GetClinicRolesAsync(Guid clinicId);
    
    /// <summary>
    /// Get role by ID.
    /// </summary>
    Task<RoleResponseDto?> GetRoleByIdAsync(Guid id);
    
    /// <summary>
    /// Get all permissions assigned to a role.
    /// </summary>
    Task<IEnumerable<string>> GetRolePermissionsAsync(Guid roleId);

    // ============================================
    // COMMAND METHODS
    // ============================================
    
    /// <summary>
    /// Create a new custom role.
    /// SuperAdmin: Can create system roles or clinic-specific roles for any clinic.
    /// ClinicAdmin: Can create roles only for their clinic.
    /// </summary>
    Task<RoleResponseDto> CreateRoleAsync(CreateRoleRequestDto dto);
    
    /// <summary>
    /// Clone a template role for a clinic.
    /// Optionally copies all permissions from the template.
    /// </summary>
    Task<RoleResponseDto> CloneRoleAsync(Guid templateRoleId, Guid? targetClinicId, string? newRoleName);
    
    /// <summary>
    /// Update role details.
    /// Cannot update system roles.
    /// ClinicAdmin can only update roles in their clinic.
    /// </summary>
    Task<RoleResponseDto?> UpdateRoleAsync(Guid id, UpdateRoleRequestDto dto);
    
    /// <summary>
    /// Delete a role.
    /// Cannot delete:
    /// - System roles
    /// - Roles with users assigned
    /// - Template roles (must convert to non-template first)
    /// </summary>
    Task<bool> DeleteRoleAsync(Guid id);

    // ============================================
    // PERMISSION MANAGEMENT
    // ============================================
    
    /// <summary>
    /// Assign a permission to a role.
    /// </summary>
    Task<bool> AssignPermissionToRoleAsync(Guid roleId, Guid permissionId);
    
    /// <summary>
    /// Remove a permission from a role.
    /// </summary>
    Task<bool> RemovePermissionFromRoleAsync(Guid roleId, Guid permissionId);
    
    /// <summary>
    /// Bulk assign multiple permissions to a role.
    /// </summary>
    Task<int> BulkAssignPermissionsAsync(Guid roleId, IEnumerable<Guid> permissionIds);
    
    /// <summary>
    /// Sync role permissions (replace all existing with new set).
    /// </summary>
    Task<bool> SyncRolePermissionsAsync(Guid roleId, IEnumerable<Guid> permissionIds);
}
========================================
File: ./NabdCare.Application/Interfaces/Roles/IRoleRepository.cs
========================================
using NabdCare.Domain.Entities.Permissions;

namespace NabdCare.Application.Interfaces.Roles;

public interface IRoleRepository
{
    // ============================================
    // QUERY METHODS
    // ============================================
    
    Task<IEnumerable<Role>> GetAllRolesAsync();
    Task<IEnumerable<Role>> GetSystemRolesAsync();
    Task<IEnumerable<Role>> GetTemplateRolesAsync();
    Task<IEnumerable<Role>> GetClinicRolesAsync(Guid clinicId);
    Task<Role?> GetRoleByIdAsync(Guid id);
    Task<Role?> GetRoleByNameAsync(string name, Guid? clinicId = null);
    Task<int> GetRoleUserCountAsync(Guid roleId);
    Task<int> GetRolePermissionCountAsync(Guid roleId);
    Task<bool> RoleExistsAsync(Guid id);
    Task<bool> RoleNameExistsAsync(string name, Guid? clinicId, Guid? excludeRoleId = null);

    // ============================================
    // COMMAND METHODS
    // ============================================
    
    Task<Role> CreateRoleAsync(Role role);
    Task<Role?> UpdateRoleAsync(Role role);
    Task<bool> DeleteRoleAsync(Guid id);

    // ============================================
    // PERMISSION MANAGEMENT
    // ============================================
    
    Task<IEnumerable<Guid>> GetRolePermissionIdsAsync(Guid roleId);
    Task<bool> AssignPermissionToRoleAsync(Guid roleId, Guid permissionId);
    Task<bool> RemovePermissionFromRoleAsync(Guid roleId, Guid permissionId);
    Task<int> BulkAssignPermissionsAsync(Guid roleId, IEnumerable<Guid> permissionIds);
    Task<bool> SyncRolePermissionsAsync(Guid roleId, IEnumerable<Guid> permissionIds);
}
========================================
File: ./NabdCare.Application/Interfaces/Permissions/IPermissionService.cs
========================================
Ôªøusing NabdCare.Application.DTOs.Permissions;

namespace NabdCare.Application.Interfaces.Permissions;

public interface IPermissionService
{
    // CRUD
    Task<IEnumerable<PermissionResponseDto>> GetAllPermissionsAsync();
    Task<IEnumerable<PermissionResponseDto>> GetPermissionsByRoleAsync(Guid roleId);
    Task<IEnumerable<PermissionResponseDto>> GetPermissionsByUserAsync(Guid userId);
    Task<PermissionResponseDto?> GetPermissionByIdAsync(Guid id);
    Task<PermissionResponseDto> CreatePermissionAsync(CreatePermissionDto dto);
    Task<PermissionResponseDto?> UpdatePermissionAsync(Guid id, UpdatePermissionDto dto);
    Task<bool> DeletePermissionAsync(Guid id);

    Task<bool> AssignPermissionToRoleAsync(Guid roleId, Guid permissionId);
    Task<bool> RemovePermissionFromRoleAsync(Guid roleId, Guid permissionId);

    // UserPermission
    Task<bool> AssignPermissionToUserAsync(Guid userId, Guid permissionId);
    Task<bool> RemovePermissionFromUserAsync(Guid userId, Guid permissionId);

    Task<IEnumerable<PermissionResponseDto>> GetUserEffectivePermissionsAsync(Guid userId, Guid roleId);
    Task<bool> UserHasPermissionAsync(Guid userId, Guid roleId, string permissionName);
}
========================================
File: ./NabdCare.Application/Interfaces/Permissions/IPermissionRepository.cs
========================================
Ôªø
using NabdCare.Domain.Entities.Permissions;

namespace NabdCare.Application.Interfaces.Permissions;

public interface IPermissionRepository
{
    // CRUD
    Task<IEnumerable<AppPermission>> GetAllPermissionsAsync();
    Task<AppPermission?> GetPermissionByIdAsync(Guid permissionId);
    Task<AppPermission> CreatePermissionAsync(AppPermission appPermission);
    Task<AppPermission?> UpdatePermissionAsync(Guid permissionId, AppPermission appPermission);
    Task<bool> DeletePermissionAsync(Guid permissionId);

    Task<IEnumerable<AppPermission>> GetPermissionsByRoleAsync(Guid roleId);
    Task<bool> AssignPermissionToRoleAsync(Guid roleId, Guid permissionId);
    Task<bool> RemovePermissionFromRoleAsync(Guid roleId, Guid permissionId);

    // User Permissions
    Task<IEnumerable<AppPermission>> GetPermissionsByUserAsync(Guid userId);
    Task<bool> AssignPermissionToUserAsync(Guid userId, Guid permissionId);
    Task<bool> RemovePermissionFromUserAsync(Guid userId, Guid permissionId);
}
========================================
File: ./NabdCare.Application/Interfaces/ISingleSeeder.cs
========================================
namespace NabdCare.Application.Interfaces;

/// <summary>
/// Interface for database seeding operations
/// </summary>
public interface ISingleSeeder
{
    /// <summary>
    /// Order in which this seeder should run (lower numbers run first)
    /// Default: 999 (runs last)
    /// </summary>
    int Order { get; }

    /// <summary>
    /// Execute the seeding logic
    /// </summary>
    Task SeedAsync();
}
========================================
File: ./NabdCare.Application/Interfaces/Clinics/IClinicService.cs
========================================
using NabdCare.Application.DTOs.Clinics;
using NabdCare.Domain.Enums;

namespace NabdCare.Application.Interfaces.Clinics;

/// <summary>
/// Service interface for clinic business operations.
/// Handles business logic, validation, and multi-tenant security.
/// </summary>
public interface IClinicService
{
    // ============================================
    // QUERY METHODS
    // ============================================
    
    /// <summary>
    /// Get clinic by ID (tenant-filtered for non-SuperAdmin)
    /// </summary>
    Task<ClinicResponseDto?> GetClinicByIdAsync(Guid id);
    
    /// <summary>
    /// Get all clinics (SuperAdmin only)
    /// </summary>
    Task<IEnumerable<ClinicResponseDto>> GetAllClinicsAsync();
    
    /// <summary>
    /// Get clinics by subscription status (SuperAdmin only)
    /// </summary>
    Task<IEnumerable<ClinicResponseDto>> GetClinicsByStatusAsync(SubscriptionStatus status);
    
    /// <summary>
    /// Get active clinics with valid subscriptions (SuperAdmin only)
    /// </summary>
    Task<IEnumerable<ClinicResponseDto>> GetActiveClinicsAsync();
    
    /// <summary>
    /// Get clinics with expiring subscriptions (SuperAdmin only)
    /// </summary>
    Task<IEnumerable<ClinicResponseDto>> GetClinicsWithExpiringSubscriptionsAsync(int withinDays);
    
    /// <summary>
    /// Get clinics with expired subscriptions (SuperAdmin only)
    /// </summary>
    Task<IEnumerable<ClinicResponseDto>> GetClinicsWithExpiredSubscriptionsAsync();
    
    /// <summary>
    /// Get paginated clinics (SuperAdmin only)
    /// </summary>
    Task<IEnumerable<ClinicResponseDto>> GetPagedClinicsAsync(int page, int pageSize);
    
    /// <summary>
    /// Search clinics by name, email, or phone (SuperAdmin only)
    /// </summary>
    Task<IEnumerable<ClinicResponseDto>> SearchClinicsAsync(string query);

    // ============================================
    // COMMAND METHODS
    // ============================================
    
    /// <summary>
    /// Create new clinic with initial subscription (SuperAdmin only)
    /// </summary>
    Task<ClinicResponseDto> CreateClinicAsync(CreateClinicRequestDto dto);
    
    /// <summary>
    /// Update clinic (SuperAdmin or own clinic only)
    /// </summary>
    Task<ClinicResponseDto?> UpdateClinicAsync(Guid id, UpdateClinicRequestDto dto);
    
    /// <summary>
    /// Update clinic subscription status (SuperAdmin only)
    /// </summary>
    Task<ClinicResponseDto?> UpdateClinicStatusAsync(Guid id, UpdateClinicStatusDto dto);
    
    /// <summary>
    /// Activate clinic (SuperAdmin only)
    /// </summary>
    Task<ClinicResponseDto?> ActivateClinicAsync(Guid id);
    
    /// <summary>
    /// Suspend clinic (SuperAdmin only)
    /// </summary>
    Task<ClinicResponseDto?> SuspendClinicAsync(Guid id);
    
    /// <summary>
    /// Soft delete clinic (SuperAdmin only)
    /// </summary>
    Task<bool> SoftDeleteClinicAsync(Guid id);
    
    /// <summary>
    /// Permanently delete clinic (SuperAdmin only)
    /// </summary>
    Task<bool> DeleteClinicAsync(Guid id);

    // ============================================
    // STATISTICS
    // ============================================
    
    /// <summary>
    /// Get clinic statistics (SuperAdmin only)
    /// </summary>
    Task<ClinicStatisticsDto?> GetClinicStatisticsAsync(Guid id);
}
========================================
File: ./NabdCare.Application/Interfaces/Clinics/Subscriptions/ISubscriptionRepository.cs
========================================
Ôªøusing NabdCare.Domain.Entities.Clinics;

namespace NabdCare.Application.Interfaces.Clinics.Subscriptions;

public interface ISubscriptionRepository
{
    Task<Subscription?> GetByIdAsync(Guid id, bool includePayments = false);
    Task<IEnumerable<Subscription>> GetByClinicIdAsync(Guid clinicId, bool includePayments = false);
    Task<IEnumerable<Subscription>> GetAllAsync(bool includePayments = false);
    Task<IEnumerable<Subscription>> GetPagedAsync(int page, int pageSize, bool includePayments = false);

    Task<Subscription> CreateAsync(Subscription subscription);
    Task<Subscription> UpdateAsync(Subscription subscription);

    Task<bool> SoftDeleteAsync(Guid id);
    Task<bool> DeleteAsync(Guid id);
}
========================================
File: ./NabdCare.Application/Interfaces/Clinics/Subscriptions/ISubscriptionService.cs
========================================
Ôªøusing NabdCare.Application.DTOs.Clinics.Subscriptions;

namespace NabdCare.Application.Interfaces.Clinics.Subscriptions;

public interface ISubscriptionService
{
    Task<SubscriptionResponseDto> CreateSubscriptionAsync(CreateSubscriptionRequestDto dto);
    Task<SubscriptionResponseDto?> GetByIdAsync(Guid id, bool includePayments = false);
    Task<IEnumerable<SubscriptionResponseDto>> GetByClinicIdAsync(Guid clinicId, bool includePayments = false);
    Task<IEnumerable<SubscriptionResponseDto>> GetPagedAsync(int page, int pageSize, bool includePayments = false);
    Task<SubscriptionResponseDto?> UpdateSubscriptionAsync(Guid id, UpdateSubscriptionRequestDto dto);
    Task<bool> SoftDeleteSubscriptionAsync(Guid id);
    Task<bool> DeleteSubscriptionAsync(Guid id);
}
========================================
File: ./NabdCare.Application/Interfaces/Clinics/IClinicRepository.cs
========================================
using NabdCare.Domain.Entities.Clinics;
using NabdCare.Domain.Enums;

namespace NabdCare.Application.Interfaces.Clinics;

/// <summary>
/// Repository interface for clinic data access operations.
/// Thin data access layer - no business logic.
/// </summary>
public interface IClinicRepository
{
    // ============================================
    // QUERY METHODS
    // ============================================
    
    /// <summary>
    /// Get clinic by ID with subscriptions
    /// </summary>
    Task<Clinic?> GetByIdAsync(Guid id);
    
    /// <summary>
    /// Get all clinics (SuperAdmin only)
    /// </summary>
    Task<IEnumerable<Clinic>> GetAllAsync();
    
    /// <summary>
    /// Get clinics by subscription status
    /// </summary>
    Task<IEnumerable<Clinic>> GetByStatusAsync(SubscriptionStatus status);
    
    /// <summary>
    /// Get clinics with active status and valid subscription (EndDate > Now)
    /// </summary>
    Task<IEnumerable<Clinic>> GetActiveWithValidSubscriptionAsync();
    
    /// <summary>
    /// Get clinics with expiring subscriptions (within days)
    /// </summary>
    Task<IEnumerable<Clinic>> GetWithExpiringSubscriptionsAsync(int withinDays);
    
    /// <summary>
    /// Get clinics with expired subscriptions
    /// </summary>
    Task<IEnumerable<Clinic>> GetWithExpiredSubscriptionsAsync();
    
    /// <summary>
    /// Get paginated clinics
    /// </summary>
    Task<IEnumerable<Clinic>> GetPagedAsync(int page, int pageSize);
    
    /// <summary>
    /// Search clinics by name, email, or phone
    /// </summary>
    Task<IEnumerable<Clinic>> SearchAsync(string query);
    
    /// <summary>
    /// Check if clinic name exists (excluding specified ID)
    /// </summary>
    Task<bool> ExistsByNameAsync(string name, Guid? excludeId = null);
    
    /// <summary>
    /// Check if clinic email exists (excluding specified ID)
    /// </summary>
    Task<bool> ExistsByEmailAsync(string email, Guid? excludeId = null);
    
    /// <summary>
    /// Check if clinic exists by ID
    /// </summary>
    Task<bool> ExistsAsync(Guid id);

    // ============================================
    // COMMAND METHODS
    // ============================================
    
    /// <summary>
    /// Create new clinic
    /// </summary>
    Task<Clinic> CreateAsync(Clinic clinic);
    
    /// <summary>
    /// Update existing clinic
    /// </summary>
    Task<Clinic> UpdateAsync(Clinic clinic);
    
    /// <summary>
    /// Soft delete clinic (can be restored)
    /// </summary>
    Task<bool> SoftDeleteAsync(Guid id);
    
    /// <summary>
    /// Permanently delete clinic (irreversible)
    /// </summary>
    Task<bool> DeleteAsync(Guid id);

    // ============================================
    // STATISTICS
    // ============================================
    
    /// <summary>
    /// Get total count of clinics
    /// </summary>
    Task<int> GetTotalCountAsync();
    
    /// <summary>
    /// Get count by subscription status
    /// </summary>
    Task<int> GetCountByStatusAsync(SubscriptionStatus status);
    
    /// <summary>
    /// Get count of clinics with active subscriptions
    /// </summary>
    Task<int> GetActiveCountAsync();
}
========================================
File: ./NabdCare.Application/Interfaces/Users/IUserService.cs
========================================
Ôªøusing NabdCare.Application.DTOs.Users;

namespace NabdCare.Application.Interfaces.Users;

/// <summary>
/// Service interface for user management operations.
/// All methods include multi-tenant security, audit logging, and comprehensive error handling.
/// </summary>
public interface IUserService
{
    // ============================================
    // QUERY METHODS
    // ============================================
    
    /// <summary>
    /// Get user by ID with multi-tenant filtering
    /// </summary>
    Task<UserResponseDto?> GetUserByIdAsync(Guid id);
    
    /// <summary>
    /// Get all users. SuperAdmin: all users. ClinicAdmin: only clinic users.
    /// </summary>
    Task<IEnumerable<UserResponseDto>> GetUsersByClinicIdAsync(Guid? clinicId);
    
    /// <summary>
    /// Get current authenticated user's details
    /// </summary>
    Task<UserResponseDto?> GetCurrentUserAsync();

    // ============================================
    // COMMAND METHODS
    // ============================================
    
    /// <summary>
    /// Create a new user
    /// </summary>
    Task<UserResponseDto> CreateUserAsync(CreateUserRequestDto dto);
    
    /// <summary>
    /// Update user information
    /// </summary>
    Task<UserResponseDto?> UpdateUserAsync(Guid id, UpdateUserRequestDto dto);
    
    /// <summary>
    /// Update user's role
    /// </summary>
    Task<UserResponseDto?> UpdateUserRoleAsync(Guid id, Guid roleId);
    
    /// <summary>
    /// Activate a deactivated user account
    /// </summary>
    Task<UserResponseDto?> ActivateUserAsync(Guid id);
    
    /// <summary>
    /// Deactivate a user account (prevents login)
    /// </summary>
    Task<UserResponseDto?> DeactivateUserAsync(Guid id);
    
    /// <summary>
    /// Soft delete user (can be restored)
    /// </summary>
    Task<bool> SoftDeleteUserAsync(Guid id);
    
    /// <summary>
    /// Permanently delete user (SuperAdmin only - IRREVERSIBLE)
    /// </summary>
    Task<bool> HardDeleteUserAsync(Guid id);

    // ============================================
    // PASSWORD MANAGEMENT
    // ============================================
    
    /// <summary>
    /// User changes their own password
    /// </summary>
    Task<UserResponseDto> ChangePasswordAsync(Guid id, ChangePasswordRequestDto dto);
    
    /// <summary>
    /// ClinicAdmin resets password for users in their clinic
    /// </summary>
    Task<UserResponseDto> ResetPasswordAsync(Guid id, ResetPasswordRequestDto dto);
    
    /// <summary>
    /// SuperAdmin resets password for any user in any clinic
    /// </summary>
    Task<UserResponseDto> AdminResetPasswordAsync(Guid id, ResetPasswordRequestDto dto);
}
========================================
File: ./NabdCare.Application/Interfaces/Users/IUserRepository.cs
========================================
Ôªøusing NabdCare.Domain.Entities.Users;

namespace NabdCare.Application.Interfaces.Users;

/// <summary>
/// Repository interface for user data access operations.
/// Provides comprehensive CRUD operations with multi-tenant support.
/// </summary>
public interface IUserRepository
{
    // ============================================
    // QUERY METHODS
    // ============================================
    
    /// <summary>
    /// Get user by ID with related entities (Clinic, Role)
    /// </summary>
    Task<User?> GetByIdAsync(Guid userId);
    
    /// <summary>
    /// Get user by email address
    /// </summary>
    Task<User?> GetByEmailAsync(string email);
    
    /// <summary>
    /// Get all users (SuperAdmin only)
    /// </summary>
    Task<IEnumerable<User>> GetAllAsync();
    
    /// <summary>
    /// Get users by clinic ID. If null, returns all users.
    /// </summary>
    Task<IEnumerable<User>> GetByClinicIdAsync(Guid clinicId);
    
    /// <summary>
    /// Check if email already exists (case-insensitive)
    /// </summary>
    Task<bool> EmailExistsAsync(string email);
    
    /// <summary>
    /// Check if user exists by ID
    /// </summary>
    Task<bool> ExistsAsync(Guid userId);

    // ============================================
    // COMMAND METHODS
    // ============================================
    
    /// <summary>
    /// Create a new user
    /// </summary>
    Task<User> CreateAsync(User user);
    
    /// <summary>
    /// Update existing user
    /// </summary>
    Task<User> UpdateAsync(User user);
    
    /// <summary>
    /// Soft delete user (marks as deleted, can be restored)
    /// </summary>
    Task<bool> SoftDeleteAsync(Guid userId);
    
    /// <summary>
    /// Permanently delete user (irreversible)
    /// </summary>
    Task<bool> DeleteAsync(Guid userId);
}
========================================
File: ./NabdCare.Application/Interfaces/ITokenService.cs
========================================
namespace NabdCare.Application.Interfaces;

public interface ITokenService
{
    string GenerateToken(string userId, string email, string roleName, Guid roleId, Guid? clinicId,
        string fullName);

    string GenerateRefreshToken();
}
========================================
File: ./NabdCare.Application/Interfaces/IPasswordService.cs
========================================
Ôªøusing NabdCare.Domain.Entities.Users;

namespace NabdCare.Application.Interfaces;

public interface IPasswordService
{
    /// <summary>
    /// Hashes a password for a specific user
    /// </summary>
    /// <param name="user">The user entity</param>
    /// <param name="password">Plain text password</param>
    /// <returns>Hashed password</returns>
    string HashPassword(User user, string password);

    /// <summary>
    /// Verifies a plain text password against the user's stored hash
    /// </summary>
    /// <param name="user">The user entity with stored PasswordHash</param>
    /// <param name="password">Plain text password to verify</param>
    /// <returns>True if password matches, false otherwise</returns>
    bool VerifyPassword(User user, string password);
}
========================================
File: ./NabdCare.Shared/obj/Debug/net8.0/.NETCoreApp,Version=v8.0.AssemblyAttributes.cs
========================================
// <autogenerated />
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v8.0", FrameworkDisplayName = ".NET 8.0")]

========================================
File: ./NabdCare.Shared/obj/Debug/net8.0/NabdCare.Shared.AssemblyInfo.cs
========================================
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("NabdCare.Shared")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+404a61d5f45213b03261a6fc7fff592311d4bbda")]
[assembly: System.Reflection.AssemblyProductAttribute("NabdCare.Shared")]
[assembly: System.Reflection.AssemblyTitleAttribute("NabdCare.Shared")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]

// Generated by the MSBuild WriteCodeFragment class.


========================================
File: ./NabdCare.Shared/obj/Debug/net8.0/NabdCare.Shared.GlobalUsings.g.cs
========================================
// <auto-generated/>
global using global::System;
global using global::System.Collections.Generic;
global using global::System.IO;
global using global::System.Linq;
global using global::System.Net.Http;
global using global::System.Threading;
global using global::System.Threading.Tasks;

========================================
File: ./NabdCare.Domain/obj/Debug/net8.0/.NETCoreApp,Version=v8.0.AssemblyAttributes.cs
========================================
// <autogenerated />
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v8.0", FrameworkDisplayName = ".NET 8.0")]

========================================
File: ./NabdCare.Domain/obj/Debug/net8.0/NabdCare.Domain.GlobalUsings.g.cs
========================================
// <auto-generated/>
global using global::System;
global using global::System.Collections.Generic;
global using global::System.IO;
global using global::System.Linq;
global using global::System.Net.Http;
global using global::System.Threading;
global using global::System.Threading.Tasks;

========================================
File: ./NabdCare.Domain/obj/Debug/net8.0/NabdCare.Domain.AssemblyInfo.cs
========================================
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("NabdCare.Domain")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+404a61d5f45213b03261a6fc7fff592311d4bbda")]
[assembly: System.Reflection.AssemblyProductAttribute("NabdCare.Domain")]
[assembly: System.Reflection.AssemblyTitleAttribute("NabdCare.Domain")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]

// Generated by the MSBuild WriteCodeFragment class.


========================================
File: ./NabdCare.Domain/Enums/SubscriptionStatus.cs
========================================
using TypeGen.Core.TypeAnnotations;

namespace NabdCare.Domain.Enums;

/// <summary>
/// Subscription status enum for clinic subscriptions.
/// Author: Rabee-Qabaha
/// Updated: 2025-10-22 20:53:22 UTC
/// </summary>
[ExportTsEnum]
public enum SubscriptionStatus
{
    /// <summary>
    /// Subscription is active and clinic can operate normally
    /// </summary>
    Active = 0,
    
    /// <summary>
    /// Subscription has expired (EndDate passed)
    /// </summary>
    Expired = 1,
    
    /// <summary>
    /// Subscription was cancelled by clinic or admin
    /// </summary>
    Cancelled = 2,
    
    /// <summary>
    /// Subscription is temporarily suspended (non-payment, violation, etc.)
    /// </summary>
    Suspended = 3,
    
    /// <summary>
    /// Trial period subscription
    /// </summary>
    Trial = 4
}
========================================
File: ./NabdCare.Domain/Enums/SubscriptionType.cs
========================================
using TypeGen.Core.TypeAnnotations;

namespace NabdCare.Domain.Enums;

[ExportTsEnum]
public enum SubscriptionType
{
    Monthly = 0,
    Yearly = 1,
    Lifetime = 2
}
========================================
File: ./NabdCare.Domain/Enums/PaymentStatus.cs
========================================
Ôªøusing TypeGen.Core.TypeAnnotations;

namespace NabdCare.Domain.Enums;

[ExportTsEnum]
public enum PaymentStatus
{
    Pending,
    Completed,
    Failed,
    Refunded
}

========================================
File: ./NabdCare.Domain/Enums/PaymentContext.cs
========================================
Ôªøusing TypeGen.Core.TypeAnnotations;

namespace NabdCare.Domain.Enums;

[ExportTsEnum]
public enum PaymentContext
{
    Clinic,
    Patient
}
========================================
File: ./NabdCare.Domain/Enums/PaymentMethod.cs
========================================
using TypeGen.Core.TypeAnnotations;

namespace NabdCare.Domain.Enums;

[ExportTsEnum]
public enum PaymentMethod
{
    Cash,
    Cheque,
    Visa,
    BankTransfer
}
========================================
File: ./NabdCare.Domain/Enums/ChequeStatus.cs
========================================
Ôªøusing TypeGen.Core.TypeAnnotations;

namespace NabdCare.Domain.Enums;

[ExportTsEnum]
    public enum ChequeStatus
    {
        Pending, 
        Cleared, 
        Bounced, 
        Cancelled
    }

========================================
File: ./NabdCare.Domain/Entities/Patients/Patient.cs
========================================
Ôªønamespace NabdCare.Domain.Entities.Patients
{
    public class Patient: BaseEntity
    {
    }
}

========================================
File: ./NabdCare.Domain/Entities/Payments/ChequePaymentDetail.cs
========================================
Ôªøusing System.ComponentModel.DataAnnotations;
using NabdCare.Domain.Enums;

namespace NabdCare.Domain.Entities.Payments;

public class ChequePaymentDetail : BaseEntity
{
    [Required]
    public Guid PaymentId { get; set; }
    public Payment Payment { get; set; } = null!;

    [Required, MaxLength(50)]
    public string ChequeNumber { get; set; } = string.Empty;

    [Required, MaxLength(100)]
    public string BankName { get; set; } = string.Empty;

    [MaxLength(100)]
    public string Branch { get; set; } = string.Empty;

    [Required]
    public DateTime IssueDate { get; set; }

    [Required]
    public DateTime DueDate { get; set; }

    [Required]
    [Range(0.01, double.MaxValue, ErrorMessage = "Cheque amount must be greater than zero.")]
    public decimal Amount { get; set; }

    [Required]
    public ChequeStatus Status { get; set; } = ChequeStatus.Pending;

    public DateTime? ClearedDate { get; set; }
}
========================================
File: ./NabdCare.Domain/Entities/Payments/Payment.cs
========================================
using System.ComponentModel.DataAnnotations;
using NabdCare.Domain.Entities.Clinics;
using NabdCare.Domain.Entities.Patients;
using NabdCare.Domain.Enums;

namespace NabdCare.Domain.Entities.Payments;

public class Payment : BaseEntity
{
    [Required]
    public PaymentContext Context { get; set; }

    // Foreign Keys (only one must be filled depending on Context)
    public Guid? ClinicId { get; set; }
    public Clinic? Clinic { get; set; }

    public Guid? PatientId { get; set; }
    public Patient? Patient { get; set; }

    [Required]
    [Range(0.01, double.MaxValue, ErrorMessage = "Payment amount must be greater than zero.")]
    public decimal Amount { get; set; }

    [Required]
    public DateTime PaymentDate { get; set; } = DateTime.UtcNow;

    [Required]
    public PaymentMethod Method { get; set; }

    [Required]
    public PaymentStatus Status { get; set; } = PaymentStatus.Pending;

    // Navigation for cheque
    public ChequePaymentDetail? ChequeDetail { get; set; }
}
========================================
File: ./NabdCare.Domain/Entities/Audits/AuditLog.cs
========================================
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;

namespace NabdCare.Domain.Entities.Audits;

/// <summary>
/// GDPR-compliant audit log for tracking sensitive operations
/// This table is INSERT-ONLY (no updates or deletes allowed)
/// </summary>
public class AuditLog
{
    [Key]
    [DatabaseGenerated(DatabaseGeneratedOption.Identity)]
    public Guid Id { get; set; }

    #region Who (Actor Information)

    /// <summary>
    /// User who performed the action
    /// </summary>
    public Guid? UserId { get; set; }

    /// <summary>
    /// Email of the user (for readability, since users can be deleted)
    /// </summary>
    [Required]
    [MaxLength(100)]
    public string UserEmail { get; set; } = string.Empty;

    /// <summary>
    /// Tenant context (null for SaaS-level actions)
    /// </summary>
    public Guid? ClinicId { get; set; }

    #endregion

    #region What (Entity & Action)

    /// <summary>
    /// Type of entity affected (e.g., "Role", "User", "Permission", "Patient")
    /// </summary>
    [Required]
    [MaxLength(50)]
    public string EntityType { get; set; } = string.Empty;

    /// <summary>
    /// ID of the affected entity (null for system-level actions)
    /// </summary>
    public Guid? EntityId { get; set; }

    /// <summary>
    /// Action performed (e.g., "Created", "Updated", "Deleted", "Accessed", "PermissionAdded")
    /// </summary>
    [Required]
    [MaxLength(50)]
    public string Action { get; set; } = string.Empty;

    #endregion

    #region Details

    /// <summary>
    /// JSON representation of changes made
    /// Format: {"FieldName": {"Old": "value1", "New": "value2"}}
    /// Example: {"Name": {"Old": "Doctor", "New": "Senior Doctor"}}
    /// </summary>
    [Column(TypeName = "jsonb")] // PostgreSQL JSONB for efficient querying
    public string? Changes { get; set; }

    /// <summary>
    /// Optional reason or notes for the action (user-provided)
    /// </summary>
    [MaxLength(1000)]
    public string? Reason { get; set; }

    #endregion

    #region When & Where

    /// <summary>
    /// When the action occurred (UTC)
    /// </summary>
    [Required]
    public DateTime Timestamp { get; set; } = DateTime.UtcNow;

    /// <summary>
    /// IP address of the request
    /// </summary>
    [MaxLength(45)] // IPv6 max length
    public string? IpAddress { get; set; }

    /// <summary>
    /// User agent (browser/client information)
    /// </summary>
    [MaxLength(500)]
    public string? UserAgent { get; set; }

    #endregion
}
========================================
File: ./NabdCare.Domain/Entities/BaseEntity.cs
========================================
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;
using NabdCare.Domain.Interfaces;

namespace NabdCare.Domain.Entities;

public abstract class BaseEntity : IAuditable, ISoftDeletable
{
    [Key]
    [DatabaseGenerated(DatabaseGeneratedOption.Identity)]
    public Guid Id { get; set; }

    public DateTime CreatedAt { get; set; }
    public string? CreatedBy { get; set; }
    public DateTime? UpdatedAt { get; set; }
    public string? UpdatedBy { get; set; }
    public bool IsDeleted { get; set; }
    public DateTime? DeletedAt { get; set; }
    public string? DeletedBy { get; set; }
}
========================================
File: ./NabdCare.Domain/Entities/Permissions/Role.cs
========================================
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;
using NabdCare.Domain.Entities.Clinics;
using NabdCare.Domain.Entities.Users;

namespace NabdCare.Domain.Entities.Permissions;

/// <summary>
/// Dynamic role entity supporting both SaaS-level and tenant-level roles
/// </summary>
public class Role : BaseEntity
{
    /// <summary>
    /// Role name (e.g., "SuperAdmin", "Senior Doctor", "Lab Technician")
    /// Unique per clinic (not globally unique)
    /// </summary>
    [Required]
    [MaxLength(100)]
    public string Name { get; set; } = string.Empty;

    /// <summary>
    /// Detailed description of the role's purpose
    /// </summary>
    [MaxLength(500)]
    public string? Description { get; set; }

    /// <summary>
    /// Multi-tenancy support:
    /// - null = System-wide role (SaaS level) or Template role
    /// - Guid = Clinic-specific role
    /// </summary>
    public Guid? ClinicId { get; set; }
    [ForeignKey(nameof(ClinicId))]
    public Clinic? Clinic { get; set; }

    /// <summary>
    /// System roles are created by SuperAdmin and cannot be deleted
    /// Examples: SuperAdmin, SupportManager, BillingManager
    /// </summary>
    public bool IsSystemRole { get; set; } = false;

    /// <summary>
    /// Template roles are read-only blueprints that clinics can clone
    /// Examples: Doctor, Nurse, Receptionist, Clinic Admin
    /// </summary>
    public bool IsTemplate { get; set; } = false;

    /// <summary>
    /// If this role was cloned from a template, this references the original
    /// Used for tracking template relationships
    /// </summary>
    public Guid? TemplateRoleId { get; set; }
    [ForeignKey(nameof(TemplateRoleId))]
    public Role? TemplateRole { get; set; }

    /// <summary>
    /// Display order for sorting in UI (lower numbers appear first)
    /// System roles: 1-9, Templates: 10-19, Custom: 20+
    /// </summary>
    public int DisplayOrder { get; set; } = 100;

    /// <summary>
    /// Hex color code for UI display (e.g., "#DC2626" for red)
    /// </summary>
    [MaxLength(7)]
    public string? ColorCode { get; set; }

    /// <summary>
    /// Optional icon class for UI display
    /// Examples: "fa-user-md", "lucide-stethoscope", "mdi-doctor"
    /// </summary>
    [MaxLength(50)]
    public string? IconClass { get; set; }

    // Navigation properties
    public ICollection<RolePermission> RolePermissions { get; set; } = new List<RolePermission>();
    public ICollection<User> Users { get; set; } = new List<User>();
}
========================================
File: ./NabdCare.Domain/Entities/Permissions/AppPermission.cs
========================================
using System.ComponentModel.DataAnnotations;

namespace NabdCare.Domain.Entities.Permissions;

public class AppPermission : BaseEntity
{
    [Required]
    [MaxLength(100)] 
    public string Name { get; set; } = string.Empty;

    [MaxLength(500)] 
    public string? Description { get; set; }

    // Navigation properties
    public ICollection<RolePermission> RolePermissions { get; set; } = new List<RolePermission>();
    public ICollection<UserPermission> UserPermissions { get; set; } = new List<UserPermission>();
}
========================================
File: ./NabdCare.Domain/Entities/Permissions/RefreshToken.cs
========================================
namespace NabdCare.Domain.Entities.Permissions;

public class RefreshToken : BaseEntity
{
    public Guid UserId { get; set; }
    public string Token { get; set; } = string.Empty;

    public new DateTime CreatedAt { get; set; } = DateTime.UtcNow;
    public string? CreatedByIp { get; set; }

    public DateTime ExpiresAt { get; set; }
    public bool IsRevoked { get; set; } = false;
    public DateTime? RevokedAt { get; set; }
    public string? RevokedByIp { get; set; }
    public string? ReplacedByToken { get; set; }
    public string? ReasonRevoked { get; set; }
}
========================================
File: ./NabdCare.Domain/Entities/Permissions/RolePermission.cs
========================================
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;

namespace NabdCare.Domain.Entities.Permissions;

public class RolePermission : BaseEntity
{
    [Required]
    public Guid RoleId { get; set; }
    [ForeignKey(nameof(RoleId))]
    public Role Role { get; set; } = null!;

    [Required]
    public Guid PermissionId { get; set; }
    [ForeignKey(nameof(PermissionId))]
    public AppPermission AppPermission { get; set; } = null!;
}
========================================
File: ./NabdCare.Domain/Entities/Permissions/UserPermission.cs
========================================
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;
using NabdCare.Domain.Entities.Users;

namespace NabdCare.Domain.Entities.Permissions;

public class UserPermission : BaseEntity
{
    [Required]
    public Guid UserId { get; set; }
    [ForeignKey(nameof(UserId))]
    public User User { get; set; }

    [Required]
    public Guid PermissionId { get; set; }
    [ForeignKey(nameof(PermissionId))]
    public AppPermission AppPermission { get; set; }
}
========================================
File: ./NabdCare.Domain/Entities/Clinics/Clinic.cs
========================================
using NabdCare.Domain.Enums;

namespace NabdCare.Domain.Entities.Clinics;

public class Clinic : BaseEntity
{
    public string Name { get; set; } = string.Empty;
    public string? Email { get; set; }
    public string? Phone { get; set; }
    public string? Address { get; set; }

    public SubscriptionStatus Status { get; set; } = SubscriptionStatus.Active;

    // Each clinic can have one active subscription
    public ICollection<Subscription>? Subscriptions { get; set; } = new List<Subscription>();

    public int BranchCount { get; set; } = 1;
}
========================================
File: ./NabdCare.Domain/Entities/Clinics/Subscription.cs
========================================
Ôªøusing NabdCare.Domain.Entities.Payments;
using NabdCare.Domain.Enums;

namespace NabdCare.Domain.Entities.Clinics;
public class Subscription : BaseEntity
{
    public Guid ClinicId { get; set; }
    public Clinic Clinic { get; set; } = null!;

    public DateTime StartDate { get; set; }
    public DateTime EndDate { get; set; }
    public SubscriptionType Type { get; set; }
    public decimal Fee { get; set; }
    public SubscriptionStatus Status { get; set; }
    
    public ICollection<Payment> Payments { get; set; } = new List<Payment>();
}
========================================
File: ./NabdCare.Domain/Entities/Users/User.cs
========================================
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;
using NabdCare.Domain.Entities.Clinics;
using NabdCare.Domain.Entities.Permissions;
using TypeGen.Core.TypeAnnotations;

namespace NabdCare.Domain.Entities.Users;

[ExportTsClass]
[TsIgnoreBase]
public class User : BaseEntity
{
    public Guid? ClinicId { get; set; }
    [ForeignKey(nameof(ClinicId))]
    public Clinic? Clinic { get; set; }

    [Required]
    [MaxLength(100)]
    public string Email { get; set; } = string.Empty;

    [Required]
    [MaxLength(255)]
    public string PasswordHash { get; set; } = string.Empty;

    [Required]
    [MaxLength(255)]
    public string FullName { get; set; } = string.Empty;

    [Required]
    public Guid RoleId { get; set; }
    [ForeignKey(nameof(RoleId))]
    public Role Role { get; set; } = null!;

    [Required]
    public bool IsActive { get; set; } = true;

    public Guid? CreatedByUserId { get; set; }
    [ForeignKey(nameof(CreatedByUserId))]
    public User? CreatedByUser { get; set; }

    public ICollection<UserPermission> Permissions { get; set; } = new List<UserPermission>();
}
========================================
File: ./NabdCare.Domain/Interfaces/ISoftDeletable.cs
========================================
namespace NabdCare.Domain.Interfaces;

public interface ISoftDeletable
{
    bool IsDeleted { get; set; }
    DateTime? DeletedAt { get; set; }
    string? DeletedBy { get; set; }
}
========================================
File: ./NabdCare.Domain/Interfaces/IAuditable.cs
========================================

namespace NabdCare.Domain.Interfaces;

public interface IAuditable
{
    DateTime CreatedAt { get; set; }
    string? CreatedBy { get; set; }
    DateTime? UpdatedAt { get; set; }
    string? UpdatedBy { get; set; }
}
========================================
File: ./NabdCare.Infrastructure/obj/Debug/net8.0/.NETCoreApp,Version=v8.0.AssemblyAttributes.cs
========================================
// <autogenerated />
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v8.0", FrameworkDisplayName = ".NET 8.0")]

========================================
File: ./NabdCare.Infrastructure/obj/Debug/net8.0/NabdCare.Infrastructure.AssemblyInfo.cs
========================================
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("NabdCare.Infrastructure")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+404a61d5f45213b03261a6fc7fff592311d4bbda")]
[assembly: System.Reflection.AssemblyProductAttribute("NabdCare.Infrastructure")]
[assembly: System.Reflection.AssemblyTitleAttribute("NabdCare.Infrastructure")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]

// Generated by the MSBuild WriteCodeFragment class.


========================================
File: ./NabdCare.Infrastructure/obj/Debug/net8.0/NabdCare.Infrastructure.GlobalUsings.g.cs
========================================
// <auto-generated/>
global using global::System;
global using global::System.Collections.Generic;
global using global::System.IO;
global using global::System.Linq;
global using global::System.Net.Http;
global using global::System.Threading;
global using global::System.Threading.Tasks;

========================================
File: ./NabdCare.Infrastructure/Migrations/20251021195128_InitialDynamicRolesWithGroupedPermissions.cs
========================================
Ôªøusing System;
using Microsoft.EntityFrameworkCore.Migrations;

#nullable disable

namespace NabdCare.Infrastructure.Migrations
{
    /// <inheritdoc />
    public partial class InitialDynamicRolesWithGroupedPermissions : Migration
    {
        /// <inheritdoc />
        protected override void Up(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.CreateTable(
                name: "AppPermissions",
                columns: table => new
                {
                    Id = table.Column<Guid>(type: "uuid", nullable: false),
                    Name = table.Column<string>(type: "character varying(100)", maxLength: 100, nullable: false),
                    Description = table.Column<string>(type: "character varying(500)", maxLength: 500, nullable: true),
                    CreatedAt = table.Column<DateTime>(type: "timestamp with time zone", nullable: false),
                    CreatedBy = table.Column<string>(type: "text", nullable: true),
                    UpdatedAt = table.Column<DateTime>(type: "timestamp with time zone", nullable: true),
                    UpdatedBy = table.Column<string>(type: "text", nullable: true),
                    IsDeleted = table.Column<bool>(type: "boolean", nullable: false),
                    DeletedAt = table.Column<DateTime>(type: "timestamp with time zone", nullable: true),
                    DeletedBy = table.Column<string>(type: "text", nullable: true)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_AppPermissions", x => x.Id);
                });

            migrationBuilder.CreateTable(
                name: "AuditLogs",
                columns: table => new
                {
                    Id = table.Column<Guid>(type: "uuid", nullable: false),
                    UserId = table.Column<Guid>(type: "uuid", nullable: true),
                    UserEmail = table.Column<string>(type: "character varying(100)", maxLength: 100, nullable: false),
                    ClinicId = table.Column<Guid>(type: "uuid", nullable: true),
                    EntityType = table.Column<string>(type: "character varying(50)", maxLength: 50, nullable: false),
                    EntityId = table.Column<Guid>(type: "uuid", nullable: true),
                    Action = table.Column<string>(type: "character varying(50)", maxLength: 50, nullable: false),
                    Changes = table.Column<string>(type: "jsonb", nullable: true),
                    Reason = table.Column<string>(type: "character varying(1000)", maxLength: 1000, nullable: true),
                    Timestamp = table.Column<DateTime>(type: "timestamp with time zone", nullable: false, defaultValueSql: "NOW()"),
                    IpAddress = table.Column<string>(type: "character varying(45)", maxLength: 45, nullable: true),
                    UserAgent = table.Column<string>(type: "character varying(500)", maxLength: 500, nullable: true)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_AuditLogs", x => x.Id);
                });

            migrationBuilder.CreateTable(
                name: "Clinics",
                columns: table => new
                {
                    Id = table.Column<Guid>(type: "uuid", nullable: false),
                    Name = table.Column<string>(type: "character varying(255)", maxLength: 255, nullable: false),
                    Email = table.Column<string>(type: "character varying(100)", maxLength: 100, nullable: true),
                    Phone = table.Column<string>(type: "character varying(15)", maxLength: 15, nullable: true),
                    Address = table.Column<string>(type: "text", nullable: true),
                    Status = table.Column<int>(type: "integer", nullable: false),
                    BranchCount = table.Column<int>(type: "integer", nullable: false),
                    CreatedAt = table.Column<DateTime>(type: "timestamp with time zone", nullable: false),
                    CreatedBy = table.Column<string>(type: "text", nullable: true),
                    UpdatedAt = table.Column<DateTime>(type: "timestamp with time zone", nullable: true),
                    UpdatedBy = table.Column<string>(type: "text", nullable: true),
                    IsDeleted = table.Column<bool>(type: "boolean", nullable: false),
                    DeletedAt = table.Column<DateTime>(type: "timestamp with time zone", nullable: true),
                    DeletedBy = table.Column<string>(type: "text", nullable: true)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_Clinics", x => x.Id);
                });

            migrationBuilder.CreateTable(
                name: "Patient",
                columns: table => new
                {
                    Id = table.Column<Guid>(type: "uuid", nullable: false),
                    CreatedAt = table.Column<DateTime>(type: "timestamp with time zone", nullable: false),
                    CreatedBy = table.Column<string>(type: "text", nullable: true),
                    UpdatedAt = table.Column<DateTime>(type: "timestamp with time zone", nullable: true),
                    UpdatedBy = table.Column<string>(type: "text", nullable: true),
                    IsDeleted = table.Column<bool>(type: "boolean", nullable: false),
                    DeletedAt = table.Column<DateTime>(type: "timestamp with time zone", nullable: true),
                    DeletedBy = table.Column<string>(type: "text", nullable: true)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_Patient", x => x.Id);
                });

            migrationBuilder.CreateTable(
                name: "RefreshTokens",
                columns: table => new
                {
                    Id = table.Column<Guid>(type: "uuid", nullable: false),
                    UserId = table.Column<Guid>(type: "uuid", nullable: false),
                    Token = table.Column<string>(type: "text", nullable: false),
                    CreatedAt = table.Column<DateTime>(type: "timestamp with time zone", nullable: false, defaultValueSql: "NOW()"),
                    CreatedByIp = table.Column<string>(type: "text", nullable: true),
                    ExpiresAt = table.Column<DateTime>(type: "timestamp with time zone", nullable: false),
                    IsRevoked = table.Column<bool>(type: "boolean", nullable: false),
                    RevokedAt = table.Column<DateTime>(type: "timestamp with time zone", nullable: true),
                    RevokedByIp = table.Column<string>(type: "text", nullable: true),
                    ReplacedByToken = table.Column<string>(type: "text", nullable: true),
                    ReasonRevoked = table.Column<string>(type: "text", nullable: true),
                    CreatedBy = table.Column<string>(type: "text", nullable: true),
                    UpdatedAt = table.Column<DateTime>(type: "timestamp with time zone", nullable: true),
                    UpdatedBy = table.Column<string>(type: "text", nullable: true),
                    IsDeleted = table.Column<bool>(type: "boolean", nullable: false),
                    DeletedAt = table.Column<DateTime>(type: "timestamp with time zone", nullable: true),
                    DeletedBy = table.Column<string>(type: "text", nullable: true)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_RefreshTokens", x => x.Id);
                });

            migrationBuilder.CreateTable(
                name: "Roles",
                columns: table => new
                {
                    Id = table.Column<Guid>(type: "uuid", nullable: false),
                    Name = table.Column<string>(type: "character varying(100)", maxLength: 100, nullable: false),
                    Description = table.Column<string>(type: "character varying(500)", maxLength: 500, nullable: true),
                    ClinicId = table.Column<Guid>(type: "uuid", nullable: true),
                    IsSystemRole = table.Column<bool>(type: "boolean", nullable: false),
                    IsTemplate = table.Column<bool>(type: "boolean", nullable: false),
                    TemplateRoleId = table.Column<Guid>(type: "uuid", nullable: true),
                    DisplayOrder = table.Column<int>(type: "integer", nullable: false, defaultValue: 100),
                    ColorCode = table.Column<string>(type: "character varying(7)", maxLength: 7, nullable: true),
                    IconClass = table.Column<string>(type: "character varying(50)", maxLength: 50, nullable: true),
                    CreatedAt = table.Column<DateTime>(type: "timestamp with time zone", nullable: false),
                    CreatedBy = table.Column<string>(type: "text", nullable: true),
                    UpdatedAt = table.Column<DateTime>(type: "timestamp with time zone", nullable: true),
                    UpdatedBy = table.Column<string>(type: "text", nullable: true),
                    IsDeleted = table.Column<bool>(type: "boolean", nullable: false),
                    DeletedAt = table.Column<DateTime>(type: "timestamp with time zone", nullable: true),
                    DeletedBy = table.Column<string>(type: "text", nullable: true)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_Roles", x => x.Id);
                    table.ForeignKey(
                        name: "FK_Roles_Clinics_ClinicId",
                        column: x => x.ClinicId,
                        principalTable: "Clinics",
                        principalColumn: "Id",
                        onDelete: ReferentialAction.Restrict);
                    table.ForeignKey(
                        name: "FK_Roles_Roles_TemplateRoleId",
                        column: x => x.TemplateRoleId,
                        principalTable: "Roles",
                        principalColumn: "Id",
                        onDelete: ReferentialAction.Restrict);
                });

            migrationBuilder.CreateTable(
                name: "Subscriptions",
                columns: table => new
                {
                    Id = table.Column<Guid>(type: "uuid", nullable: false),
                    ClinicId = table.Column<Guid>(type: "uuid", nullable: false),
                    StartDate = table.Column<DateTime>(type: "timestamp with time zone", nullable: false),
                    EndDate = table.Column<DateTime>(type: "timestamp with time zone", nullable: false),
                    Type = table.Column<int>(type: "integer", nullable: false),
                    Fee = table.Column<decimal>(type: "numeric(18,2)", precision: 18, scale: 2, nullable: false),
                    Status = table.Column<int>(type: "integer", nullable: false),
                    CreatedAt = table.Column<DateTime>(type: "timestamp with time zone", nullable: false),
                    CreatedBy = table.Column<string>(type: "text", nullable: true),
                    UpdatedAt = table.Column<DateTime>(type: "timestamp with time zone", nullable: true),
                    UpdatedBy = table.Column<string>(type: "text", nullable: true),
                    IsDeleted = table.Column<bool>(type: "boolean", nullable: false),
                    DeletedAt = table.Column<DateTime>(type: "timestamp with time zone", nullable: true),
                    DeletedBy = table.Column<string>(type: "text", nullable: true)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_Subscriptions", x => x.Id);
                    table.ForeignKey(
                        name: "FK_Subscriptions_Clinics_ClinicId",
                        column: x => x.ClinicId,
                        principalTable: "Clinics",
                        principalColumn: "Id",
                        onDelete: ReferentialAction.Cascade);
                });

            migrationBuilder.CreateTable(
                name: "RolePermissions",
                columns: table => new
                {
                    Id = table.Column<Guid>(type: "uuid", nullable: false),
                    RoleId = table.Column<Guid>(type: "uuid", nullable: false),
                    PermissionId = table.Column<Guid>(type: "uuid", nullable: false),
                    AppPermissionId = table.Column<Guid>(type: "uuid", nullable: true),
                    CreatedAt = table.Column<DateTime>(type: "timestamp with time zone", nullable: false),
                    CreatedBy = table.Column<string>(type: "text", nullable: true),
                    UpdatedAt = table.Column<DateTime>(type: "timestamp with time zone", nullable: true),
                    UpdatedBy = table.Column<string>(type: "text", nullable: true),
                    IsDeleted = table.Column<bool>(type: "boolean", nullable: false),
                    DeletedAt = table.Column<DateTime>(type: "timestamp with time zone", nullable: true),
                    DeletedBy = table.Column<string>(type: "text", nullable: true)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_RolePermissions", x => x.Id);
                    table.ForeignKey(
                        name: "FK_RolePermissions_AppPermissions_AppPermissionId",
                        column: x => x.AppPermissionId,
                        principalTable: "AppPermissions",
                        principalColumn: "Id");
                    table.ForeignKey(
                        name: "FK_RolePermissions_AppPermissions_PermissionId",
                        column: x => x.PermissionId,
                        principalTable: "AppPermissions",
                        principalColumn: "Id",
                        onDelete: ReferentialAction.Cascade);
                    table.ForeignKey(
                        name: "FK_RolePermissions_Roles_RoleId",
                        column: x => x.RoleId,
                        principalTable: "Roles",
                        principalColumn: "Id",
                        onDelete: ReferentialAction.Cascade);
                });

            migrationBuilder.CreateTable(
                name: "Users",
                columns: table => new
                {
                    Id = table.Column<Guid>(type: "uuid", nullable: false),
                    ClinicId = table.Column<Guid>(type: "uuid", nullable: true),
                    Email = table.Column<string>(type: "character varying(100)", maxLength: 100, nullable: false),
                    PasswordHash = table.Column<string>(type: "character varying(255)", maxLength: 255, nullable: false),
                    FullName = table.Column<string>(type: "character varying(255)", maxLength: 255, nullable: false),
                    RoleId = table.Column<Guid>(type: "uuid", nullable: false),
                    IsActive = table.Column<bool>(type: "boolean", nullable: false),
                    CreatedByUserId = table.Column<Guid>(type: "uuid", nullable: true),
                    CreatedAt = table.Column<DateTime>(type: "timestamp with time zone", nullable: false),
                    CreatedBy = table.Column<string>(type: "text", nullable: true),
                    UpdatedAt = table.Column<DateTime>(type: "timestamp with time zone", nullable: true),
                    UpdatedBy = table.Column<string>(type: "text", nullable: true),
                    IsDeleted = table.Column<bool>(type: "boolean", nullable: false),
                    DeletedAt = table.Column<DateTime>(type: "timestamp with time zone", nullable: true),
                    DeletedBy = table.Column<string>(type: "text", nullable: true)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_Users", x => x.Id);
                    table.ForeignKey(
                        name: "FK_Users_Clinics_ClinicId",
                        column: x => x.ClinicId,
                        principalTable: "Clinics",
                        principalColumn: "Id",
                        onDelete: ReferentialAction.Restrict);
                    table.ForeignKey(
                        name: "FK_Users_Roles_RoleId",
                        column: x => x.RoleId,
                        principalTable: "Roles",
                        principalColumn: "Id",
                        onDelete: ReferentialAction.Restrict);
                    table.ForeignKey(
                        name: "FK_Users_Users_CreatedByUserId",
                        column: x => x.CreatedByUserId,
                        principalTable: "Users",
                        principalColumn: "Id");
                });

            migrationBuilder.CreateTable(
                name: "Payments",
                columns: table => new
                {
                    Id = table.Column<Guid>(type: "uuid", nullable: false),
                    Context = table.Column<int>(type: "integer", nullable: false),
                    ClinicId = table.Column<Guid>(type: "uuid", nullable: true),
                    PatientId = table.Column<Guid>(type: "uuid", nullable: true),
                    Amount = table.Column<decimal>(type: "numeric(18,2)", precision: 18, scale: 2, nullable: false),
                    PaymentDate = table.Column<DateTime>(type: "timestamp with time zone", nullable: false, defaultValueSql: "NOW()"),
                    Method = table.Column<int>(type: "integer", nullable: false),
                    Status = table.Column<int>(type: "integer", nullable: false, defaultValue: 0),
                    SubscriptionId = table.Column<Guid>(type: "uuid", nullable: true),
                    CreatedAt = table.Column<DateTime>(type: "timestamp with time zone", nullable: false),
                    CreatedBy = table.Column<string>(type: "text", nullable: true),
                    UpdatedAt = table.Column<DateTime>(type: "timestamp with time zone", nullable: true),
                    UpdatedBy = table.Column<string>(type: "text", nullable: true),
                    IsDeleted = table.Column<bool>(type: "boolean", nullable: false),
                    DeletedAt = table.Column<DateTime>(type: "timestamp with time zone", nullable: true),
                    DeletedBy = table.Column<string>(type: "text", nullable: true)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_Payments", x => x.Id);
                    table.CheckConstraint("CK_Payment_Context", "(\"Context\" = 0 AND \"ClinicId\" IS NOT NULL AND \"PatientId\" IS NULL) OR (\"Context\" = 1 AND \"PatientId\" IS NOT NULL AND \"ClinicId\" IS NULL)");
                    table.ForeignKey(
                        name: "FK_Payments_Clinics_ClinicId",
                        column: x => x.ClinicId,
                        principalTable: "Clinics",
                        principalColumn: "Id",
                        onDelete: ReferentialAction.Restrict);
                    table.ForeignKey(
                        name: "FK_Payments_Patient_PatientId",
                        column: x => x.PatientId,
                        principalTable: "Patient",
                        principalColumn: "Id",
                        onDelete: ReferentialAction.Restrict);
                    table.ForeignKey(
                        name: "FK_Payments_Subscriptions_SubscriptionId",
                        column: x => x.SubscriptionId,
                        principalTable: "Subscriptions",
                        principalColumn: "Id");
                });

            migrationBuilder.CreateTable(
                name: "UserPermissions",
                columns: table => new
                {
                    Id = table.Column<Guid>(type: "uuid", nullable: false),
                    UserId = table.Column<Guid>(type: "uuid", nullable: false),
                    PermissionId = table.Column<Guid>(type: "uuid", nullable: false),
                    AppPermissionId = table.Column<Guid>(type: "uuid", nullable: true),
                    CreatedAt = table.Column<DateTime>(type: "timestamp with time zone", nullable: false),
                    CreatedBy = table.Column<string>(type: "text", nullable: true),
                    UpdatedAt = table.Column<DateTime>(type: "timestamp with time zone", nullable: true),
                    UpdatedBy = table.Column<string>(type: "text", nullable: true),
                    IsDeleted = table.Column<bool>(type: "boolean", nullable: false),
                    DeletedAt = table.Column<DateTime>(type: "timestamp with time zone", nullable: true),
                    DeletedBy = table.Column<string>(type: "text", nullable: true)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_UserPermissions", x => x.Id);
                    table.ForeignKey(
                        name: "FK_UserPermissions_AppPermissions_AppPermissionId",
                        column: x => x.AppPermissionId,
                        principalTable: "AppPermissions",
                        principalColumn: "Id");
                    table.ForeignKey(
                        name: "FK_UserPermissions_AppPermissions_PermissionId",
                        column: x => x.PermissionId,
                        principalTable: "AppPermissions",
                        principalColumn: "Id",
                        onDelete: ReferentialAction.Cascade);
                    table.ForeignKey(
                        name: "FK_UserPermissions_Users_UserId",
                        column: x => x.UserId,
                        principalTable: "Users",
                        principalColumn: "Id",
                        onDelete: ReferentialAction.Cascade);
                });

            migrationBuilder.CreateTable(
                name: "ChequePaymentDetails",
                columns: table => new
                {
                    Id = table.Column<Guid>(type: "uuid", nullable: false),
                    PaymentId = table.Column<Guid>(type: "uuid", nullable: false),
                    ChequeNumber = table.Column<string>(type: "character varying(50)", maxLength: 50, nullable: false),
                    BankName = table.Column<string>(type: "character varying(100)", maxLength: 100, nullable: false),
                    Branch = table.Column<string>(type: "character varying(100)", maxLength: 100, nullable: false),
                    IssueDate = table.Column<DateTime>(type: "timestamp with time zone", nullable: false),
                    DueDate = table.Column<DateTime>(type: "timestamp with time zone", nullable: false),
                    Amount = table.Column<decimal>(type: "numeric(18,2)", precision: 18, scale: 2, nullable: false),
                    Status = table.Column<int>(type: "integer", nullable: false),
                    ClearedDate = table.Column<DateTime>(type: "timestamp with time zone", nullable: true),
                    CreatedAt = table.Column<DateTime>(type: "timestamp with time zone", nullable: false),
                    CreatedBy = table.Column<string>(type: "text", nullable: true),
                    UpdatedAt = table.Column<DateTime>(type: "timestamp with time zone", nullable: true),
                    UpdatedBy = table.Column<string>(type: "text", nullable: true),
                    IsDeleted = table.Column<bool>(type: "boolean", nullable: false),
                    DeletedAt = table.Column<DateTime>(type: "timestamp with time zone", nullable: true),
                    DeletedBy = table.Column<string>(type: "text", nullable: true)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_ChequePaymentDetails", x => x.Id);
                    table.ForeignKey(
                        name: "FK_ChequePaymentDetails_Payments_PaymentId",
                        column: x => x.PaymentId,
                        principalTable: "Payments",
                        principalColumn: "Id",
                        onDelete: ReferentialAction.Cascade);
                });

            migrationBuilder.CreateIndex(
                name: "IX_AppPermissions_Name",
                table: "AppPermissions",
                column: "Name",
                unique: true);

            migrationBuilder.CreateIndex(
                name: "IX_AuditLogs_Action",
                table: "AuditLogs",
                column: "Action");

            migrationBuilder.CreateIndex(
                name: "IX_AuditLogs_Clinic_Timestamp",
                table: "AuditLogs",
                columns: new[] { "ClinicId", "Timestamp" });

            migrationBuilder.CreateIndex(
                name: "IX_AuditLogs_ClinicId",
                table: "AuditLogs",
                column: "ClinicId");

            migrationBuilder.CreateIndex(
                name: "IX_AuditLogs_Entity",
                table: "AuditLogs",
                columns: new[] { "EntityType", "EntityId" });

            migrationBuilder.CreateIndex(
                name: "IX_AuditLogs_Timestamp",
                table: "AuditLogs",
                column: "Timestamp");

            migrationBuilder.CreateIndex(
                name: "IX_AuditLogs_UserId",
                table: "AuditLogs",
                column: "UserId");

            migrationBuilder.CreateIndex(
                name: "IX_ChequePaymentDetails_ChequeNumber",
                table: "ChequePaymentDetails",
                column: "ChequeNumber",
                unique: true);

            migrationBuilder.CreateIndex(
                name: "IX_ChequePaymentDetails_PaymentId",
                table: "ChequePaymentDetails",
                column: "PaymentId",
                unique: true);

            migrationBuilder.CreateIndex(
                name: "IX_ChequePaymentDetails_Status",
                table: "ChequePaymentDetails",
                column: "Status");

            migrationBuilder.CreateIndex(
                name: "IX_Clinics_Email",
                table: "Clinics",
                column: "Email");

            migrationBuilder.CreateIndex(
                name: "IX_Clinics_Name",
                table: "Clinics",
                column: "Name");

            migrationBuilder.CreateIndex(
                name: "IX_Payments_ClinicId",
                table: "Payments",
                column: "ClinicId");

            migrationBuilder.CreateIndex(
                name: "IX_Payments_ClinicId_PaymentDate",
                table: "Payments",
                columns: new[] { "ClinicId", "PaymentDate" });

            migrationBuilder.CreateIndex(
                name: "IX_Payments_Context_ClinicId_PatientId",
                table: "Payments",
                columns: new[] { "Context", "ClinicId", "PatientId" });

            migrationBuilder.CreateIndex(
                name: "IX_Payments_PatientId",
                table: "Payments",
                column: "PatientId");

            migrationBuilder.CreateIndex(
                name: "IX_Payments_PatientId_PaymentDate",
                table: "Payments",
                columns: new[] { "PatientId", "PaymentDate" });

            migrationBuilder.CreateIndex(
                name: "IX_Payments_PaymentDate",
                table: "Payments",
                column: "PaymentDate");

            migrationBuilder.CreateIndex(
                name: "IX_Payments_SubscriptionId",
                table: "Payments",
                column: "SubscriptionId");

            migrationBuilder.CreateIndex(
                name: "IX_RefreshTokens_ExpiresAt",
                table: "RefreshTokens",
                column: "ExpiresAt");

            migrationBuilder.CreateIndex(
                name: "IX_RefreshTokens_Token",
                table: "RefreshTokens",
                column: "Token",
                unique: true);

            migrationBuilder.CreateIndex(
                name: "IX_RefreshTokens_UserId",
                table: "RefreshTokens",
                column: "UserId");

            migrationBuilder.CreateIndex(
                name: "IX_RolePermissions_AppPermissionId",
                table: "RolePermissions",
                column: "AppPermissionId");

            migrationBuilder.CreateIndex(
                name: "IX_RolePermissions_PermissionId",
                table: "RolePermissions",
                column: "PermissionId");

            migrationBuilder.CreateIndex(
                name: "IX_RolePermissions_Role_Permission",
                table: "RolePermissions",
                columns: new[] { "RoleId", "PermissionId" },
                unique: true);

            migrationBuilder.CreateIndex(
                name: "IX_Roles_ClinicId",
                table: "Roles",
                column: "ClinicId");

            migrationBuilder.CreateIndex(
                name: "IX_Roles_DisplayOrder",
                table: "Roles",
                column: "DisplayOrder");

            migrationBuilder.CreateIndex(
                name: "IX_Roles_IsSystemRole",
                table: "Roles",
                column: "IsSystemRole");

            migrationBuilder.CreateIndex(
                name: "IX_Roles_IsTemplate",
                table: "Roles",
                column: "IsTemplate");

            migrationBuilder.CreateIndex(
                name: "IX_Roles_Name_ClinicId",
                table: "Roles",
                columns: new[] { "Name", "ClinicId" },
                unique: true);

            migrationBuilder.CreateIndex(
                name: "IX_Roles_TemplateRoleId",
                table: "Roles",
                column: "TemplateRoleId");

            migrationBuilder.CreateIndex(
                name: "IX_Subscriptions_ClinicId",
                table: "Subscriptions",
                column: "ClinicId");

            migrationBuilder.CreateIndex(
                name: "IX_Subscriptions_Status",
                table: "Subscriptions",
                column: "Status");

            migrationBuilder.CreateIndex(
                name: "IX_UserPermissions_AppPermissionId",
                table: "UserPermissions",
                column: "AppPermissionId");

            migrationBuilder.CreateIndex(
                name: "IX_UserPermissions_PermissionId",
                table: "UserPermissions",
                column: "PermissionId");

            migrationBuilder.CreateIndex(
                name: "IX_UserPermissions_UserId_PermissionId",
                table: "UserPermissions",
                columns: new[] { "UserId", "PermissionId" },
                unique: true);

            migrationBuilder.CreateIndex(
                name: "IX_Users_ClinicId",
                table: "Users",
                column: "ClinicId");

            migrationBuilder.CreateIndex(
                name: "IX_Users_CreatedByUserId",
                table: "Users",
                column: "CreatedByUserId");

            migrationBuilder.CreateIndex(
                name: "IX_Users_Email",
                table: "Users",
                column: "Email",
                unique: true);

            migrationBuilder.CreateIndex(
                name: "IX_Users_FullName",
                table: "Users",
                column: "FullName");

            migrationBuilder.CreateIndex(
                name: "IX_Users_RoleId",
                table: "Users",
                column: "RoleId");
        }

        /// <inheritdoc />
        protected override void Down(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.DropTable(
                name: "AuditLogs");

            migrationBuilder.DropTable(
                name: "ChequePaymentDetails");

            migrationBuilder.DropTable(
                name: "RefreshTokens");

            migrationBuilder.DropTable(
                name: "RolePermissions");

            migrationBuilder.DropTable(
                name: "UserPermissions");

            migrationBuilder.DropTable(
                name: "Payments");

            migrationBuilder.DropTable(
                name: "AppPermissions");

            migrationBuilder.DropTable(
                name: "Users");

            migrationBuilder.DropTable(
                name: "Patient");

            migrationBuilder.DropTable(
                name: "Subscriptions");

            migrationBuilder.DropTable(
                name: "Roles");

            migrationBuilder.DropTable(
                name: "Clinics");
        }
    }
}

========================================
File: ./NabdCare.Infrastructure/Migrations/NabdCareDbContextModelSnapshot.cs
========================================
Ôªø// <auto-generated />
using System;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
using NabdCare.Infrastructure.Persistence;
using Npgsql.EntityFrameworkCore.PostgreSQL.Metadata;

#nullable disable

namespace NabdCare.Infrastructure.Migrations
{
    [DbContext(typeof(NabdCareDbContext))]
    partial class NabdCareDbContextModelSnapshot : ModelSnapshot
    {
        protected override void BuildModel(ModelBuilder modelBuilder)
        {
#pragma warning disable 612, 618
            modelBuilder
                .HasAnnotation("ProductVersion", "8.0.20")
                .HasAnnotation("Relational:MaxIdentifierLength", 63);

            NpgsqlModelBuilderExtensions.UseIdentityByDefaultColumns(modelBuilder);

            modelBuilder.Entity("NabdCare.Domain.Entities.Audits.AuditLog", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<string>("Action")
                        .IsRequired()
                        .HasMaxLength(50)
                        .HasColumnType("character varying(50)");

                    b.Property<string>("Changes")
                        .HasColumnType("jsonb");

                    b.Property<Guid?>("ClinicId")
                        .HasColumnType("uuid");

                    b.Property<Guid?>("EntityId")
                        .HasColumnType("uuid");

                    b.Property<string>("EntityType")
                        .IsRequired()
                        .HasMaxLength(50)
                        .HasColumnType("character varying(50)");

                    b.Property<string>("IpAddress")
                        .HasMaxLength(45)
                        .HasColumnType("character varying(45)");

                    b.Property<string>("Reason")
                        .HasMaxLength(1000)
                        .HasColumnType("character varying(1000)");

                    b.Property<DateTime>("Timestamp")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("timestamp with time zone")
                        .HasDefaultValueSql("NOW()");

                    b.Property<string>("UserAgent")
                        .HasMaxLength(500)
                        .HasColumnType("character varying(500)");

                    b.Property<string>("UserEmail")
                        .IsRequired()
                        .HasMaxLength(100)
                        .HasColumnType("character varying(100)");

                    b.Property<Guid?>("UserId")
                        .HasColumnType("uuid");

                    b.HasKey("Id");

                    b.HasIndex("Action")
                        .HasDatabaseName("IX_AuditLogs_Action");

                    b.HasIndex("ClinicId")
                        .HasDatabaseName("IX_AuditLogs_ClinicId");

                    b.HasIndex("Timestamp")
                        .HasDatabaseName("IX_AuditLogs_Timestamp");

                    b.HasIndex("UserId")
                        .HasDatabaseName("IX_AuditLogs_UserId");

                    b.HasIndex("ClinicId", "Timestamp")
                        .HasDatabaseName("IX_AuditLogs_Clinic_Timestamp");

                    b.HasIndex("EntityType", "EntityId")
                        .HasDatabaseName("IX_AuditLogs_Entity");

                    b.ToTable("AuditLogs", (string)null);
                });

            modelBuilder.Entity("NabdCare.Domain.Entities.Clinics.Clinic", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<string>("Address")
                        .HasColumnType("text");

                    b.Property<int>("BranchCount")
                        .HasColumnType("integer");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("timestamp with time zone");

                    b.Property<string>("CreatedBy")
                        .HasColumnType("text");

                    b.Property<DateTime?>("DeletedAt")
                        .HasColumnType("timestamp with time zone");

                    b.Property<string>("DeletedBy")
                        .HasColumnType("text");

                    b.Property<string>("Email")
                        .HasMaxLength(100)
                        .HasColumnType("character varying(100)");

                    b.Property<bool>("IsDeleted")
                        .HasColumnType("boolean");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasMaxLength(255)
                        .HasColumnType("character varying(255)");

                    b.Property<string>("Phone")
                        .HasMaxLength(15)
                        .HasColumnType("character varying(15)");

                    b.Property<int>("Status")
                        .HasColumnType("integer");

                    b.Property<DateTime?>("UpdatedAt")
                        .HasColumnType("timestamp with time zone");

                    b.Property<string>("UpdatedBy")
                        .HasColumnType("text");

                    b.HasKey("Id");

                    b.HasIndex("Email");

                    b.HasIndex("Name");

                    b.ToTable("Clinics", (string)null);
                });

            modelBuilder.Entity("NabdCare.Domain.Entities.Clinics.Subscription", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<Guid>("ClinicId")
                        .HasColumnType("uuid");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("timestamp with time zone");

                    b.Property<string>("CreatedBy")
                        .HasColumnType("text");

                    b.Property<DateTime?>("DeletedAt")
                        .HasColumnType("timestamp with time zone");

                    b.Property<string>("DeletedBy")
                        .HasColumnType("text");

                    b.Property<DateTime>("EndDate")
                        .HasColumnType("timestamp with time zone");

                    b.Property<decimal>("Fee")
                        .HasPrecision(18, 2)
                        .HasColumnType("numeric(18,2)");

                    b.Property<bool>("IsDeleted")
                        .HasColumnType("boolean");

                    b.Property<DateTime>("StartDate")
                        .HasColumnType("timestamp with time zone");

                    b.Property<int>("Status")
                        .HasColumnType("integer");

                    b.Property<int>("Type")
                        .HasColumnType("integer");

                    b.Property<DateTime?>("UpdatedAt")
                        .HasColumnType("timestamp with time zone");

                    b.Property<string>("UpdatedBy")
                        .HasColumnType("text");

                    b.HasKey("Id");

                    b.HasIndex("ClinicId");

                    b.HasIndex("Status");

                    b.ToTable("Subscriptions", (string)null);
                });

            modelBuilder.Entity("NabdCare.Domain.Entities.Patients.Patient", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("timestamp with time zone");

                    b.Property<string>("CreatedBy")
                        .HasColumnType("text");

                    b.Property<DateTime?>("DeletedAt")
                        .HasColumnType("timestamp with time zone");

                    b.Property<string>("DeletedBy")
                        .HasColumnType("text");

                    b.Property<bool>("IsDeleted")
                        .HasColumnType("boolean");

                    b.Property<DateTime?>("UpdatedAt")
                        .HasColumnType("timestamp with time zone");

                    b.Property<string>("UpdatedBy")
                        .HasColumnType("text");

                    b.HasKey("Id");

                    b.ToTable("Patient");
                });

            modelBuilder.Entity("NabdCare.Domain.Entities.Payments.ChequePaymentDetail", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<decimal>("Amount")
                        .HasPrecision(18, 2)
                        .HasColumnType("numeric(18,2)");

                    b.Property<string>("BankName")
                        .IsRequired()
                        .HasMaxLength(100)
                        .HasColumnType("character varying(100)");

                    b.Property<string>("Branch")
                        .IsRequired()
                        .HasMaxLength(100)
                        .HasColumnType("character varying(100)");

                    b.Property<string>("ChequeNumber")
                        .IsRequired()
                        .HasMaxLength(50)
                        .HasColumnType("character varying(50)");

                    b.Property<DateTime?>("ClearedDate")
                        .HasColumnType("timestamp with time zone");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("timestamp with time zone");

                    b.Property<string>("CreatedBy")
                        .HasColumnType("text");

                    b.Property<DateTime?>("DeletedAt")
                        .HasColumnType("timestamp with time zone");

                    b.Property<string>("DeletedBy")
                        .HasColumnType("text");

                    b.Property<DateTime>("DueDate")
                        .HasColumnType("timestamp with time zone");

                    b.Property<bool>("IsDeleted")
                        .HasColumnType("boolean");

                    b.Property<DateTime>("IssueDate")
                        .HasColumnType("timestamp with time zone");

                    b.Property<Guid>("PaymentId")
                        .HasColumnType("uuid");

                    b.Property<int>("Status")
                        .HasColumnType("integer");

                    b.Property<DateTime?>("UpdatedAt")
                        .HasColumnType("timestamp with time zone");

                    b.Property<string>("UpdatedBy")
                        .HasColumnType("text");

                    b.HasKey("Id");

                    b.HasIndex("ChequeNumber")
                        .IsUnique();

                    b.HasIndex("PaymentId")
                        .IsUnique();

                    b.HasIndex("Status");

                    b.ToTable("ChequePaymentDetails", (string)null);
                });

            modelBuilder.Entity("NabdCare.Domain.Entities.Payments.Payment", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<decimal>("Amount")
                        .HasPrecision(18, 2)
                        .HasColumnType("numeric(18,2)");

                    b.Property<Guid?>("ClinicId")
                        .HasColumnType("uuid");

                    b.Property<int>("Context")
                        .HasColumnType("integer");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("timestamp with time zone");

                    b.Property<string>("CreatedBy")
                        .HasColumnType("text");

                    b.Property<DateTime?>("DeletedAt")
                        .HasColumnType("timestamp with time zone");

                    b.Property<string>("DeletedBy")
                        .HasColumnType("text");

                    b.Property<bool>("IsDeleted")
                        .HasColumnType("boolean");

                    b.Property<int>("Method")
                        .HasColumnType("integer");

                    b.Property<Guid?>("PatientId")
                        .HasColumnType("uuid");

                    b.Property<DateTime>("PaymentDate")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("timestamp with time zone")
                        .HasDefaultValueSql("NOW()");

                    b.Property<int>("Status")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("integer")
                        .HasDefaultValue(0);

                    b.Property<Guid?>("SubscriptionId")
                        .HasColumnType("uuid");

                    b.Property<DateTime?>("UpdatedAt")
                        .HasColumnType("timestamp with time zone");

                    b.Property<string>("UpdatedBy")
                        .HasColumnType("text");

                    b.HasKey("Id");

                    b.HasIndex("ClinicId");

                    b.HasIndex("PatientId");

                    b.HasIndex("PaymentDate");

                    b.HasIndex("SubscriptionId");

                    b.HasIndex("ClinicId", "PaymentDate");

                    b.HasIndex("PatientId", "PaymentDate");

                    b.HasIndex("Context", "ClinicId", "PatientId");

                    b.ToTable("Payments", t =>
                        {
                            t.HasCheckConstraint("CK_Payment_Context", "(\"Context\" = 0 AND \"ClinicId\" IS NOT NULL AND \"PatientId\" IS NULL) OR (\"Context\" = 1 AND \"PatientId\" IS NOT NULL AND \"ClinicId\" IS NULL)");
                        });
                });

            modelBuilder.Entity("NabdCare.Domain.Entities.Permissions.AppPermission", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("timestamp with time zone");

                    b.Property<string>("CreatedBy")
                        .HasColumnType("text");

                    b.Property<DateTime?>("DeletedAt")
                        .HasColumnType("timestamp with time zone");

                    b.Property<string>("DeletedBy")
                        .HasColumnType("text");

                    b.Property<string>("Description")
                        .HasMaxLength(500)
                        .HasColumnType("character varying(500)");

                    b.Property<bool>("IsDeleted")
                        .HasColumnType("boolean");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasMaxLength(100)
                        .HasColumnType("character varying(100)");

                    b.Property<DateTime?>("UpdatedAt")
                        .HasColumnType("timestamp with time zone");

                    b.Property<string>("UpdatedBy")
                        .HasColumnType("text");

                    b.HasKey("Id");

                    b.HasIndex("Name")
                        .IsUnique();

                    b.ToTable("AppPermissions", (string)null);
                });

            modelBuilder.Entity("NabdCare.Domain.Entities.Permissions.RefreshToken", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<DateTime>("CreatedAt")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("timestamp with time zone")
                        .HasDefaultValueSql("NOW()");

                    b.Property<string>("CreatedBy")
                        .HasColumnType("text");

                    b.Property<string>("CreatedByIp")
                        .HasColumnType("text");

                    b.Property<DateTime?>("DeletedAt")
                        .HasColumnType("timestamp with time zone");

                    b.Property<string>("DeletedBy")
                        .HasColumnType("text");

                    b.Property<DateTime>("ExpiresAt")
                        .HasColumnType("timestamp with time zone");

                    b.Property<bool>("IsDeleted")
                        .HasColumnType("boolean");

                    b.Property<bool>("IsRevoked")
                        .HasColumnType("boolean");

                    b.Property<string>("ReasonRevoked")
                        .HasColumnType("text");

                    b.Property<string>("ReplacedByToken")
                        .HasColumnType("text");

                    b.Property<DateTime?>("RevokedAt")
                        .HasColumnType("timestamp with time zone");

                    b.Property<string>("RevokedByIp")
                        .HasColumnType("text");

                    b.Property<string>("Token")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<DateTime?>("UpdatedAt")
                        .HasColumnType("timestamp with time zone");

                    b.Property<string>("UpdatedBy")
                        .HasColumnType("text");

                    b.Property<Guid>("UserId")
                        .HasColumnType("uuid");

                    b.HasKey("Id");

                    b.HasIndex("ExpiresAt");

                    b.HasIndex("Token")
                        .IsUnique();

                    b.HasIndex("UserId");

                    b.ToTable("RefreshTokens", (string)null);
                });

            modelBuilder.Entity("NabdCare.Domain.Entities.Permissions.Role", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<Guid?>("ClinicId")
                        .HasColumnType("uuid");

                    b.Property<string>("ColorCode")
                        .HasMaxLength(7)
                        .HasColumnType("character varying(7)");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("timestamp with time zone");

                    b.Property<string>("CreatedBy")
                        .HasColumnType("text");

                    b.Property<DateTime?>("DeletedAt")
                        .HasColumnType("timestamp with time zone");

                    b.Property<string>("DeletedBy")
                        .HasColumnType("text");

                    b.Property<string>("Description")
                        .HasMaxLength(500)
                        .HasColumnType("character varying(500)");

                    b.Property<int>("DisplayOrder")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("integer")
                        .HasDefaultValue(100);

                    b.Property<string>("IconClass")
                        .HasMaxLength(50)
                        .HasColumnType("character varying(50)");

                    b.Property<bool>("IsDeleted")
                        .HasColumnType("boolean");

                    b.Property<bool>("IsSystemRole")
                        .HasColumnType("boolean");

                    b.Property<bool>("IsTemplate")
                        .HasColumnType("boolean");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasMaxLength(100)
                        .HasColumnType("character varying(100)");

                    b.Property<Guid?>("TemplateRoleId")
                        .HasColumnType("uuid");

                    b.Property<DateTime?>("UpdatedAt")
                        .HasColumnType("timestamp with time zone");

                    b.Property<string>("UpdatedBy")
                        .HasColumnType("text");

                    b.HasKey("Id");

                    b.HasIndex("ClinicId")
                        .HasDatabaseName("IX_Roles_ClinicId");

                    b.HasIndex("DisplayOrder")
                        .HasDatabaseName("IX_Roles_DisplayOrder");

                    b.HasIndex("IsSystemRole")
                        .HasDatabaseName("IX_Roles_IsSystemRole");

                    b.HasIndex("IsTemplate")
                        .HasDatabaseName("IX_Roles_IsTemplate");

                    b.HasIndex("TemplateRoleId");

                    b.HasIndex("Name", "ClinicId")
                        .IsUnique()
                        .HasDatabaseName("IX_Roles_Name_ClinicId");

                    b.ToTable("Roles", (string)null);
                });

            modelBuilder.Entity("NabdCare.Domain.Entities.Permissions.RolePermission", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<Guid?>("AppPermissionId")
                        .HasColumnType("uuid");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("timestamp with time zone");

                    b.Property<string>("CreatedBy")
                        .HasColumnType("text");

                    b.Property<DateTime?>("DeletedAt")
                        .HasColumnType("timestamp with time zone");

                    b.Property<string>("DeletedBy")
                        .HasColumnType("text");

                    b.Property<bool>("IsDeleted")
                        .HasColumnType("boolean");

                    b.Property<Guid>("PermissionId")
                        .HasColumnType("uuid");

                    b.Property<Guid>("RoleId")
                        .HasColumnType("uuid");

                    b.Property<DateTime?>("UpdatedAt")
                        .HasColumnType("timestamp with time zone");

                    b.Property<string>("UpdatedBy")
                        .HasColumnType("text");

                    b.HasKey("Id");

                    b.HasIndex("AppPermissionId");

                    b.HasIndex("PermissionId");

                    b.HasIndex("RoleId", "PermissionId")
                        .IsUnique()
                        .HasDatabaseName("IX_RolePermissions_Role_Permission");

                    b.ToTable("RolePermissions", (string)null);
                });

            modelBuilder.Entity("NabdCare.Domain.Entities.Permissions.UserPermission", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<Guid?>("AppPermissionId")
                        .HasColumnType("uuid");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("timestamp with time zone");

                    b.Property<string>("CreatedBy")
                        .HasColumnType("text");

                    b.Property<DateTime?>("DeletedAt")
                        .HasColumnType("timestamp with time zone");

                    b.Property<string>("DeletedBy")
                        .HasColumnType("text");

                    b.Property<bool>("IsDeleted")
                        .HasColumnType("boolean");

                    b.Property<Guid>("PermissionId")
                        .HasColumnType("uuid");

                    b.Property<DateTime?>("UpdatedAt")
                        .HasColumnType("timestamp with time zone");

                    b.Property<string>("UpdatedBy")
                        .HasColumnType("text");

                    b.Property<Guid>("UserId")
                        .HasColumnType("uuid");

                    b.HasKey("Id");

                    b.HasIndex("AppPermissionId");

                    b.HasIndex("PermissionId");

                    b.HasIndex("UserId", "PermissionId")
                        .IsUnique();

                    b.ToTable("UserPermissions", (string)null);
                });

            modelBuilder.Entity("NabdCare.Domain.Entities.Users.User", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<Guid?>("ClinicId")
                        .HasColumnType("uuid");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("timestamp with time zone");

                    b.Property<string>("CreatedBy")
                        .HasColumnType("text");

                    b.Property<Guid?>("CreatedByUserId")
                        .HasColumnType("uuid");

                    b.Property<DateTime?>("DeletedAt")
                        .HasColumnType("timestamp with time zone");

                    b.Property<string>("DeletedBy")
                        .HasColumnType("text");

                    b.Property<string>("Email")
                        .IsRequired()
                        .HasMaxLength(100)
                        .HasColumnType("character varying(100)");

                    b.Property<string>("FullName")
                        .IsRequired()
                        .HasMaxLength(255)
                        .HasColumnType("character varying(255)");

                    b.Property<bool>("IsActive")
                        .HasColumnType("boolean");

                    b.Property<bool>("IsDeleted")
                        .HasColumnType("boolean");

                    b.Property<string>("PasswordHash")
                        .IsRequired()
                        .HasMaxLength(255)
                        .HasColumnType("character varying(255)");

                    b.Property<Guid>("RoleId")
                        .HasColumnType("uuid");

                    b.Property<DateTime?>("UpdatedAt")
                        .HasColumnType("timestamp with time zone");

                    b.Property<string>("UpdatedBy")
                        .HasColumnType("text");

                    b.HasKey("Id");

                    b.HasIndex("ClinicId");

                    b.HasIndex("CreatedByUserId");

                    b.HasIndex("Email")
                        .IsUnique();

                    b.HasIndex("FullName");

                    b.HasIndex("RoleId");

                    b.ToTable("Users", (string)null);
                });

            modelBuilder.Entity("NabdCare.Domain.Entities.Clinics.Subscription", b =>
                {
                    b.HasOne("NabdCare.Domain.Entities.Clinics.Clinic", "Clinic")
                        .WithMany("Subscriptions")
                        .HasForeignKey("ClinicId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("Clinic");
                });

            modelBuilder.Entity("NabdCare.Domain.Entities.Payments.ChequePaymentDetail", b =>
                {
                    b.HasOne("NabdCare.Domain.Entities.Payments.Payment", "Payment")
                        .WithOne("ChequeDetail")
                        .HasForeignKey("NabdCare.Domain.Entities.Payments.ChequePaymentDetail", "PaymentId")
                        .OnDelete(DeleteBehavior.Cascade);

                    b.Navigation("Payment");
                });

            modelBuilder.Entity("NabdCare.Domain.Entities.Payments.Payment", b =>
                {
                    b.HasOne("NabdCare.Domain.Entities.Clinics.Clinic", "Clinic")
                        .WithMany()
                        .HasForeignKey("ClinicId")
                        .OnDelete(DeleteBehavior.Restrict);

                    b.HasOne("NabdCare.Domain.Entities.Patients.Patient", "Patient")
                        .WithMany()
                        .HasForeignKey("PatientId")
                        .OnDelete(DeleteBehavior.Restrict);

                    b.HasOne("NabdCare.Domain.Entities.Clinics.Subscription", null)
                        .WithMany("Payments")
                        .HasForeignKey("SubscriptionId");

                    b.Navigation("Clinic");

                    b.Navigation("Patient");
                });

            modelBuilder.Entity("NabdCare.Domain.Entities.Permissions.Role", b =>
                {
                    b.HasOne("NabdCare.Domain.Entities.Clinics.Clinic", "Clinic")
                        .WithMany()
                        .HasForeignKey("ClinicId")
                        .OnDelete(DeleteBehavior.Restrict);

                    b.HasOne("NabdCare.Domain.Entities.Permissions.Role", "TemplateRole")
                        .WithMany()
                        .HasForeignKey("TemplateRoleId")
                        .OnDelete(DeleteBehavior.Restrict);

                    b.Navigation("Clinic");

                    b.Navigation("TemplateRole");
                });

            modelBuilder.Entity("NabdCare.Domain.Entities.Permissions.RolePermission", b =>
                {
                    b.HasOne("NabdCare.Domain.Entities.Permissions.AppPermission", null)
                        .WithMany("RolePermissions")
                        .HasForeignKey("AppPermissionId");

                    b.HasOne("NabdCare.Domain.Entities.Permissions.AppPermission", "AppPermission")
                        .WithMany()
                        .HasForeignKey("PermissionId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.HasOne("NabdCare.Domain.Entities.Permissions.Role", "Role")
                        .WithMany("RolePermissions")
                        .HasForeignKey("RoleId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("AppPermission");

                    b.Navigation("Role");
                });

            modelBuilder.Entity("NabdCare.Domain.Entities.Permissions.UserPermission", b =>
                {
                    b.HasOne("NabdCare.Domain.Entities.Permissions.AppPermission", null)
                        .WithMany("UserPermissions")
                        .HasForeignKey("AppPermissionId");

                    b.HasOne("NabdCare.Domain.Entities.Permissions.AppPermission", "AppPermission")
                        .WithMany()
                        .HasForeignKey("PermissionId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.HasOne("NabdCare.Domain.Entities.Users.User", "User")
                        .WithMany("Permissions")
                        .HasForeignKey("UserId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("AppPermission");

                    b.Navigation("User");
                });

            modelBuilder.Entity("NabdCare.Domain.Entities.Users.User", b =>
                {
                    b.HasOne("NabdCare.Domain.Entities.Clinics.Clinic", "Clinic")
                        .WithMany()
                        .HasForeignKey("ClinicId")
                        .OnDelete(DeleteBehavior.Restrict);

                    b.HasOne("NabdCare.Domain.Entities.Users.User", "CreatedByUser")
                        .WithMany()
                        .HasForeignKey("CreatedByUserId");

                    b.HasOne("NabdCare.Domain.Entities.Permissions.Role", "Role")
                        .WithMany("Users")
                        .HasForeignKey("RoleId")
                        .OnDelete(DeleteBehavior.Restrict)
                        .IsRequired();

                    b.Navigation("Clinic");

                    b.Navigation("CreatedByUser");

                    b.Navigation("Role");
                });

            modelBuilder.Entity("NabdCare.Domain.Entities.Clinics.Clinic", b =>
                {
                    b.Navigation("Subscriptions");
                });

            modelBuilder.Entity("NabdCare.Domain.Entities.Clinics.Subscription", b =>
                {
                    b.Navigation("Payments");
                });

            modelBuilder.Entity("NabdCare.Domain.Entities.Payments.Payment", b =>
                {
                    b.Navigation("ChequeDetail");
                });

            modelBuilder.Entity("NabdCare.Domain.Entities.Permissions.AppPermission", b =>
                {
                    b.Navigation("RolePermissions");

                    b.Navigation("UserPermissions");
                });

            modelBuilder.Entity("NabdCare.Domain.Entities.Permissions.Role", b =>
                {
                    b.Navigation("RolePermissions");

                    b.Navigation("Users");
                });

            modelBuilder.Entity("NabdCare.Domain.Entities.Users.User", b =>
                {
                    b.Navigation("Permissions");
                });
#pragma warning restore 612, 618
        }
    }
}

========================================
File: ./NabdCare.Infrastructure/Migrations/20251021195128_InitialDynamicRolesWithGroupedPermissions.Designer.cs
========================================
Ôªø// <auto-generated />
using System;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Migrations;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
using NabdCare.Infrastructure.Persistence;
using Npgsql.EntityFrameworkCore.PostgreSQL.Metadata;

#nullable disable

namespace NabdCare.Infrastructure.Migrations
{
    [DbContext(typeof(NabdCareDbContext))]
    [Migration("20251021195128_InitialDynamicRolesWithGroupedPermissions")]
    partial class InitialDynamicRolesWithGroupedPermissions
    {
        /// <inheritdoc />
        protected override void BuildTargetModel(ModelBuilder modelBuilder)
        {
#pragma warning disable 612, 618
            modelBuilder
                .HasAnnotation("ProductVersion", "8.0.20")
                .HasAnnotation("Relational:MaxIdentifierLength", 63);

            NpgsqlModelBuilderExtensions.UseIdentityByDefaultColumns(modelBuilder);

            modelBuilder.Entity("NabdCare.Domain.Entities.Audits.AuditLog", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<string>("Action")
                        .IsRequired()
                        .HasMaxLength(50)
                        .HasColumnType("character varying(50)");

                    b.Property<string>("Changes")
                        .HasColumnType("jsonb");

                    b.Property<Guid?>("ClinicId")
                        .HasColumnType("uuid");

                    b.Property<Guid?>("EntityId")
                        .HasColumnType("uuid");

                    b.Property<string>("EntityType")
                        .IsRequired()
                        .HasMaxLength(50)
                        .HasColumnType("character varying(50)");

                    b.Property<string>("IpAddress")
                        .HasMaxLength(45)
                        .HasColumnType("character varying(45)");

                    b.Property<string>("Reason")
                        .HasMaxLength(1000)
                        .HasColumnType("character varying(1000)");

                    b.Property<DateTime>("Timestamp")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("timestamp with time zone")
                        .HasDefaultValueSql("NOW()");

                    b.Property<string>("UserAgent")
                        .HasMaxLength(500)
                        .HasColumnType("character varying(500)");

                    b.Property<string>("UserEmail")
                        .IsRequired()
                        .HasMaxLength(100)
                        .HasColumnType("character varying(100)");

                    b.Property<Guid?>("UserId")
                        .HasColumnType("uuid");

                    b.HasKey("Id");

                    b.HasIndex("Action")
                        .HasDatabaseName("IX_AuditLogs_Action");

                    b.HasIndex("ClinicId")
                        .HasDatabaseName("IX_AuditLogs_ClinicId");

                    b.HasIndex("Timestamp")
                        .HasDatabaseName("IX_AuditLogs_Timestamp");

                    b.HasIndex("UserId")
                        .HasDatabaseName("IX_AuditLogs_UserId");

                    b.HasIndex("ClinicId", "Timestamp")
                        .HasDatabaseName("IX_AuditLogs_Clinic_Timestamp");

                    b.HasIndex("EntityType", "EntityId")
                        .HasDatabaseName("IX_AuditLogs_Entity");

                    b.ToTable("AuditLogs", (string)null);
                });

            modelBuilder.Entity("NabdCare.Domain.Entities.Clinics.Clinic", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<string>("Address")
                        .HasColumnType("text");

                    b.Property<int>("BranchCount")
                        .HasColumnType("integer");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("timestamp with time zone");

                    b.Property<string>("CreatedBy")
                        .HasColumnType("text");

                    b.Property<DateTime?>("DeletedAt")
                        .HasColumnType("timestamp with time zone");

                    b.Property<string>("DeletedBy")
                        .HasColumnType("text");

                    b.Property<string>("Email")
                        .HasMaxLength(100)
                        .HasColumnType("character varying(100)");

                    b.Property<bool>("IsDeleted")
                        .HasColumnType("boolean");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasMaxLength(255)
                        .HasColumnType("character varying(255)");

                    b.Property<string>("Phone")
                        .HasMaxLength(15)
                        .HasColumnType("character varying(15)");

                    b.Property<int>("Status")
                        .HasColumnType("integer");

                    b.Property<DateTime?>("UpdatedAt")
                        .HasColumnType("timestamp with time zone");

                    b.Property<string>("UpdatedBy")
                        .HasColumnType("text");

                    b.HasKey("Id");

                    b.HasIndex("Email");

                    b.HasIndex("Name");

                    b.ToTable("Clinics", (string)null);
                });

            modelBuilder.Entity("NabdCare.Domain.Entities.Clinics.Subscription", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<Guid>("ClinicId")
                        .HasColumnType("uuid");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("timestamp with time zone");

                    b.Property<string>("CreatedBy")
                        .HasColumnType("text");

                    b.Property<DateTime?>("DeletedAt")
                        .HasColumnType("timestamp with time zone");

                    b.Property<string>("DeletedBy")
                        .HasColumnType("text");

                    b.Property<DateTime>("EndDate")
                        .HasColumnType("timestamp with time zone");

                    b.Property<decimal>("Fee")
                        .HasPrecision(18, 2)
                        .HasColumnType("numeric(18,2)");

                    b.Property<bool>("IsDeleted")
                        .HasColumnType("boolean");

                    b.Property<DateTime>("StartDate")
                        .HasColumnType("timestamp with time zone");

                    b.Property<int>("Status")
                        .HasColumnType("integer");

                    b.Property<int>("Type")
                        .HasColumnType("integer");

                    b.Property<DateTime?>("UpdatedAt")
                        .HasColumnType("timestamp with time zone");

                    b.Property<string>("UpdatedBy")
                        .HasColumnType("text");

                    b.HasKey("Id");

                    b.HasIndex("ClinicId");

                    b.HasIndex("Status");

                    b.ToTable("Subscriptions", (string)null);
                });

            modelBuilder.Entity("NabdCare.Domain.Entities.Patients.Patient", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("timestamp with time zone");

                    b.Property<string>("CreatedBy")
                        .HasColumnType("text");

                    b.Property<DateTime?>("DeletedAt")
                        .HasColumnType("timestamp with time zone");

                    b.Property<string>("DeletedBy")
                        .HasColumnType("text");

                    b.Property<bool>("IsDeleted")
                        .HasColumnType("boolean");

                    b.Property<DateTime?>("UpdatedAt")
                        .HasColumnType("timestamp with time zone");

                    b.Property<string>("UpdatedBy")
                        .HasColumnType("text");

                    b.HasKey("Id");

                    b.ToTable("Patient");
                });

            modelBuilder.Entity("NabdCare.Domain.Entities.Payments.ChequePaymentDetail", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<decimal>("Amount")
                        .HasPrecision(18, 2)
                        .HasColumnType("numeric(18,2)");

                    b.Property<string>("BankName")
                        .IsRequired()
                        .HasMaxLength(100)
                        .HasColumnType("character varying(100)");

                    b.Property<string>("Branch")
                        .IsRequired()
                        .HasMaxLength(100)
                        .HasColumnType("character varying(100)");

                    b.Property<string>("ChequeNumber")
                        .IsRequired()
                        .HasMaxLength(50)
                        .HasColumnType("character varying(50)");

                    b.Property<DateTime?>("ClearedDate")
                        .HasColumnType("timestamp with time zone");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("timestamp with time zone");

                    b.Property<string>("CreatedBy")
                        .HasColumnType("text");

                    b.Property<DateTime?>("DeletedAt")
                        .HasColumnType("timestamp with time zone");

                    b.Property<string>("DeletedBy")
                        .HasColumnType("text");

                    b.Property<DateTime>("DueDate")
                        .HasColumnType("timestamp with time zone");

                    b.Property<bool>("IsDeleted")
                        .HasColumnType("boolean");

                    b.Property<DateTime>("IssueDate")
                        .HasColumnType("timestamp with time zone");

                    b.Property<Guid>("PaymentId")
                        .HasColumnType("uuid");

                    b.Property<int>("Status")
                        .HasColumnType("integer");

                    b.Property<DateTime?>("UpdatedAt")
                        .HasColumnType("timestamp with time zone");

                    b.Property<string>("UpdatedBy")
                        .HasColumnType("text");

                    b.HasKey("Id");

                    b.HasIndex("ChequeNumber")
                        .IsUnique();

                    b.HasIndex("PaymentId")
                        .IsUnique();

                    b.HasIndex("Status");

                    b.ToTable("ChequePaymentDetails", (string)null);
                });

            modelBuilder.Entity("NabdCare.Domain.Entities.Payments.Payment", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<decimal>("Amount")
                        .HasPrecision(18, 2)
                        .HasColumnType("numeric(18,2)");

                    b.Property<Guid?>("ClinicId")
                        .HasColumnType("uuid");

                    b.Property<int>("Context")
                        .HasColumnType("integer");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("timestamp with time zone");

                    b.Property<string>("CreatedBy")
                        .HasColumnType("text");

                    b.Property<DateTime?>("DeletedAt")
                        .HasColumnType("timestamp with time zone");

                    b.Property<string>("DeletedBy")
                        .HasColumnType("text");

                    b.Property<bool>("IsDeleted")
                        .HasColumnType("boolean");

                    b.Property<int>("Method")
                        .HasColumnType("integer");

                    b.Property<Guid?>("PatientId")
                        .HasColumnType("uuid");

                    b.Property<DateTime>("PaymentDate")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("timestamp with time zone")
                        .HasDefaultValueSql("NOW()");

                    b.Property<int>("Status")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("integer")
                        .HasDefaultValue(0);

                    b.Property<Guid?>("SubscriptionId")
                        .HasColumnType("uuid");

                    b.Property<DateTime?>("UpdatedAt")
                        .HasColumnType("timestamp with time zone");

                    b.Property<string>("UpdatedBy")
                        .HasColumnType("text");

                    b.HasKey("Id");

                    b.HasIndex("ClinicId");

                    b.HasIndex("PatientId");

                    b.HasIndex("PaymentDate");

                    b.HasIndex("SubscriptionId");

                    b.HasIndex("ClinicId", "PaymentDate");

                    b.HasIndex("PatientId", "PaymentDate");

                    b.HasIndex("Context", "ClinicId", "PatientId");

                    b.ToTable("Payments", t =>
                        {
                            t.HasCheckConstraint("CK_Payment_Context", "(\"Context\" = 0 AND \"ClinicId\" IS NOT NULL AND \"PatientId\" IS NULL) OR (\"Context\" = 1 AND \"PatientId\" IS NOT NULL AND \"ClinicId\" IS NULL)");
                        });
                });

            modelBuilder.Entity("NabdCare.Domain.Entities.Permissions.AppPermission", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("timestamp with time zone");

                    b.Property<string>("CreatedBy")
                        .HasColumnType("text");

                    b.Property<DateTime?>("DeletedAt")
                        .HasColumnType("timestamp with time zone");

                    b.Property<string>("DeletedBy")
                        .HasColumnType("text");

                    b.Property<string>("Description")
                        .HasMaxLength(500)
                        .HasColumnType("character varying(500)");

                    b.Property<bool>("IsDeleted")
                        .HasColumnType("boolean");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasMaxLength(100)
                        .HasColumnType("character varying(100)");

                    b.Property<DateTime?>("UpdatedAt")
                        .HasColumnType("timestamp with time zone");

                    b.Property<string>("UpdatedBy")
                        .HasColumnType("text");

                    b.HasKey("Id");

                    b.HasIndex("Name")
                        .IsUnique();

                    b.ToTable("AppPermissions", (string)null);
                });

            modelBuilder.Entity("NabdCare.Domain.Entities.Permissions.RefreshToken", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<DateTime>("CreatedAt")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("timestamp with time zone")
                        .HasDefaultValueSql("NOW()");

                    b.Property<string>("CreatedBy")
                        .HasColumnType("text");

                    b.Property<string>("CreatedByIp")
                        .HasColumnType("text");

                    b.Property<DateTime?>("DeletedAt")
                        .HasColumnType("timestamp with time zone");

                    b.Property<string>("DeletedBy")
                        .HasColumnType("text");

                    b.Property<DateTime>("ExpiresAt")
                        .HasColumnType("timestamp with time zone");

                    b.Property<bool>("IsDeleted")
                        .HasColumnType("boolean");

                    b.Property<bool>("IsRevoked")
                        .HasColumnType("boolean");

                    b.Property<string>("ReasonRevoked")
                        .HasColumnType("text");

                    b.Property<string>("ReplacedByToken")
                        .HasColumnType("text");

                    b.Property<DateTime?>("RevokedAt")
                        .HasColumnType("timestamp with time zone");

                    b.Property<string>("RevokedByIp")
                        .HasColumnType("text");

                    b.Property<string>("Token")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<DateTime?>("UpdatedAt")
                        .HasColumnType("timestamp with time zone");

                    b.Property<string>("UpdatedBy")
                        .HasColumnType("text");

                    b.Property<Guid>("UserId")
                        .HasColumnType("uuid");

                    b.HasKey("Id");

                    b.HasIndex("ExpiresAt");

                    b.HasIndex("Token")
                        .IsUnique();

                    b.HasIndex("UserId");

                    b.ToTable("RefreshTokens", (string)null);
                });

            modelBuilder.Entity("NabdCare.Domain.Entities.Permissions.Role", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<Guid?>("ClinicId")
                        .HasColumnType("uuid");

                    b.Property<string>("ColorCode")
                        .HasMaxLength(7)
                        .HasColumnType("character varying(7)");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("timestamp with time zone");

                    b.Property<string>("CreatedBy")
                        .HasColumnType("text");

                    b.Property<DateTime?>("DeletedAt")
                        .HasColumnType("timestamp with time zone");

                    b.Property<string>("DeletedBy")
                        .HasColumnType("text");

                    b.Property<string>("Description")
                        .HasMaxLength(500)
                        .HasColumnType("character varying(500)");

                    b.Property<int>("DisplayOrder")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("integer")
                        .HasDefaultValue(100);

                    b.Property<string>("IconClass")
                        .HasMaxLength(50)
                        .HasColumnType("character varying(50)");

                    b.Property<bool>("IsDeleted")
                        .HasColumnType("boolean");

                    b.Property<bool>("IsSystemRole")
                        .HasColumnType("boolean");

                    b.Property<bool>("IsTemplate")
                        .HasColumnType("boolean");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasMaxLength(100)
                        .HasColumnType("character varying(100)");

                    b.Property<Guid?>("TemplateRoleId")
                        .HasColumnType("uuid");

                    b.Property<DateTime?>("UpdatedAt")
                        .HasColumnType("timestamp with time zone");

                    b.Property<string>("UpdatedBy")
                        .HasColumnType("text");

                    b.HasKey("Id");

                    b.HasIndex("ClinicId")
                        .HasDatabaseName("IX_Roles_ClinicId");

                    b.HasIndex("DisplayOrder")
                        .HasDatabaseName("IX_Roles_DisplayOrder");

                    b.HasIndex("IsSystemRole")
                        .HasDatabaseName("IX_Roles_IsSystemRole");

                    b.HasIndex("IsTemplate")
                        .HasDatabaseName("IX_Roles_IsTemplate");

                    b.HasIndex("TemplateRoleId");

                    b.HasIndex("Name", "ClinicId")
                        .IsUnique()
                        .HasDatabaseName("IX_Roles_Name_ClinicId");

                    b.ToTable("Roles", (string)null);
                });

            modelBuilder.Entity("NabdCare.Domain.Entities.Permissions.RolePermission", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<Guid?>("AppPermissionId")
                        .HasColumnType("uuid");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("timestamp with time zone");

                    b.Property<string>("CreatedBy")
                        .HasColumnType("text");

                    b.Property<DateTime?>("DeletedAt")
                        .HasColumnType("timestamp with time zone");

                    b.Property<string>("DeletedBy")
                        .HasColumnType("text");

                    b.Property<bool>("IsDeleted")
                        .HasColumnType("boolean");

                    b.Property<Guid>("PermissionId")
                        .HasColumnType("uuid");

                    b.Property<Guid>("RoleId")
                        .HasColumnType("uuid");

                    b.Property<DateTime?>("UpdatedAt")
                        .HasColumnType("timestamp with time zone");

                    b.Property<string>("UpdatedBy")
                        .HasColumnType("text");

                    b.HasKey("Id");

                    b.HasIndex("AppPermissionId");

                    b.HasIndex("PermissionId");

                    b.HasIndex("RoleId", "PermissionId")
                        .IsUnique()
                        .HasDatabaseName("IX_RolePermissions_Role_Permission");

                    b.ToTable("RolePermissions", (string)null);
                });

            modelBuilder.Entity("NabdCare.Domain.Entities.Permissions.UserPermission", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<Guid?>("AppPermissionId")
                        .HasColumnType("uuid");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("timestamp with time zone");

                    b.Property<string>("CreatedBy")
                        .HasColumnType("text");

                    b.Property<DateTime?>("DeletedAt")
                        .HasColumnType("timestamp with time zone");

                    b.Property<string>("DeletedBy")
                        .HasColumnType("text");

                    b.Property<bool>("IsDeleted")
                        .HasColumnType("boolean");

                    b.Property<Guid>("PermissionId")
                        .HasColumnType("uuid");

                    b.Property<DateTime?>("UpdatedAt")
                        .HasColumnType("timestamp with time zone");

                    b.Property<string>("UpdatedBy")
                        .HasColumnType("text");

                    b.Property<Guid>("UserId")
                        .HasColumnType("uuid");

                    b.HasKey("Id");

                    b.HasIndex("AppPermissionId");

                    b.HasIndex("PermissionId");

                    b.HasIndex("UserId", "PermissionId")
                        .IsUnique();

                    b.ToTable("UserPermissions", (string)null);
                });

            modelBuilder.Entity("NabdCare.Domain.Entities.Users.User", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<Guid?>("ClinicId")
                        .HasColumnType("uuid");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("timestamp with time zone");

                    b.Property<string>("CreatedBy")
                        .HasColumnType("text");

                    b.Property<Guid?>("CreatedByUserId")
                        .HasColumnType("uuid");

                    b.Property<DateTime?>("DeletedAt")
                        .HasColumnType("timestamp with time zone");

                    b.Property<string>("DeletedBy")
                        .HasColumnType("text");

                    b.Property<string>("Email")
                        .IsRequired()
                        .HasMaxLength(100)
                        .HasColumnType("character varying(100)");

                    b.Property<string>("FullName")
                        .IsRequired()
                        .HasMaxLength(255)
                        .HasColumnType("character varying(255)");

                    b.Property<bool>("IsActive")
                        .HasColumnType("boolean");

                    b.Property<bool>("IsDeleted")
                        .HasColumnType("boolean");

                    b.Property<string>("PasswordHash")
                        .IsRequired()
                        .HasMaxLength(255)
                        .HasColumnType("character varying(255)");

                    b.Property<Guid>("RoleId")
                        .HasColumnType("uuid");

                    b.Property<DateTime?>("UpdatedAt")
                        .HasColumnType("timestamp with time zone");

                    b.Property<string>("UpdatedBy")
                        .HasColumnType("text");

                    b.HasKey("Id");

                    b.HasIndex("ClinicId");

                    b.HasIndex("CreatedByUserId");

                    b.HasIndex("Email")
                        .IsUnique();

                    b.HasIndex("FullName");

                    b.HasIndex("RoleId");

                    b.ToTable("Users", (string)null);
                });

            modelBuilder.Entity("NabdCare.Domain.Entities.Clinics.Subscription", b =>
                {
                    b.HasOne("NabdCare.Domain.Entities.Clinics.Clinic", "Clinic")
                        .WithMany("Subscriptions")
                        .HasForeignKey("ClinicId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("Clinic");
                });

            modelBuilder.Entity("NabdCare.Domain.Entities.Payments.ChequePaymentDetail", b =>
                {
                    b.HasOne("NabdCare.Domain.Entities.Payments.Payment", "Payment")
                        .WithOne("ChequeDetail")
                        .HasForeignKey("NabdCare.Domain.Entities.Payments.ChequePaymentDetail", "PaymentId")
                        .OnDelete(DeleteBehavior.Cascade);

                    b.Navigation("Payment");
                });

            modelBuilder.Entity("NabdCare.Domain.Entities.Payments.Payment", b =>
                {
                    b.HasOne("NabdCare.Domain.Entities.Clinics.Clinic", "Clinic")
                        .WithMany()
                        .HasForeignKey("ClinicId")
                        .OnDelete(DeleteBehavior.Restrict);

                    b.HasOne("NabdCare.Domain.Entities.Patients.Patient", "Patient")
                        .WithMany()
                        .HasForeignKey("PatientId")
                        .OnDelete(DeleteBehavior.Restrict);

                    b.HasOne("NabdCare.Domain.Entities.Clinics.Subscription", null)
                        .WithMany("Payments")
                        .HasForeignKey("SubscriptionId");

                    b.Navigation("Clinic");

                    b.Navigation("Patient");
                });

            modelBuilder.Entity("NabdCare.Domain.Entities.Permissions.Role", b =>
                {
                    b.HasOne("NabdCare.Domain.Entities.Clinics.Clinic", "Clinic")
                        .WithMany()
                        .HasForeignKey("ClinicId")
                        .OnDelete(DeleteBehavior.Restrict);

                    b.HasOne("NabdCare.Domain.Entities.Permissions.Role", "TemplateRole")
                        .WithMany()
                        .HasForeignKey("TemplateRoleId")
                        .OnDelete(DeleteBehavior.Restrict);

                    b.Navigation("Clinic");

                    b.Navigation("TemplateRole");
                });

            modelBuilder.Entity("NabdCare.Domain.Entities.Permissions.RolePermission", b =>
                {
                    b.HasOne("NabdCare.Domain.Entities.Permissions.AppPermission", null)
                        .WithMany("RolePermissions")
                        .HasForeignKey("AppPermissionId");

                    b.HasOne("NabdCare.Domain.Entities.Permissions.AppPermission", "AppPermission")
                        .WithMany()
                        .HasForeignKey("PermissionId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.HasOne("NabdCare.Domain.Entities.Permissions.Role", "Role")
                        .WithMany("RolePermissions")
                        .HasForeignKey("RoleId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("AppPermission");

                    b.Navigation("Role");
                });

            modelBuilder.Entity("NabdCare.Domain.Entities.Permissions.UserPermission", b =>
                {
                    b.HasOne("NabdCare.Domain.Entities.Permissions.AppPermission", null)
                        .WithMany("UserPermissions")
                        .HasForeignKey("AppPermissionId");

                    b.HasOne("NabdCare.Domain.Entities.Permissions.AppPermission", "AppPermission")
                        .WithMany()
                        .HasForeignKey("PermissionId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.HasOne("NabdCare.Domain.Entities.Users.User", "User")
                        .WithMany("Permissions")
                        .HasForeignKey("UserId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("AppPermission");

                    b.Navigation("User");
                });

            modelBuilder.Entity("NabdCare.Domain.Entities.Users.User", b =>
                {
                    b.HasOne("NabdCare.Domain.Entities.Clinics.Clinic", "Clinic")
                        .WithMany()
                        .HasForeignKey("ClinicId")
                        .OnDelete(DeleteBehavior.Restrict);

                    b.HasOne("NabdCare.Domain.Entities.Users.User", "CreatedByUser")
                        .WithMany()
                        .HasForeignKey("CreatedByUserId");

                    b.HasOne("NabdCare.Domain.Entities.Permissions.Role", "Role")
                        .WithMany("Users")
                        .HasForeignKey("RoleId")
                        .OnDelete(DeleteBehavior.Restrict)
                        .IsRequired();

                    b.Navigation("Clinic");

                    b.Navigation("CreatedByUser");

                    b.Navigation("Role");
                });

            modelBuilder.Entity("NabdCare.Domain.Entities.Clinics.Clinic", b =>
                {
                    b.Navigation("Subscriptions");
                });

            modelBuilder.Entity("NabdCare.Domain.Entities.Clinics.Subscription", b =>
                {
                    b.Navigation("Payments");
                });

            modelBuilder.Entity("NabdCare.Domain.Entities.Payments.Payment", b =>
                {
                    b.Navigation("ChequeDetail");
                });

            modelBuilder.Entity("NabdCare.Domain.Entities.Permissions.AppPermission", b =>
                {
                    b.Navigation("RolePermissions");

                    b.Navigation("UserPermissions");
                });

            modelBuilder.Entity("NabdCare.Domain.Entities.Permissions.Role", b =>
                {
                    b.Navigation("RolePermissions");

                    b.Navigation("Users");
                });

            modelBuilder.Entity("NabdCare.Domain.Entities.Users.User", b =>
                {
                    b.Navigation("Permissions");
                });
#pragma warning restore 612, 618
        }
    }
}

========================================
File: ./NabdCare.Infrastructure/Repositories/Payments/PaymentRepository.cs
========================================
Ôªøusing Microsoft.EntityFrameworkCore;
using NabdCare.Application.Interfaces.Payments;
using NabdCare.Domain.Entities.Payments;
using NabdCare.Infrastructure.Persistence;

namespace NabdCare.Infrastructure.Repositories.Payments;

public class PaymentRepository 
{

}

========================================
File: ./NabdCare.Infrastructure/Repositories/Auth/AuthRepository.cs
========================================
using Microsoft.EntityFrameworkCore;
using NabdCare.Application.Interfaces;
using NabdCare.Application.Interfaces.Auth;
using NabdCare.Domain.Entities.Permissions;
using NabdCare.Domain.Entities.Users;
using NabdCare.Infrastructure.Persistence;

namespace NabdCare.Infrastructure.Repositories.Auth;

public class AuthRepository : IAuthRepository
{
    private readonly NabdCareDbContext _dbContext;
    private readonly IPasswordService _passwordService;

    public AuthRepository(NabdCareDbContext dbContext, IPasswordService passwordService)
    {
        _dbContext = dbContext;
        _passwordService = passwordService;
    }

    public async Task<User?> AuthenticateUserAsync(string email, string password)
    {
        // Normalize the email
        email = email.Trim().ToLower();

        // ‚úÖ FIXED: Include Role when fetching user
        var user = await _dbContext.Users
            .Include(u => u.Role) // Load role relationship
            .IgnoreQueryFilters()
            .FirstOrDefaultAsync(u => u.Email.ToLower() == email);

        if (user == null)
            return null;

        // ‚úÖ FIXED: Allow SuperAdmin login even if inactive, otherwise require active
        if (!user.IsActive && user.Role.Name != "SuperAdmin")
            return null;

        // Validate password
        if (!_passwordService.VerifyPassword(user, password))
            return null;

        return user;
    }
    
    public async Task<User?> AuthenticateUserByIdAsync(Guid userId)
    {
        // ‚úÖ FIXED: Include Role when fetching user
        return await _dbContext.Users
            .Include(u => u.Role)
            .IgnoreQueryFilters()
            .FirstOrDefaultAsync(u => u.Id == userId && u.IsActive);
    }

    public async Task ChangePasswordAsync(User user, string newPassword)
    {
        user.PasswordHash = _passwordService.HashPassword(user, newPassword);
        _dbContext.Users.Update(user);
        await _dbContext.SaveChangesAsync();
    }

    public async Task SaveRefreshTokenAsync(User user, RefreshToken token)
    {
        token.UserId = user.Id;
        await _dbContext.RefreshTokens.AddAsync(token);
        await _dbContext.SaveChangesAsync();
    }

    public async Task<RefreshToken?> GetRefreshTokenAsync(string token)
    {
        return await _dbContext.RefreshTokens
            .FirstOrDefaultAsync(rt => rt.Token == token && !rt.IsRevoked && rt.ExpiresAt > DateTime.UtcNow);
    }

    public async Task<RefreshToken?> GetRefreshTokenIncludingRevokedAsync(string token)
    {
        return await _dbContext.RefreshTokens
            .FirstOrDefaultAsync(rt => rt.Token == token);
    }

    public async Task RevokeRefreshTokenAsync(string token, string revokedByIp, string reason)
    {
        var rt = await _dbContext.RefreshTokens
            .FirstOrDefaultAsync(rt2 => rt2.Token == token && !rt2.IsRevoked);

        if (rt != null)
        {
            rt.IsRevoked = true;
            rt.RevokedAt = DateTime.UtcNow;
            rt.RevokedByIp = revokedByIp;
            rt.ReasonRevoked = reason;

            _dbContext.RefreshTokens.Update(rt);
            await _dbContext.SaveChangesAsync();
        }
    }

    public async Task RevokeTokenFamilyAsync(RefreshToken token)
    {
        var toRevoke = await _dbContext.RefreshTokens
            .Where(rt =>
                rt.UserId == token.UserId &&
                (rt.Token == token.Token ||
                    rt.ReplacedByToken == token.Token ||
                    false
                ) &&
                !rt.IsRevoked)
            .ToListAsync();

        foreach (var rt in toRevoke)
        {
            rt.IsRevoked = true;
            rt.RevokedAt = DateTime.UtcNow;
            rt.RevokedByIp = token.RevokedByIp;
            rt.ReasonRevoked = "TokenFamilyRevoked";
        }

        _dbContext.RefreshTokens.UpdateRange(toRevoke);
        await _dbContext.SaveChangesAsync();
    }
    
    public async Task RevokeAllUserTokensAsync(Guid userId, string revokedByIp, string reason)
    {
        var tokens = await _dbContext.RefreshTokens
            .Where(rt => rt.UserId == userId && !rt.IsRevoked)
            .ToListAsync();

        foreach (var token in tokens)
        {
            token.IsRevoked = true;
            token.RevokedAt = DateTime.UtcNow;
            token.RevokedByIp = revokedByIp;
            token.ReasonRevoked = reason;
        }

        _dbContext.RefreshTokens.UpdateRange(tokens);
        await _dbContext.SaveChangesAsync();
    }
}
========================================
File: ./NabdCare.Infrastructure/Repositories/Auth/JwtTokenService.cs
========================================
using System.IdentityModel.Tokens.Jwt;
using System.Security.Claims;
using System.Security.Cryptography;
using System.Text;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.Logging;
using Microsoft.IdentityModel.Tokens;
using NabdCare.Application.Interfaces;

namespace NabdCare.Infrastructure.Repositories.Auth;

public class JwtTokenService : ITokenService
{
    private readonly IConfiguration _config;
    private readonly ILogger<JwtTokenService> _logger;

    public JwtTokenService(IConfiguration config, ILogger<JwtTokenService> logger)
    {
        _config = config;
        _logger = logger;
        
        // ‚úÖ Validate JWT configuration on startup
        ValidateConfiguration();
    }

    /// <summary>
    /// Generates a signed JWT access token with clean, frontend-friendly claims.
    /// </summary>
    public string GenerateToken(string userId, string email, string roleName, Guid roleId, Guid? clinicId, string fullName)
    {
        // Prefer env vars (for Docker/prod), fallback to appsettings.json
        var key = Environment.GetEnvironmentVariable("JWT_KEY")
                  ?? _config["Jwt:Key"]
                  ?? throw new InvalidOperationException("JWT Key not configured");

        var issuer = Environment.GetEnvironmentVariable("JWT_ISSUER")
                     ?? _config["Jwt:Issuer"]
                     ?? throw new InvalidOperationException("JWT Issuer not configured");

        var audience = Environment.GetEnvironmentVariable("JWT_AUDIENCE")
                       ?? _config["Jwt:Audience"]
                       ?? throw new InvalidOperationException("JWT Audience not configured");

        var expireMinutesStr = Environment.GetEnvironmentVariable("JWT_EXPIREMINUTES")
                               ?? _config["Jwt:ExpireMinutes"]
                               ?? "60";

        if (!double.TryParse(expireMinutesStr, out var expireMinutes))
            expireMinutes = 60;

        // ‚úÖ Clean claim names for frontend simplicity
        var claims = new List<Claim>
        {
            new(ClaimTypes.NameIdentifier, userId),
            new(ClaimTypes.Email, email),
            new(ClaimTypes.Name, fullName),
            new(ClaimTypes.Role, roleName),
            new("RoleId", roleId.ToString()),
        };

        // ‚úÖ Only add ClinicId if it has a value (cleaner JWT)
        if (clinicId.HasValue)
        {
            claims.Add(new Claim("ClinicId", clinicId.Value.ToString()));
        }

        // Signing key
        var signingKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(key));
        var creds = new SigningCredentials(signingKey, SecurityAlgorithms.HmacSha256);

        // Token
        var token = new JwtSecurityToken(
            issuer: issuer,
            audience: audience,
            claims: claims,
            notBefore: DateTime.UtcNow,
            expires: DateTime.UtcNow.AddMinutes(expireMinutes),
            signingCredentials: creds
        );

        return new JwtSecurityTokenHandler().WriteToken(token);
    }

    /// <summary>
    /// Generates a cryptographically secure random refresh token
    /// </summary>
    public string GenerateRefreshToken()
    {
        // ‚úÖ Generate 64 random bytes (512 bits) for maximum security
        var randomBytes = new byte[64];
        using var rng = RandomNumberGenerator.Create();
        rng.GetBytes(randomBytes);
        
        // Convert to Base64 string for storage
        return Convert.ToBase64String(randomBytes);
    }

    /// <summary>
    /// Validates JWT configuration on application startup
    /// </summary>
    private void ValidateConfiguration()
    {
        var key = Environment.GetEnvironmentVariable("JWT_KEY")
                  ?? _config["Jwt:Key"];

        if (string.IsNullOrWhiteSpace(key))
        {
            _logger.LogCritical("‚ùå JWT Key is not configured. Set JWT_KEY environment variable or Jwt:Key in appsettings.json");
            throw new InvalidOperationException("JWT Key not configured");
        }

        // Validate key strength
        if (key.Length < 32)
        {
            _logger.LogCritical("‚ùå JWT Key is too short ({Length} chars). Must be at least 32 characters (256 bits)", key.Length);
            throw new InvalidOperationException($"JWT Key must be at least 32 characters. Current length: {key.Length}");
        }

        // ‚úÖ Warn if using weak/example keys
        var weakKeyPatterns = new[] { "your-secret", "example", "test-key", "change-me", "secret", "password" };
        if (weakKeyPatterns.Any(pattern => key.Contains(pattern, StringComparison.OrdinalIgnoreCase)))
        {
            _logger.LogCritical("‚ùå JWT Key appears to contain weak/example patterns. Use a strong random key.");
            throw new InvalidOperationException("JWT Key appears to be weak or an example key");
        }

        // ‚úÖ Validate other required settings
        var issuer = Environment.GetEnvironmentVariable("JWT_ISSUER") ?? _config["Jwt:Issuer"];
        var audience = Environment.GetEnvironmentVariable("JWT_AUDIENCE") ?? _config["Jwt:Audience"];

        if (string.IsNullOrWhiteSpace(issuer))
        {
            _logger.LogCritical("‚ùå JWT Issuer is not configured");
            throw new InvalidOperationException("JWT Issuer not configured");
        }

        if (string.IsNullOrWhiteSpace(audience))
        {
            _logger.LogCritical("‚ùå JWT Audience is not configured");
            throw new InvalidOperationException("JWT Audience not configured");
        }

        _logger.LogInformation("‚úÖ JWT configuration validated successfully");
        _logger.LogInformation("   - Key length: {KeyLength} characters", key.Length);
        _logger.LogInformation("   - Issuer: {Issuer}", issuer);
        _logger.LogInformation("   - Audience: {Audience}", audience);
    }
}
========================================
File: ./NabdCare.Infrastructure/Repositories/Roles/RoleRepository.cs
========================================
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Logging;
using NabdCare.Application.Interfaces.Roles;
using NabdCare.Domain.Entities.Permissions;
using NabdCare.Infrastructure.Persistence;

namespace NabdCare.Infrastructure.Repositories.Roles;

public class RoleRepository : IRoleRepository
{
    private readonly NabdCareDbContext _dbContext;
    private readonly ILogger<RoleRepository> _logger;

    public RoleRepository(NabdCareDbContext dbContext, ILogger<RoleRepository> logger)
    {
        _dbContext = dbContext;
        _logger = logger;
    }

    #region QUERY METHODS

    public async Task<IEnumerable<Role>> GetAllRolesAsync()
    {
        return await _dbContext.Roles
            .Include(r => r.Clinic)
            .OrderBy(r => r.DisplayOrder)
            .ThenBy(r => r.Name)
            .ToListAsync();
    }

    public async Task<IEnumerable<Role>> GetSystemRolesAsync()
    {
        return await _dbContext.Roles
            .IgnoreQueryFilters() // System roles have no clinic
            .Where(r => r.IsSystemRole)
            .OrderBy(r => r.DisplayOrder)
            .ToListAsync();
    }

    public async Task<IEnumerable<Role>> GetTemplateRolesAsync()
    {
        return await _dbContext.Roles
            .IgnoreQueryFilters() // Templates have no clinic
            .Where(r => r.IsTemplate)
            .OrderBy(r => r.DisplayOrder)
            .ToListAsync();
    }

    public async Task<IEnumerable<Role>> GetClinicRolesAsync(Guid clinicId)
    {
        return await _dbContext.Roles
            .Where(r => r.ClinicId == clinicId)
            .Include(r => r.Clinic)
            .OrderBy(r => r.DisplayOrder)
            .ThenBy(r => r.Name)
            .ToListAsync();
    }

    public async Task<Role?> GetRoleByIdAsync(Guid id)
    {
        return await _dbContext.Roles
            .Include(r => r.Clinic)
            .FirstOrDefaultAsync(r => r.Id == id);
    }

    public async Task<Role?> GetRoleByNameAsync(string name, Guid? clinicId = null)
    {
        return await _dbContext.Roles
            .FirstOrDefaultAsync(r => r.Name == name && r.ClinicId == clinicId);
    }

    public async Task<int> GetRoleUserCountAsync(Guid roleId)
    {
        return await _dbContext.Users
            .IgnoreQueryFilters() // Count all users, even deleted
            .CountAsync(u => u.RoleId == roleId && !u.IsDeleted);
    }

    public async Task<int> GetRolePermissionCountAsync(Guid roleId)
    {
        return await _dbContext.RolePermissions
            .IgnoreQueryFilters()
            .CountAsync(rp => rp.RoleId == roleId && !rp.IsDeleted);
    }

    public async Task<bool> RoleExistsAsync(Guid id)
    {
        return await _dbContext.Roles.AnyAsync(r => r.Id == id);
    }

    public async Task<bool> RoleNameExistsAsync(string name, Guid? clinicId, Guid? excludeRoleId = null)
    {
        var query = _dbContext.Roles
            .Where(r => r.Name == name && r.ClinicId == clinicId);

        if (excludeRoleId.HasValue)
        {
            query = query.Where(r => r.Id != excludeRoleId.Value);
        }

        return await query.AnyAsync();
    }

    #endregion

    #region COMMAND METHODS

    public async Task<Role> CreateRoleAsync(Role role)
    {
        _dbContext.Roles.Add(role);
        await _dbContext.SaveChangesAsync();
        return role;
    }

    public async Task<Role?> UpdateRoleAsync(Role role)
    {
        _dbContext.Roles.Update(role);
        await _dbContext.SaveChangesAsync();
        return role;
    }

    public async Task<bool> DeleteRoleAsync(Guid id)
    {
        var role = await GetRoleByIdAsync(id);
        if (role == null)
            return false;

        _dbContext.Roles.Remove(role);
        await _dbContext.SaveChangesAsync();
        return true;
    }

    #endregion

    #region PERMISSION MANAGEMENT

    public async Task<IEnumerable<Guid>> GetRolePermissionIdsAsync(Guid roleId)
    {
        return await _dbContext.RolePermissions
            .IgnoreQueryFilters()
            .Where(rp => rp.RoleId == roleId && !rp.IsDeleted)
            .Select(rp => rp.PermissionId)
            .ToListAsync();
    }

    public async Task<bool> AssignPermissionToRoleAsync(Guid roleId, Guid permissionId)
    {
        // Check if already exists
        var exists = await _dbContext.RolePermissions
            .IgnoreQueryFilters()
            .AnyAsync(rp => rp.RoleId == roleId && rp.PermissionId == permissionId && !rp.IsDeleted);

        if (exists)
            return false;

        var rolePermission = new RolePermission
        {
            Id = Guid.NewGuid(),
            RoleId = roleId,
            PermissionId = permissionId,
            CreatedAt = DateTime.UtcNow,
            CreatedBy = "System",
            IsDeleted = false
        };

        _dbContext.RolePermissions.Add(rolePermission);
        await _dbContext.SaveChangesAsync();
        return true;
    }

    public async Task<bool> RemovePermissionFromRoleAsync(Guid roleId, Guid permissionId)
    {
        var rolePermission = await _dbContext.RolePermissions
            .IgnoreQueryFilters()
            .FirstOrDefaultAsync(rp => rp.RoleId == roleId && rp.PermissionId == permissionId && !rp.IsDeleted);

        if (rolePermission == null)
            return false;

        _dbContext.RolePermissions.Remove(rolePermission);
        await _dbContext.SaveChangesAsync();
        return true;
    }

    public async Task<int> BulkAssignPermissionsAsync(Guid roleId, IEnumerable<Guid> permissionIds)
    {
        var existingPermissionIds = await GetRolePermissionIdsAsync(roleId);
        var newPermissionIds = permissionIds.Except(existingPermissionIds).ToList();

        if (!newPermissionIds.Any())
            return 0;

        var rolePermissions = newPermissionIds.Select(permissionId => new RolePermission
        {
            Id = Guid.NewGuid(),
            RoleId = roleId,
            PermissionId = permissionId,
            CreatedAt = DateTime.UtcNow,
            CreatedBy = "System",
            IsDeleted = false
        }).ToList();

        _dbContext.RolePermissions.AddRange(rolePermissions);
        await _dbContext.SaveChangesAsync();

        return rolePermissions.Count;
    }

    public async Task<bool> SyncRolePermissionsAsync(Guid roleId, IEnumerable<Guid> permissionIds)
    {
        // Get existing permissions
        var existing = await _dbContext.RolePermissions
            .IgnoreQueryFilters()
            .Where(rp => rp.RoleId == roleId && !rp.IsDeleted)
            .ToListAsync();

        // Remove all existing
        _dbContext.RolePermissions.RemoveRange(existing);

        // Add new permissions
        var rolePermissions = permissionIds.Select(permissionId => new RolePermission
        {
            Id = Guid.NewGuid(),
            RoleId = roleId,
            PermissionId = permissionId,
            CreatedAt = DateTime.UtcNow,
            CreatedBy = "System",
            IsDeleted = false
        }).ToList();

        _dbContext.RolePermissions.AddRange(rolePermissions);
        await _dbContext.SaveChangesAsync();

        return true;
    }

    #endregion
}
========================================
File: ./NabdCare.Infrastructure/Repositories/Permissions/PermissionRepository.cs
========================================
Ôªøusing Microsoft.EntityFrameworkCore;
using NabdCare.Application.Interfaces.Permissions;
using NabdCare.Domain.Entities.Permissions;
using NabdCare.Infrastructure.Persistence;

namespace NabdCare.Infrastructure.Repositories.Permissions;

public class PermissionRepository : IPermissionRepository
{
    private readonly NabdCareDbContext _dbContext;

    public PermissionRepository(NabdCareDbContext dbContext)
    {
        _dbContext = dbContext;
    }

    #region CRUD

    public async Task<IEnumerable<AppPermission>> GetAllPermissionsAsync()
        => await _dbContext.AppPermissions.ToListAsync();

    public async Task<AppPermission?> GetPermissionByIdAsync(Guid permissionId)
        => await _dbContext.AppPermissions.FindAsync(permissionId);

    public async Task<AppPermission> CreatePermissionAsync(AppPermission appPermission)
    {
        await _dbContext.AppPermissions.AddAsync(appPermission);
        await _dbContext.SaveChangesAsync();
        return appPermission;
    }

    public async Task<AppPermission?> UpdatePermissionAsync(Guid permissionId, AppPermission appPermission)
    {
        var existing = await _dbContext.AppPermissions.FindAsync(permissionId);
        if (existing == null) return null;

        existing.Name = appPermission.Name;
        existing.Description = appPermission.Description;

        _dbContext.AppPermissions.Update(existing);
        await _dbContext.SaveChangesAsync();
        return existing;
    }

    public async Task<bool> DeletePermissionAsync(Guid permissionId)
    {
        var existing = await _dbContext.AppPermissions.FindAsync(permissionId);
        if (existing == null) return false;

        _dbContext.AppPermissions.Remove(existing);
        await _dbContext.SaveChangesAsync();
        return true;
    }

    #endregion

    #region Role Permissions

    public async Task<IEnumerable<AppPermission>> GetPermissionsByRoleAsync(Guid roleId)
    {
        return await _dbContext.RolePermissions
            .Include(rp => rp.AppPermission)
            .Where(rp => rp.RoleId == roleId)
            .Select(rp => rp.AppPermission)
            .ToListAsync();
    }

    public async Task<bool> AssignPermissionToRoleAsync(Guid roleId, Guid permissionId)
    {
        if (await _dbContext.RolePermissions.AnyAsync(rp => rp.RoleId == roleId && rp.PermissionId == permissionId))
            return false;

        _dbContext.RolePermissions.Add(new RolePermission
        {
            RoleId = roleId,
            PermissionId = permissionId
        });

        await _dbContext.SaveChangesAsync();
        return true;
    }

    public async Task<bool> RemovePermissionFromRoleAsync(Guid roleId, Guid permissionId)
    {
        var existing = await _dbContext.RolePermissions
            .FirstOrDefaultAsync(rp => rp.RoleId == roleId && rp.PermissionId == permissionId);

        if (existing == null) return false;

        _dbContext.RolePermissions.Remove(existing);
        await _dbContext.SaveChangesAsync();
        return true;
    }

    #endregion

    #region User Permissions

    public async Task<IEnumerable<AppPermission>> GetPermissionsByUserAsync(Guid userId)
    {
        return await _dbContext.UserPermissions
            .Include(up => up.AppPermission)
            .Where(up => up.UserId == userId)
            .Select(up => up.AppPermission)
            .ToListAsync();
    }

    public async Task<bool> AssignPermissionToUserAsync(Guid userId, Guid permissionId)
    {
        if (await _dbContext.UserPermissions.AnyAsync(up => up.UserId == userId && up.PermissionId == permissionId))
            return false;

        _dbContext.UserPermissions.Add(new UserPermission
        {
            UserId = userId,
            PermissionId = permissionId
        });

        await _dbContext.SaveChangesAsync();
        return true;
    }

    public async Task<bool> RemovePermissionFromUserAsync(Guid userId, Guid permissionId)
    {
        var existing = await _dbContext.UserPermissions
            .FirstOrDefaultAsync(up => up.UserId == userId && up.PermissionId == permissionId);

        if (existing == null) return false;

        _dbContext.UserPermissions.Remove(existing);
        await _dbContext.SaveChangesAsync();
        return true;
    }

    #endregion
}
========================================
File: ./NabdCare.Infrastructure/Repositories/Clinics/SubscriptionRepository.cs
========================================
Ôªøusing Microsoft.EntityFrameworkCore;
using NabdCare.Application.Interfaces.Clinics.Subscriptions;
using NabdCare.Domain.Entities.Clinics;
using NabdCare.Infrastructure.Persistence;

namespace NabdCare.Infrastructure.Repositories.Clinics;

public class SubscriptionRepository : ISubscriptionRepository
{
    private readonly NabdCareDbContext _db;

    public SubscriptionRepository(NabdCareDbContext db)
    {
        _db = db;
    }

    public async Task<Subscription?> GetByIdAsync(Guid id, bool includePayments = false)
    {
        IQueryable<Subscription> query = _db.Subscriptions;

        if (includePayments)
            query = query.Include(s => s.Payments);

        return await query.FirstOrDefaultAsync(s => s.Id == id);
    }

    public async Task<IEnumerable<Subscription>> GetByClinicIdAsync(Guid clinicId, bool includePayments = false)
    {
        IQueryable<Subscription> query = _db.Subscriptions
            .Where(s => s.ClinicId == clinicId)
            .OrderByDescending(s => s.StartDate);

        if (includePayments)
            query = query.Include(s => s.Payments);

        return await query.ToListAsync();
    }

    public async Task<IEnumerable<Subscription>> GetAllAsync(bool includePayments = false)
    {
        IQueryable<Subscription> query = _db.Subscriptions
            .OrderByDescending(s => s.StartDate);

        if (includePayments)
            query = query.Include(s => s.Payments);

        return await query.ToListAsync();
    }

    public async Task<IEnumerable<Subscription>> GetPagedAsync(int page, int pageSize, bool includePayments = false)
    {
        if (page <= 0) page = 1;
        if (pageSize <= 0) pageSize = 20;

        IQueryable<Subscription> query = _db.Subscriptions
            .OrderByDescending(s => s.StartDate)
            .Skip((page - 1) * pageSize)
            .Take(pageSize);

        if (includePayments)
            query = query.Include(s => s.Payments);

        return await query.ToListAsync();
    }

    public async Task<Subscription> CreateAsync(Subscription subscription)
    {
        await _db.Subscriptions.AddAsync(subscription);
        await _db.SaveChangesAsync();
        return subscription;
    }

    public async Task<Subscription> UpdateAsync(Subscription subscription)
    {
        _db.Subscriptions.Update(subscription);
        await _db.SaveChangesAsync();
        return subscription;
    }

    public async Task<bool> SoftDeleteAsync(Guid id)
    {
        var subscription = await _db.Subscriptions.FirstOrDefaultAsync(s => s.Id == id);
        if (subscription == null) return false;

        subscription.IsDeleted = true;
        _db.Subscriptions.Update(subscription);
        await _db.SaveChangesAsync();
        return true;
    }

    public async Task<bool> DeleteAsync(Guid id)
    {
        var subscription = await _db.Subscriptions.FirstOrDefaultAsync(s => s.Id == id);
        if (subscription == null) return false;

        _db.Subscriptions.Remove(subscription);
        await _db.SaveChangesAsync();
        return true;
    }
}

========================================
File: ./NabdCare.Infrastructure/Repositories/Clinics/ClinicRepository.cs
========================================
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Logging;
using NabdCare.Application.Interfaces.Clinics;
using NabdCare.Domain.Entities.Clinics;
using NabdCare.Domain.Enums;
using NabdCare.Infrastructure.Persistence;

namespace NabdCare.Infrastructure.Repositories.Clinics;

/// <summary>
/// Production-ready clinic repository.
/// Thin data access layer - no business logic, no try-catch.
/// </summary>
public class ClinicRepository : IClinicRepository
{
    private readonly NabdCareDbContext _dbContext;
    private readonly ILogger<ClinicRepository> _logger;

    public ClinicRepository(
        NabdCareDbContext dbContext,
        ILogger<ClinicRepository> logger)
    {
        _dbContext = dbContext ?? throw new ArgumentNullException(nameof(dbContext));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }

    #region QUERY METHODS

    public async Task<Clinic?> GetByIdAsync(Guid id)
    {
        if (id == Guid.Empty)
            return null;

        return await _dbContext.Clinics
            .Include(c => c.Subscriptions.Where(s => !s.IsDeleted))
            .AsNoTracking()
            .FirstOrDefaultAsync(c => c.Id == id && !c.IsDeleted);
    }

    public async Task<IEnumerable<Clinic>> GetAllAsync()
    {
        return await _dbContext.Clinics
            .Include(c => c.Subscriptions.Where(s => !s.IsDeleted))
            .Where(c => !c.IsDeleted)
            .OrderBy(c => c.Name)
            .AsNoTracking()
            .ToListAsync();
    }

    public async Task<IEnumerable<Clinic>> GetByStatusAsync(SubscriptionStatus status)
    {
        return await _dbContext.Clinics
            .Include(c => c.Subscriptions.Where(s => !s.IsDeleted))
            .Where(c => !c.IsDeleted && c.Status == status)
            .OrderBy(c => c.Name)
            .AsNoTracking()
            .ToListAsync();
    }

    public async Task<IEnumerable<Clinic>> GetActiveWithValidSubscriptionAsync()
    {
        var now = DateTime.UtcNow;

        return await _dbContext.Clinics
            .Include(c => c.Subscriptions.Where(s => !s.IsDeleted))
            .Where(c => !c.IsDeleted && 
                c.Status == SubscriptionStatus.Active &&
                c.Subscriptions.Any(s => 
                    !s.IsDeleted && 
                    s.Status == SubscriptionStatus.Active &&
                    s.EndDate > now))
            .OrderBy(c => c.Name)
            .AsNoTracking()
            .ToListAsync();
    }

    public async Task<IEnumerable<Clinic>> GetWithExpiringSubscriptionsAsync(int withinDays)
    {
        var now = DateTime.UtcNow;
        var expirationDate = now.AddDays(withinDays);

        return await _dbContext.Clinics
            .Include(c => c.Subscriptions.Where(s => !s.IsDeleted))
            .Where(c => !c.IsDeleted && 
                c.Status == SubscriptionStatus.Active &&
                c.Subscriptions.Any(s => 
                    !s.IsDeleted && 
                    s.Status == SubscriptionStatus.Active &&
                    s.EndDate > now && 
                    s.EndDate <= expirationDate))
            .OrderBy(c => c.Subscriptions
                .Where(s => !s.IsDeleted && s.Status == SubscriptionStatus.Active)
                .Min(s => s.EndDate))
            .AsNoTracking()
            .ToListAsync();
    }

    public async Task<IEnumerable<Clinic>> GetWithExpiredSubscriptionsAsync()
    {
        var now = DateTime.UtcNow;

        return await _dbContext.Clinics
            .Include(c => c.Subscriptions.Where(s => !s.IsDeleted))
            .Where(c => !c.IsDeleted && 
                c.Subscriptions.Any(s => 
                    !s.IsDeleted && 
                    s.Status == SubscriptionStatus.Active &&
                    s.EndDate <= now))
            .OrderBy(c => c.Name)
            .AsNoTracking()
            .ToListAsync();
    }

    public async Task<IEnumerable<Clinic>> GetPagedAsync(int page, int pageSize)
    {
        if (page < 1) page = 1;
        if (pageSize < 1) pageSize = 20;
        if (pageSize > 100) pageSize = 100;

        return await _dbContext.Clinics
            .Include(c => c.Subscriptions.Where(s => !s.IsDeleted))
            .Where(c => !c.IsDeleted)
            .OrderBy(c => c.Name)
            .Skip((page - 1) * pageSize)
            .Take(pageSize)
            .AsNoTracking()
            .ToListAsync();
    }

    public async Task<IEnumerable<Clinic>> SearchAsync(string query)
    {
        if (string.IsNullOrWhiteSpace(query))
            return Enumerable.Empty<Clinic>();

        var searchTerm = query.Trim().ToLower();

        return await _dbContext.Clinics
            .Include(c => c.Subscriptions.Where(s => !s.IsDeleted))
            .Where(c => !c.IsDeleted && 
                (c.Name.ToLower().Contains(searchTerm) ||
                 (c.Email != null && c.Email.ToLower().Contains(searchTerm)) ||
                 (c.Phone != null && c.Phone.Contains(searchTerm))))
            .OrderBy(c => c.Name)
            .AsNoTracking()
            .ToListAsync();
    }

    public async Task<bool> ExistsByNameAsync(string name, Guid? excludeId = null)
    {
        if (string.IsNullOrWhiteSpace(name))
            return false;

        var normalizedName = name.Trim().ToLower();

        var query = _dbContext.Clinics
            .Where(c => !c.IsDeleted && c.Name.ToLower() == normalizedName);

        if (excludeId.HasValue)
            query = query.Where(c => c.Id != excludeId.Value);

        return await query.AsNoTracking().AnyAsync();
    }

    public async Task<bool> ExistsByEmailAsync(string email, Guid? excludeId = null)
    {
        if (string.IsNullOrWhiteSpace(email))
            return false;

        var normalizedEmail = email.Trim().ToLower();

        var query = _dbContext.Clinics
            .Where(c => !c.IsDeleted && c.Email != null && c.Email.ToLower() == normalizedEmail);

        if (excludeId.HasValue)
            query = query.Where(c => c.Id != excludeId.Value);

        return await query.AsNoTracking().AnyAsync();
    }

    public async Task<bool> ExistsAsync(Guid id)
    {
        if (id == Guid.Empty)
            return false;

        return await _dbContext.Clinics
            .AsNoTracking()
            .AnyAsync(c => c.Id == id && !c.IsDeleted);
    }

    #endregion

    #region COMMAND METHODS

    public async Task<Clinic> CreateAsync(Clinic clinic)
    {
        if (clinic == null)
            throw new ArgumentNullException(nameof(clinic));

        await _dbContext.Clinics.AddAsync(clinic);
        await _dbContext.SaveChangesAsync();

        _logger.LogInformation("Clinic {ClinicId} created in database", clinic.Id);

        return clinic;
    }

    public async Task<Clinic> UpdateAsync(Clinic clinic)
    {
        if (clinic == null)
            throw new ArgumentNullException(nameof(clinic));

        _dbContext.Clinics.Update(clinic);
        await _dbContext.SaveChangesAsync();

        _logger.LogInformation("Clinic {ClinicId} updated in database", clinic.Id);

        return clinic;
    }

    public async Task<bool> SoftDeleteAsync(Guid id)
    {
        if (id == Guid.Empty)
            return false;

        var clinic = await _dbContext.Clinics
            .FirstOrDefaultAsync(c => c.Id == id && !c.IsDeleted);

        if (clinic == null)
            return false;

        clinic.IsDeleted = true;
        clinic.DeletedAt = DateTime.UtcNow;

        _dbContext.Clinics.Update(clinic);
        await _dbContext.SaveChangesAsync();

        _logger.LogInformation("Clinic {ClinicId} soft deleted in database", id);

        return true;
    }

    public async Task<bool> DeleteAsync(Guid id)
    {
        if (id == Guid.Empty)
            return false;

        var clinic = await _dbContext.Clinics.FirstOrDefaultAsync(c => c.Id == id);
        if (clinic == null)
            return false;

        _dbContext.Clinics.Remove(clinic);
        await _dbContext.SaveChangesAsync();

        _logger.LogWarning("Clinic {ClinicId} PERMANENTLY DELETED from database", id);

        return true;
    }

    #endregion

    #region STATISTICS

    public async Task<int> GetTotalCountAsync()
    {
        return await _dbContext.Clinics
            .AsNoTracking()
            .CountAsync(c => !c.IsDeleted);
    }

    public async Task<int> GetCountByStatusAsync(SubscriptionStatus status)
    {
        return await _dbContext.Clinics
            .AsNoTracking()
            .CountAsync(c => !c.IsDeleted && c.Status == status);
    }

    public async Task<int> GetActiveCountAsync()
    {
        var now = DateTime.UtcNow;

        return await _dbContext.Clinics
            .AsNoTracking()
            .CountAsync(c => !c.IsDeleted && 
                c.Status == SubscriptionStatus.Active &&
                c.Subscriptions.Any(s => 
                    !s.IsDeleted && 
                    s.Status == SubscriptionStatus.Active &&
                    s.EndDate > now));
    }

    #endregion
}
========================================
File: ./NabdCare.Infrastructure/Repositories/Users/UserRepository.cs
========================================
Ôªøusing Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Logging;
using NabdCare.Application.Interfaces.Users;
using NabdCare.Domain.Entities.Users;
using NabdCare.Infrastructure.Persistence;

namespace NabdCare.Infrastructure.Repositories.Users;

/// <summary>
/// Production-ready user repository - thin data access layer.
/// No try-catch: exceptions bubble up to service layer.
/// </summary>
public class UserRepository : IUserRepository
{
    private readonly NabdCareDbContext _dbContext;
    private readonly ILogger<UserRepository> _logger;

    public UserRepository(
        NabdCareDbContext dbContext,
        ILogger<UserRepository> logger)
    {
        _dbContext = dbContext ?? throw new ArgumentNullException(nameof(dbContext));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }

    #region QUERY METHODS

    public async Task<User?> GetByIdAsync(Guid userId)
    {
        if (userId == Guid.Empty)
            return null;

        return await _dbContext.Users
            .Include(u => u.Clinic)
            .Include(u => u.Role)
            .AsNoTracking()
            .FirstOrDefaultAsync(u => u.Id == userId && !u.IsDeleted);
    }

    public async Task<User?> GetByEmailAsync(string email)
    {
        if (string.IsNullOrWhiteSpace(email))
            return null;

        var normalizedEmail = email.Trim().ToLower();

        return await _dbContext.Users
            .Include(u => u.Clinic)
            .Include(u => u.Role)
            .AsNoTracking()
            .FirstOrDefaultAsync(u => u.Email == normalizedEmail && !u.IsDeleted);
    }

    public async Task<IEnumerable<User>> GetAllAsync()
    {
        return await _dbContext.Users
            .Include(u => u.Clinic)
            .Include(u => u.Role)
            .Where(u => !u.IsDeleted)
            .OrderBy(u => u.FullName)
            .AsNoTracking()
            .ToListAsync();
    }

    public async Task<IEnumerable<User>> GetByClinicIdAsync(Guid clinicId)
    {
        if (clinicId == Guid.Empty)
            return Enumerable.Empty<User>();

        return await _dbContext.Users
            .Include(u => u.Clinic)
            .Include(u => u.Role)
            .Where(u => u.ClinicId == clinicId && !u.IsDeleted)
            .OrderBy(u => u.FullName)
            .AsNoTracking()
            .ToListAsync();
    }

    public async Task<bool> EmailExistsAsync(string email)
    {
        if (string.IsNullOrWhiteSpace(email))
            return false;

        var normalizedEmail = email.Trim().ToLower();

        return await _dbContext.Users
            .AsNoTracking()
            .AnyAsync(u => u.Email == normalizedEmail && !u.IsDeleted);
    }

    public async Task<bool> ExistsAsync(Guid userId)
    {
        if (userId == Guid.Empty)
            return false;

        return await _dbContext.Users
            .AsNoTracking()
            .AnyAsync(u => u.Id == userId && !u.IsDeleted);
    }

    #endregion

    #region COMMAND METHODS

    public async Task<User> CreateAsync(User user)
    {
        if (user == null)
            throw new ArgumentNullException(nameof(user));

        // Normalize email
        user.Email = user.Email.Trim().ToLower();

        await _dbContext.Users.AddAsync(user);
        await _dbContext.SaveChangesAsync();

        _logger.LogInformation("User {UserId} created in database", user.Id);

        return user;
    }

    public async Task<User> UpdateAsync(User user)
    {
        if (user == null)
            throw new ArgumentNullException(nameof(user));

        // Normalize email if changed
        if (!string.IsNullOrWhiteSpace(user.Email))
            user.Email = user.Email.Trim().ToLower();

        _dbContext.Users.Update(user);
        await _dbContext.SaveChangesAsync();

        _logger.LogInformation("User {UserId} updated in database", user.Id);

        return user;
    }

    public async Task<bool> SoftDeleteAsync(Guid userId)
    {
        if (userId == Guid.Empty)
            return false;

        var user = await _dbContext.Users
            .FirstOrDefaultAsync(u => u.Id == userId && !u.IsDeleted);

        if (user == null)
            return false;

        user.IsDeleted = true;
        user.DeletedAt = DateTime.UtcNow;

        _dbContext.Users.Update(user);
        await _dbContext.SaveChangesAsync();

        _logger.LogInformation("User {UserId} soft deleted in database", userId);

        return true;
    }

    public async Task<bool> DeleteAsync(Guid userId)
    {
        if (userId == Guid.Empty)
            return false;

        var user = await _dbContext.Users.FirstOrDefaultAsync(u => u.Id == userId);
        if (user == null)
            return false;

        _dbContext.Users.Remove(user);
        await _dbContext.SaveChangesAsync();

        _logger.LogWarning("User {UserId} PERMANENTLY DELETED from database", userId);

        return true;
    }

    #endregion
}
========================================
File: ./NabdCare.Infrastructure/Persistence/Configurations/UserPermissionConfiguration.cs
========================================
Ôªøusing Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;
using NabdCare.Domain.Entities.Permissions;

namespace NabdCare.Infrastructure.Persistence.Configurations;

public class UserPermissionConfiguration : IEntityTypeConfiguration<UserPermission>
{
    public void Configure(EntityTypeBuilder<UserPermission> builder)
    {
        builder.ToTable("UserPermissions");

        builder.HasKey(up => up.Id);

        builder.HasOne(up => up.User)
            .WithMany(u => u.Permissions)
            .HasForeignKey(up => up.UserId)
            .OnDelete(DeleteBehavior.Cascade);

        builder.HasOne(up => up.AppPermission)
            .WithMany()
            .HasForeignKey(up => up.PermissionId)
            .OnDelete(DeleteBehavior.Cascade);

        // Indexes
        builder.HasIndex(up => new { up.UserId, up.PermissionId }).IsUnique();
    }
}
========================================
File: ./NabdCare.Infrastructure/Persistence/Configurations/AuditLogConfiguration.cs
========================================
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;
using NabdCare.Domain.Entities.Audits;

namespace NabdCare.Infrastructure.Persistence.Configurations;

public class AuditLogConfiguration : IEntityTypeConfiguration<AuditLog>
{
    public void Configure(EntityTypeBuilder<AuditLog> builder)
    {
        builder.ToTable("AuditLogs");

        builder.HasKey(a => a.Id);

        // Properties
        builder.Property(a => a.UserEmail)
            .IsRequired()
            .HasMaxLength(100);

        builder.Property(a => a.EntityType)
            .IsRequired()
            .HasMaxLength(50);

        builder.Property(a => a.Action)
            .IsRequired()
            .HasMaxLength(50);

        builder.Property(a => a.Timestamp)
            .IsRequired()
            .HasDefaultValueSql("NOW()");

        builder.Property(a => a.Changes)
            .HasColumnType("jsonb"); // PostgreSQL JSONB

        builder.Property(a => a.Reason)
            .HasMaxLength(1000);

        builder.Property(a => a.IpAddress)
            .HasMaxLength(45);

        builder.Property(a => a.UserAgent)
            .HasMaxLength(500);

        // Indexes for common queries
        builder.HasIndex(a => a.UserId)
            .HasDatabaseName("IX_AuditLogs_UserId");

        builder.HasIndex(a => a.ClinicId)
            .HasDatabaseName("IX_AuditLogs_ClinicId");

        builder.HasIndex(a => new { a.EntityType, a.EntityId })
            .HasDatabaseName("IX_AuditLogs_Entity");

        builder.HasIndex(a => a.Timestamp)
            .HasDatabaseName("IX_AuditLogs_Timestamp");

        builder.HasIndex(a => new { a.ClinicId, a.Timestamp })
            .HasDatabaseName("IX_AuditLogs_Clinic_Timestamp");

        builder.HasIndex(a => a.Action)
            .HasDatabaseName("IX_AuditLogs_Action");
    }
}
========================================
File: ./NabdCare.Infrastructure/Persistence/Configurations/RoleConfiguration.cs
========================================
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;
using NabdCare.Domain.Entities.Permissions;

namespace NabdCare.Infrastructure.Persistence.Configurations;

public class RoleConfiguration : IEntityTypeConfiguration<Role>
{
    public void Configure(EntityTypeBuilder<Role> builder)
    {
        builder.ToTable("Roles");

        builder.HasKey(r => r.Id);

        // Properties
        builder.Property(r => r.Name)
            .IsRequired()
            .HasMaxLength(100);

        builder.Property(r => r.Description)
            .HasMaxLength(500);

        builder.Property(r => r.ColorCode)
            .HasMaxLength(7);

        builder.Property(r => r.IconClass)
            .HasMaxLength(50);

        builder.Property(r => r.DisplayOrder)
            .HasDefaultValue(100);

        // Relationships
        builder.HasOne(r => r.Clinic)
            .WithMany()
            .HasForeignKey(r => r.ClinicId)
            .OnDelete(DeleteBehavior.Restrict);

        builder.HasOne(r => r.TemplateRole)
            .WithMany()
            .HasForeignKey(r => r.TemplateRoleId)
            .OnDelete(DeleteBehavior.Restrict);

        builder.HasMany(r => r.RolePermissions)
            .WithOne(rp => rp.Role)
            .HasForeignKey(rp => rp.RoleId)
            .OnDelete(DeleteBehavior.Cascade);

        builder.HasMany(r => r.Users)
            .WithOne(u => u.Role)
            .HasForeignKey(u => u.RoleId)
            .OnDelete(DeleteBehavior.Restrict); // Cannot delete role with assigned users

        // Indexes
        // Unique constraint: Role name must be unique per clinic
        // System roles (ClinicId = NULL) must have unique names globally
        builder.HasIndex(r => new { r.Name, r.ClinicId })
            .IsUnique()
            .HasDatabaseName("IX_Roles_Name_ClinicId");

        builder.HasIndex(r => r.ClinicId)
            .HasDatabaseName("IX_Roles_ClinicId");

        builder.HasIndex(r => r.IsSystemRole)
            .HasDatabaseName("IX_Roles_IsSystemRole");

        builder.HasIndex(r => r.IsTemplate)
            .HasDatabaseName("IX_Roles_IsTemplate");

        builder.HasIndex(r => r.DisplayOrder)
            .HasDatabaseName("IX_Roles_DisplayOrder");
    }
}
========================================
File: ./NabdCare.Infrastructure/Persistence/Configurations/RefreshTokenConfiguration.cs
========================================
Ôªøusing Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;
using NabdCare.Domain.Entities.Permissions;

namespace NabdCare.Infrastructure.Persistence.Configurations;

public class RefreshTokenConfiguration : IEntityTypeConfiguration<RefreshToken>
{
    public void Configure(EntityTypeBuilder<RefreshToken> builder)
    {
        builder.ToTable("RefreshTokens");

        builder.HasKey(rt => rt.Id);

        builder.Property(rt => rt.Token)
            .IsRequired();

        builder.Property(rt => rt.CreatedAt)
            .HasDefaultValueSql("NOW()")
            .ValueGeneratedOnAdd();

        builder.HasIndex(rt => rt.Token).IsUnique();
        builder.HasIndex(rt => rt.UserId);
        builder.HasIndex(rt => rt.ExpiresAt);
    }
}
========================================
File: ./NabdCare.Infrastructure/Persistence/Configurations/SubscriptionConfiguration.cs
========================================
Ôªøusing Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;
using NabdCare.Domain.Entities.Clinics;

namespace NabdCare.Infrastructure.Persistence.Configurations;

public class SubscriptionConfiguration : IEntityTypeConfiguration<Subscription>
{
    public void Configure(EntityTypeBuilder<Subscription> builder)
    {
        builder.ToTable("Subscriptions");

        builder.HasKey(s => s.Id);

        builder.Property(s => s.StartDate).IsRequired();
        builder.Property(s => s.EndDate).IsRequired();

        builder.Property(s => s.Fee)
            .IsRequired()
            .HasPrecision(18, 2);

        builder.Property(s => s.Type)
            .IsRequired();

        builder.Property(s => s.Status)
            .IsRequired();

        // Clinic relationship
        builder.HasOne(s => s.Clinic)
            .WithMany(c => c.Subscriptions)
            .HasForeignKey(s => s.ClinicId)
            .OnDelete(DeleteBehavior.Cascade);

        // Indexes
        builder.HasIndex(s => s.ClinicId);
        builder.HasIndex(s => s.Status);
    }
}
========================================
File: ./NabdCare.Infrastructure/Persistence/Configurations/RolePermissionConfiguration.cs
========================================
Ôªøusing Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;
using NabdCare.Domain.Entities.Permissions;

namespace NabdCare.Infrastructure.Persistence.Configurations;

public class RolePermissionConfiguration : IEntityTypeConfiguration<RolePermission>
{
    public void Configure(EntityTypeBuilder<RolePermission> builder)
    {
        builder.ToTable("RolePermissions");

        builder.HasKey(rp => rp.Id);

        // ‚ö†Ô∏è CHANGED: Relationship to Role entity instead of enum
        builder.HasOne(rp => rp.Role)
            .WithMany(r => r.RolePermissions)
            .HasForeignKey(rp => rp.RoleId)
            .OnDelete(DeleteBehavior.Cascade);

        builder.HasOne(rp => rp.AppPermission)
            .WithMany()
            .HasForeignKey(rp => rp.PermissionId)
            .OnDelete(DeleteBehavior.Cascade);

        // Indexes - Prevent duplicate permission assignments
        builder.HasIndex(rp => new { rp.RoleId, rp.PermissionId })
            .IsUnique()
            .HasDatabaseName("IX_RolePermissions_Role_Permission");
    }
}
========================================
File: ./NabdCare.Infrastructure/Persistence/Configurations/ClinicConfiguration.cs
========================================
Ôªøusing Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;
using NabdCare.Domain.Entities.Clinics;

namespace NabdCare.Infrastructure.Persistence.Configurations;

public class ClinicConfiguration : IEntityTypeConfiguration<Clinic>
{
    public void Configure(EntityTypeBuilder<Clinic> builder)
    {
        builder.ToTable("Clinics");

        builder.HasKey(c => c.Id);

        builder.Property(c => c.Name)
            .IsRequired()
            .HasMaxLength(255);

        builder.Property(c => c.Email)
            .HasMaxLength(100);

        builder.Property(c => c.Phone)
            .HasMaxLength(15);

        // Indexes
        builder.HasIndex(c => c.Email).IsUnique(false);
        builder.HasIndex(c => c.Name);
    }
}
========================================
File: ./NabdCare.Infrastructure/Persistence/Configurations/ChequePaymentDetailConfiguration.cs
========================================
Ôªøusing Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;
using NabdCare.Domain.Entities.Payments;

namespace NabdCare.Infrastructure.Persistence.Configurations;

public class ChequePaymentDetailConfiguration : IEntityTypeConfiguration<ChequePaymentDetail>
{
    public void Configure(EntityTypeBuilder<ChequePaymentDetail> builder)
    {
        builder.ToTable("ChequePaymentDetails");

        builder.HasKey(cd => cd.Id);

        builder.Property(cd => cd.ChequeNumber)
            .IsRequired()
            .HasMaxLength(50);

        builder.Property(cd => cd.BankName)
            .IsRequired()
            .HasMaxLength(100);

        builder.Property(cd => cd.Branch)
            .HasMaxLength(100);

        builder.Property(cd => cd.Amount)
            .HasPrecision(18, 2);

        builder.HasOne(cd => cd.Payment)
            .WithOne(p => p.ChequeDetail)
            .HasForeignKey<ChequePaymentDetail>(cd => cd.PaymentId)
            .OnDelete(DeleteBehavior.Cascade)
            .IsRequired(false);

        // Indexes
        builder.HasIndex(cd => cd.ChequeNumber).IsUnique();
        builder.HasIndex(cd => cd.Status);
    }
}
========================================
File: ./NabdCare.Infrastructure/Persistence/Configurations/PaymentConfiguration.cs
========================================
Ôªøusing Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;
using NabdCare.Domain.Entities.Payments;
using NabdCare.Domain.Enums;

namespace NabdCare.Infrastructure.Persistence.Configurations;

public class PaymentConfiguration : IEntityTypeConfiguration<Payment>
{
    public void Configure(EntityTypeBuilder<Payment> builder)
    {
        // Use the table builder for the check constraint (non-obsolete)
        builder.ToTable(tb =>
        {
            tb.HasCheckConstraint("CK_Payment_Context",
                "(\"Context\" = 0 AND \"ClinicId\" IS NOT NULL AND \"PatientId\" IS NULL) OR " +
                "(\"Context\" = 1 AND \"PatientId\" IS NOT NULL AND \"ClinicId\" IS NULL)"
            );
        });

        builder.HasKey(p => p.Id);

        builder.Property(p => p.Amount)
            .IsRequired()
            .HasPrecision(18, 2);

        builder.Property(p => p.PaymentDate)
            .IsRequired()
            .HasDefaultValueSql("NOW()");

        builder.Property(p => p.Context)
            .IsRequired();

        builder.Property(p => p.Method)
            .IsRequired();

        builder.Property(p => p.Status)
            .IsRequired()
            .HasDefaultValue(PaymentStatus.Pending);

        // Relations
        builder.HasOne(p => p.Clinic)
            .WithMany()
            .HasForeignKey(p => p.ClinicId)
            .OnDelete(DeleteBehavior.Restrict);

        builder.HasOne(p => p.Patient)
            .WithMany()
            .HasForeignKey(p => p.PatientId)
            .OnDelete(DeleteBehavior.Restrict);

        builder.HasOne(p => p.ChequeDetail)
            .WithOne(cd => cd.Payment)
            .HasForeignKey<ChequePaymentDetail>(cd => cd.PaymentId)
            .OnDelete(DeleteBehavior.Cascade);

        // Indexes for frequent queries
        builder.HasIndex(p => new { p.Context, p.ClinicId, p.PatientId });
        builder.HasIndex(p => new { p.ClinicId, p.PaymentDate });
        builder.HasIndex(p => new { p.PatientId, p.PaymentDate });
        builder.HasIndex(p => p.PaymentDate);
        builder.HasIndex(p => p.ClinicId);
        builder.HasIndex(p => p.PatientId);
    }
}

========================================
File: ./NabdCare.Infrastructure/Persistence/Configurations/UserConfiguration.cs
========================================
Ôªøusing Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;
using NabdCare.Domain.Entities.Users;

namespace NabdCare.Infrastructure.Persistence.Configurations;

public class UserConfiguration : IEntityTypeConfiguration<User>
{
    public void Configure(EntityTypeBuilder<User> builder)
    {
        builder.ToTable("Users");

        builder.HasKey(u => u.Id);

        builder.Property(u => u.Email)
            .IsRequired()
            .HasMaxLength(100);

        builder.Property(u => u.FullName)
            .IsRequired()
            .HasMaxLength(255);

        builder.Property(u => u.PasswordHash)
            .IsRequired()
            .HasMaxLength(255);

        // Relations
        builder.HasOne(u => u.Clinic)
            .WithMany()
            .HasForeignKey(u => u.ClinicId)
            .OnDelete(DeleteBehavior.Restrict);

        // ‚ö†Ô∏è NEW: Role relationship
        builder.HasOne(u => u.Role)
            .WithMany(r => r.Users)
            .HasForeignKey(u => u.RoleId)
            .OnDelete(DeleteBehavior.Restrict); // Cannot delete role with assigned users

        builder.HasMany(u => u.Permissions)
            .WithOne(up => up.User)
            .HasForeignKey(up => up.UserId)
            .OnDelete(DeleteBehavior.Cascade);

        // Indexes
        builder.HasIndex(u => u.Email).IsUnique();
        builder.HasIndex(u => u.FullName);
        builder.HasIndex(u => u.RoleId); // ‚ö†Ô∏è NEW: Index for role lookups
        builder.HasIndex(u => u.ClinicId);
    }
}
========================================
File: ./NabdCare.Infrastructure/Persistence/Configurations/AppPermissionConfiguration.cs
========================================
Ôªø// Infrastructure/Persistence/Configurations/AppPermissionConfiguration.cs
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;
using NabdCare.Domain.Entities.Permissions;

namespace NabdCare.Infrastructure.Persistence.Configurations;

public class AppPermissionConfiguration : IEntityTypeConfiguration<AppPermission>
{
    public void Configure(EntityTypeBuilder<AppPermission> builder)
    {
        builder.ToTable("AppPermissions");

        builder.HasKey(p => p.Id);

        builder.Property(p => p.Name)
            .IsRequired()
            .HasMaxLength(100); 

        builder.Property(p => p.Description)
            .HasMaxLength(500); 

        // Indexes
        builder.HasIndex(p => p.Name)
            .IsUnique();
    }
}
========================================
File: ./NabdCare.Infrastructure/Persistence/NabdCareDbContext.cs
========================================
using Microsoft.EntityFrameworkCore;
using NabdCare.Application.Common;
using NabdCare.Domain.Entities.Audits;
using NabdCare.Domain.Entities.Clinics;
using NabdCare.Domain.Entities.Payments;
using NabdCare.Domain.Entities.Permissions;
using NabdCare.Domain.Entities.Users;
using NabdCare.Domain.Interfaces;

namespace NabdCare.Infrastructure.Persistence;

/// <summary>
/// NabdCare database context with multi-tenant query filters and audit logging.
/// Author: Rabee-Qabaha
/// Updated: 2025-10-23 20:01:28 UTC
/// </summary>
public class NabdCareDbContext : DbContext
{
    private readonly ITenantContext _tenantContext;
    private readonly IUserContext _userContext;

    private Guid? TenantId => _tenantContext.ClinicId;
    private bool IsSuperAdminUser => _tenantContext.IsSuperAdmin;

    public NabdCareDbContext(
        DbContextOptions<NabdCareDbContext> options,
        ITenantContext tenantContext,
        IUserContext userContext) : base(options)
    {
        _tenantContext = tenantContext ?? throw new ArgumentNullException(nameof(tenantContext));
        _userContext = userContext ?? throw new ArgumentNullException(nameof(userContext));
    }

    // DbSets
    public DbSet<User> Users { get; set; }
    public DbSet<Clinic> Clinics { get; set; }
    public DbSet<Subscription> Subscriptions { get; set; }
    public DbSet<Payment> Payments { get; set; }
    public DbSet<ChequePaymentDetail> ChequePaymentDetails { get; set; }
    public DbSet<AppPermission> AppPermissions { get; set; }
    public DbSet<RolePermission> RolePermissions { get; set; }
    public DbSet<UserPermission> UserPermissions { get; set; }
    public DbSet<RefreshToken> RefreshTokens { get; set; }
    public DbSet<Role> Roles { get; set; }
    public DbSet<AuditLog> AuditLogs { get; set; }

    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        // Apply entity configurations
        modelBuilder.ApplyConfigurationsFromAssembly(typeof(NabdCareDbContext).Assembly);

        // ============================================
        // MULTI-TENANT QUERY FILTERS
        // ============================================

        // Role query filter
        modelBuilder.Entity<Role>().HasQueryFilter(r =>
            !r.IsDeleted &&
            (
                IsSuperAdminUser ||
                r.ClinicId == null ||
                (TenantId.HasValue && r.ClinicId == TenantId)
            )
        );

        // User query filter
        modelBuilder.Entity<User>().HasQueryFilter(u =>
            !u.IsDeleted && 
            (IsSuperAdminUser || (TenantId.HasValue && u.ClinicId == TenantId))
        );

        // Payment query filter
        modelBuilder.Entity<Payment>().HasQueryFilter(p =>
            !p.IsDeleted && 
            (IsSuperAdminUser || (TenantId.HasValue && p.ClinicId == TenantId))
        );

        // ChequePaymentDetail query filter
        modelBuilder.Entity<ChequePaymentDetail>().HasQueryFilter(cd =>
            !cd.IsDeleted && 
            !cd.Payment.IsDeleted &&
            (IsSuperAdminUser || (TenantId.HasValue && cd.Payment.ClinicId == TenantId))
        );

        // AuditLog query filter
        modelBuilder.Entity<AuditLog>().HasQueryFilter(a =>
            IsSuperAdminUser || (TenantId.HasValue && a.ClinicId == TenantId)
        );

        // ============================================
        // SIMPLE SOFT DELETE FILTERS
        // ============================================

        modelBuilder.Entity<Clinic>().HasQueryFilter(c => !c.IsDeleted);
        modelBuilder.Entity<Subscription>().HasQueryFilter(s => !s.IsDeleted);
        modelBuilder.Entity<AppPermission>().HasQueryFilter(p => !p.IsDeleted);
        modelBuilder.Entity<RolePermission>().HasQueryFilter(rp => !rp.IsDeleted);
        modelBuilder.Entity<UserPermission>().HasQueryFilter(up => !up.IsDeleted);

        // ============================================
        // GLOBAL DECIMAL PRECISION
        // ============================================

        foreach (var property in modelBuilder.Model.GetEntityTypes()
                     .SelectMany(t => t.GetProperties())
                     .Where(p => p.ClrType == typeof(decimal) || p.ClrType == typeof(decimal?)))
        {
            property.SetPrecision(18);
            property.SetScale(2);
        }

        base.OnModelCreating(modelBuilder);
    }

    public override int SaveChanges()
    {
        SetAuditFields();
        HandleSoftDeleteAuditing();
        return base.SaveChanges();
    }

    public override Task<int> SaveChangesAsync(CancellationToken cancellationToken = default)
    {
        SetAuditFields();
        HandleSoftDeleteAuditing();
        return base.SaveChangesAsync(cancellationToken);
    }

    private void SetAuditFields()
    {
        var now = DateTime.UtcNow;
        var userId = _userContext.GetCurrentUserId();

        foreach (var entry in ChangeTracker.Entries<IAuditable>())
        {
            if (entry.State == EntityState.Added)
            {
                entry.Entity.CreatedAt = now;
                entry.Entity.CreatedBy = userId;
            }
            else if (entry.State == EntityState.Modified)
            {
                entry.Entity.UpdatedAt = now;
                entry.Entity.UpdatedBy = userId;
            }
        }
    }

    private void HandleSoftDeleteAuditing()
    {
        var now = DateTime.UtcNow;
        var userId = _userContext.GetCurrentUserId();

        foreach (var entry in ChangeTracker.Entries<ISoftDeletable>())
        {
            if (entry.State == EntityState.Modified && entry.Entity.IsDeleted)
            {
                entry.Entity.DeletedAt = now;
                entry.Entity.DeletedBy = userId;
            }
        }
    }
}
========================================
File: ./NabdCare.Infrastructure/Persistence/DesignTimeDbContextFactory.cs
========================================
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Design;
using Microsoft.Extensions.Configuration;
using NabdCare.Application.Common;

namespace NabdCare.Infrastructure.Persistence;

public class DesignTimeDbContextFactory : IDesignTimeDbContextFactory<NabdCareDbContext>
{
    public NabdCareDbContext CreateDbContext(string[] args)
    {
        // Build configuration to read appsettings.json
        var configuration = new ConfigurationBuilder()
            .SetBasePath(Directory.GetCurrentDirectory())
            .AddJsonFile("appsettings.json", optional: false)
            .AddJsonFile("appsettings.Development.json", optional: true)
            .AddEnvironmentVariables()
            .Build();

        // Get the connection string
        var connectionString = configuration.GetConnectionString("DefaultConnection");

        var optionsBuilder = new DbContextOptionsBuilder<NabdCareDbContext>();
        optionsBuilder.UseNpgsql(connectionString);

        // ‚úÖ Use dummy implementations for design-time purposes
        var tenantContext = new DesignTimeTenantContext();
        var userContext = new DesignTimeUserContext();

        return new NabdCareDbContext(optionsBuilder.Options, tenantContext, userContext);
    }
}

/// <summary>
/// Dummy TenantContext implementation for EF Core design-time operations (migrations)
/// </summary>
public class DesignTimeTenantContext : ITenantContext
{
    public Guid? ClinicId => null;
    public Guid? UserId => null;
    public string? UserEmail => "system@nabdcare.local";
    public bool IsSuperAdmin => true; // Allow all operations during migrations
    public string? UserRole => "SuperAdmin";
    public bool IsAuthenticated => false;
}

/// <summary>
/// Dummy UserContext implementation for EF Core design-time operations (migrations)
/// </summary>
public class DesignTimeUserContext : IUserContext
{
    public string GetCurrentUserId()
    {
        return "System";
    }

    public string? GetCurrentUserRoleId()
    {
        return null; // No role ID during design-time/migrations
    }
}
========================================
File: ./NabdCare.Infrastructure/Persistence/DataSeed/DbSeedHostedService.cs
========================================
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;

namespace NabdCare.Infrastructure.Persistence.DataSeed;

public class DbSeedHostedService : IHostedService
{
    private readonly IServiceProvider _serviceProvider;

    public DbSeedHostedService(IServiceProvider serviceProvider)
    {
        _serviceProvider = serviceProvider;
    }

    public async Task StartAsync(CancellationToken cancellationToken)
    {
        using var scope = _serviceProvider.CreateScope();
        var seeder = scope.ServiceProvider.GetRequiredService<DbSeeder>();

        // Use async seeding
        await seeder.SeedAsync();
    }

    public Task StopAsync(CancellationToken cancellationToken) => Task.CompletedTask;
}
========================================
File: ./NabdCare.Infrastructure/Persistence/DataSeed/RolePermissionsSeeder.cs
========================================
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Logging;
using NabdCare.Application.Interfaces;
using NabdCare.Domain.Entities.Permissions;

namespace NabdCare.Infrastructure.Persistence.DataSeed;

/// <summary>
/// Seeds role-permission associations into the database.
/// Maps permissions to system and template roles.
/// Author: Rabee-Qabaha
/// Updated: 2025-10-25
/// </summary>
public class RolePermissionsSeeder : ISingleSeeder
{
    private readonly NabdCareDbContext _dbContext;
    private readonly ILogger<RolePermissionsSeeder> _logger;

    public int Order => 3;

    public RolePermissionsSeeder(
        NabdCareDbContext dbContext,
        ILogger<RolePermissionsSeeder> logger)
    {
        _dbContext = dbContext ?? throw new ArgumentNullException(nameof(dbContext));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }

    public async Task SeedAsync()
    {
        _logger.LogInformation("üå± Seeding role permissions...");

        var roles = await _dbContext.Roles
            .IgnoreQueryFilters()
            .Where(r => r.ClinicId == null)
            .ToListAsync();

        var permissions = await _dbContext.AppPermissions
            .IgnoreQueryFilters()
            .ToListAsync();

        if (!roles.Any())
        {
            _logger.LogWarning("‚ö†Ô∏è  No roles found. Ensure RolesSeeder runs before this");
            return;
        }

        if (!permissions.Any())
        {
            _logger.LogWarning("‚ö†Ô∏è  No permissions found. Ensure PermissionsSeeder runs before this");
            return;
        }

        var rolePermissionMappings = GetRolePermissionMappings();
        var assignedCount = 0;

        foreach (var mapping in rolePermissionMappings)
        {
            var roleName = mapping.Key;
            var permissionNames = mapping.Value;

            var role = roles.FirstOrDefault(r => r.Name == roleName);
            if (role == null)
            {
                _logger.LogWarning("   ‚ö†Ô∏è  Role '{RoleName}' not found, skipping", roleName);
                continue;
            }

            _logger.LogDebug("   üìã Processing role: {RoleName} ({Count} permissions)", 
                roleName, permissionNames.Length);

            foreach (var permissionName in permissionNames)
            {
                var permission = permissions.FirstOrDefault(p => p.Name == permissionName);
                if (permission == null)
                {
                    _logger.LogWarning("      ‚ö†Ô∏è  Permission '{PermissionName}' not found", permissionName);
                    continue;
                }

                var exists = await _dbContext.RolePermissions
                    .IgnoreQueryFilters()
                    .AnyAsync(rp => rp.RoleId == role.Id && rp.PermissionId == permission.Id);

                if (!exists)
                {
                    var rolePermission = new RolePermission
                    {
                        Id = Guid.NewGuid(),
                        RoleId = role.Id,
                        PermissionId = permission.Id,
                        CreatedAt = DateTime.UtcNow,
                        CreatedBy = "System:Seeder",
                        IsDeleted = false
                    };

                    _dbContext.RolePermissions.Add(rolePermission);
                    assignedCount++;
                }
            }

            _logger.LogInformation("   ‚úÖ Assigned {Count} permissions to {RoleName}", 
                permissionNames.Length, roleName);
        }

        if (assignedCount > 0)
        {
            await _dbContext.SaveChangesAsync();
            _logger.LogInformation("‚úÖ {Count} role-permission assignments created", assignedCount);
        }
        else
        {
            _logger.LogInformation("‚úÖ All role permissions already assigned, skipping seed");
        }
    }

    private static Dictionary<string, string[]> GetRolePermissionMappings()
    {
        return new Dictionary<string, string[]>
        {
            // ============================================
            // üëë SUPERADMIN - Full System Access
            // ============================================
            ["SuperAdmin"] = new[]
            {
                // ALL Clinic Management
                "Clinics.ViewAll",
                "Clinics.Create",
                "Clinics.Edit",
                "Clinics.Delete",
                "Clinics.HardDelete",
                "Clinics.ManageStatus",
                "Clinics.ViewStats",
                
                // ALL Subscription Management
                "Subscriptions.ViewAll",
                "Subscriptions.View",
                "Subscriptions.Create",
                "Subscriptions.Edit",
                "Subscriptions.Cancel",
                "Subscriptions.Renew",
                
                // ALL User Management
                "Users.ViewAll",
                "Users.View",
                "Users.ViewDetails",
                "Users.Create",
                "Users.Edit",
                "Users.Delete",
                "Users.Activate",
                "Users.ChangeRole",
                "Users.ResetPassword",
                "Users.ManagePermissions",
                
                // ALL Role Management
                "Roles.ViewAll",
                "Roles.View",
                "Roles.Create",
                "Roles.Edit",
                "Roles.Delete",
                "Roles.ManagePermissions",

                // Settings.ManageRoles (ADDED for SuperAdmin!)
                "Settings.ManageRoles",

                // ALL Permission Management
                "Permissions.View",
                "Permissions.Assign",
                "Permissions.Revoke",
                
                // ALL Patient Management
                "Patients.View",
                "Patients.ViewDetails",
                "Patients.Create",
                "Patients.Edit",
                "Patients.Delete",
                "Patients.ViewMedicalHistory",
                "Patients.EditMedicalHistory",
                "Patients.ViewDocuments",
                "Patients.UploadDocuments",
                "Patients.Export",
                
                // ALL Appointments
                "Appointments.View",
                "Appointments.Create",
                "Appointments.Edit",
                "Appointments.Cancel",
                "Appointments.CheckIn",
                "Appointments.ViewCalendar",
                
                // ALL Medical Records
                "MedicalRecords.View",
                "MedicalRecords.Create",
                "MedicalRecords.Edit",
                "MedicalRecords.Delete",
                "MedicalRecords.Prescribe",
                "MedicalRecords.ViewPrescriptions",
                
                // ALL Billing
                "Payments.View",
                "Payments.Create",
                "Payments.Edit",
                "Payments.Delete",
                "Payments.Process",
                "Payments.Refund",
                "Payments.ViewReports",
                "Invoices.View",
                "Invoices.Create",
                "Invoices.Edit",
                "Invoices.Send",
                "Invoices.ViewReports",
                
                // ALL Reports
                "Reports.ViewDashboard",
                "Reports.ViewPatientReports",
                "Reports.ViewFinancialReports",
                "Reports.ViewAppointmentReports",
                "Reports.Export",
                "Reports.Generate",
                
                // ALL Settings
                "Settings.View",
                "Settings.Edit",
                
                // ALL Audit Logs
                "AuditLogs.View",
                "AuditLogs.Export",
                
                // System Management
                "System.ManageSettings",
                "System.ViewLogs",
                "System.ManageRoles"
            },

            // ============================================
            // üõ†Ô∏è SUPPORT MANAGER - Customer Support
            // ============================================
            ["SupportManager"] = new[]
            {
                "Clinics.ViewAll",
                "Users.ViewAll",
                "Users.View",
                "Users.ViewDetails",
                "Users.ResetPassword",
                "Patients.View",
                "Patients.ViewDetails",
                "AuditLogs.View"
            },

            // ============================================
            // üí∞ BILLING MANAGER - Subscription Management
            // ============================================
            ["BillingManager"] = new[]
            {
                "Clinics.ViewAll",
                "Clinics.Edit",
                "Subscriptions.ViewAll",
                "Subscriptions.Create",
                "Subscriptions.Edit",
                "Subscriptions.Cancel",
                "Subscriptions.Renew",
                "Payments.View",
                "Payments.ViewReports",
                "Invoices.View",
                "Invoices.ViewReports",
                "Reports.ViewFinancialReports"
            },

            // ============================================
            // üè• CLINIC ADMIN - Full Clinic Management
            // ============================================
            ["Clinic Admin"] = new[]
            {
                // Own Clinic Management
                "Clinic.View",
                "Clinic.Edit",
                "Clinic.ViewSettings",
                "Clinic.EditSettings",
                "Clinic.ManageBranches",
                
                // Own Subscription
                "Subscriptions.View",
                "Subscriptions.Renew",
                
                // User Management (within clinic)
                "Users.View",
                "Users.ViewDetails",
                "Users.Create",
                "Users.Edit",
                "Users.Delete",
                "Users.Activate",
                "Users.ChangeRole",
                "Users.ResetPassword",
                "Users.ManagePermissions",
                
                // Role Management
                "Roles.View",
                "Roles.Create",
                "Roles.Edit",
                "Roles.Delete",
                "Roles.ManagePermissions",

                // Settings.ManageRoles (optional for Clinic Admin, add if needed)
                // "Settings.ManageRoles", // Uncomment if you want Clinic Admin to manage roles

                // Permissions
                "Permissions.View",
                "Permissions.Assign",
                "Permissions.Revoke",
                
                // Patient Management
                "Patients.View",
                "Patients.ViewDetails",
                "Patients.Create",
                "Patients.Edit",
                "Patients.Delete",
                "Patients.ViewMedicalHistory",
                "Patients.EditMedicalHistory",
                "Patients.ViewDocuments",
                "Patients.UploadDocuments",
                "Patients.Export",
                
                // Appointments
                "Appointments.View",
                "Appointments.Create",
                "Appointments.Edit",
                "Appointments.Cancel",
                "Appointments.CheckIn",
                "Appointments.ViewCalendar",
                
                // Medical Records
                "MedicalRecords.View",
                "MedicalRecords.Create",
                "MedicalRecords.Edit",
                "MedicalRecords.Prescribe",
                "MedicalRecords.ViewPrescriptions",
                
                // Billing
                "Payments.View",
                "Payments.Create",
                "Payments.Edit",
                "Payments.Process",
                "Payments.Refund",
                "Payments.ViewReports",
                "Invoices.View",
                "Invoices.Create",
                "Invoices.Edit",
                "Invoices.Send",
                "Invoices.ViewReports",
                
                // Reports
                "Reports.ViewDashboard",
                "Reports.ViewPatientReports",
                "Reports.ViewFinancialReports",
                "Reports.ViewAppointmentReports",
                "Reports.Export",
                "Reports.Generate",
                
                // Settings
                "Settings.View",
                "Settings.Edit",
                
                // Audit Logs
                "AuditLogs.View",
                "AuditLogs.Export"
            },

            // ============================================
            // üë®‚Äç‚öïÔ∏è DOCTOR - Medical Care
            // ============================================
            ["Doctor"] = new[]
            {
                "Patients.View",
                "Patients.ViewDetails",
                "Patients.Create",
                "Patients.Edit",
                "Patients.ViewMedicalHistory",
                "Patients.EditMedicalHistory",
                "Patients.ViewDocuments",
                "Patients.UploadDocuments",
                "Appointments.View",
                "Appointments.Create",
                "Appointments.Edit",
                "Appointments.CheckIn",
                "Appointments.ViewCalendar",
                "MedicalRecords.View",
                "MedicalRecords.Create",
                "MedicalRecords.Edit",
                "MedicalRecords.Prescribe",
                "MedicalRecords.ViewPrescriptions",
                "Reports.ViewPatientReports"
            },

            // ============================================
            // üë©‚Äç‚öïÔ∏è NURSE - Patient Care Support
            // ============================================
            ["Nurse"] = new[]
            {
                "Patients.View",
                "Patients.ViewDetails",
                "Patients.ViewMedicalHistory",
                "Patients.ViewDocuments",
                "Appointments.View",
                "Appointments.CheckIn",
                "Appointments.ViewCalendar",
                "MedicalRecords.View",
                "MedicalRecords.ViewPrescriptions"
            },

            // ============================================
            // üìû RECEPTIONIST - Front Desk
            // ============================================
            ["Receptionist"] = new[]
            {
                "Patients.View",
                "Patients.ViewDetails",
                "Patients.Create",
                "Patients.Edit",
                "Appointments.View",
                "Appointments.Create",
                "Appointments.Edit",
                "Appointments.Cancel",
                "Appointments.CheckIn",
                "Appointments.ViewCalendar",
                "Payments.View",
                "Payments.Create",
                "Invoices.View",
                "Invoices.Create",
                "Invoices.Send",
                "Users.View"
            }
        };
    }
}
========================================
File: ./NabdCare.Infrastructure/Persistence/DataSeed/RolesSeeder.cs
========================================
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Logging;
using NabdCare.Application.Interfaces;
using NabdCare.Domain.Entities.Permissions;

namespace NabdCare.Infrastructure.Persistence.DataSeed;

/// <summary>
/// Seeds default system and template roles into the database.
/// System roles: SuperAdmin, SupportManager, BillingManager
/// Template roles: Clinic Admin, Doctor, Nurse, Receptionist
/// Author: Rabee-Qabaha
/// Updated: 2025-10-23 18:46:03 UTC
/// </summary>
public class RolesSeeder : ISingleSeeder
{
    private readonly NabdCareDbContext _dbContext;
    private readonly ILogger<RolesSeeder> _logger;

    public int Order => 1;

    public RolesSeeder(
        NabdCareDbContext dbContext,
        ILogger<RolesSeeder> logger)
    {
        _dbContext = dbContext ?? throw new ArgumentNullException(nameof(dbContext));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }

    public async Task SeedAsync()
    {
        _logger.LogInformation("üå± Seeding default roles...");

        var systemRoles = GetSystemRoles();
        var templateRoles = GetTemplateRoles();
        var allRoles = systemRoles.Concat(templateRoles).ToList();
        
        var addedCount = 0;

        foreach (var role in allRoles)
        {
            var exists = await _dbContext.Roles
                .IgnoreQueryFilters()
                .AnyAsync(r => r.Name == role.Name && r.ClinicId == null);

            if (!exists)
            {
                role.Id = Guid.NewGuid();
                role.CreatedAt = DateTime.UtcNow;
                role.CreatedBy = "System:Seeder";
                role.IsDeleted = false;

                _dbContext.Roles.Add(role);
                addedCount++;

                var roleType = role.IsSystemRole ? "System" : "Template";
                _logger.LogDebug("   ‚ûï Added role: {Name} ({Type})", role.Name, roleType);
            }
        }

        if (addedCount > 0)
        {
            await _dbContext.SaveChangesAsync();
            _logger.LogInformation("‚úÖ {Count} roles seeded successfully", addedCount);
        }
        else
        {
            _logger.LogInformation("‚úÖ All roles already exist, skipping seed");
        }
    }

    private static List<Role> GetSystemRoles()
    {
        return new List<Role>
        {
            new()
            {
                Name = "SuperAdmin",
                Description = "Full system access - SaaS administrator with unrestricted permissions",
                IsSystemRole = true,
                IsTemplate = false,
                ClinicId = null,
                DisplayOrder = 1,
                ColorCode = "#DC2626", // Red
                IconClass = "fa-crown"
            },
            new()
            {
                Name = "SupportManager",
                Description = "Customer support - can view clinics and assist users with troubleshooting",
                IsSystemRole = true,
                IsTemplate = false,
                ClinicId = null,
                DisplayOrder = 2,
                ColorCode = "#2563EB", // Blue
                IconClass = "fa-headset"
            },
            new()
            {
                Name = "BillingManager",
                Description = "Billing and subscription management - handles payments and renewals",
                IsSystemRole = true,
                IsTemplate = false,
                ClinicId = null,
                DisplayOrder = 3,
                ColorCode = "#16A34A", // Green
                IconClass = "fa-dollar-sign"
            }
        };
    }

    private static List<Role> GetTemplateRoles()
    {
        return new List<Role>
        {
            new()
            {
                Name = "Clinic Admin",
                Description = "Full clinic management access - manages staff, patients, and settings",
                IsSystemRole = false,
                IsTemplate = true,
                ClinicId = null,
                DisplayOrder = 10,
                ColorCode = "#9333EA", // Purple
                IconClass = "fa-user-shield"
            },
            new()
            {
                Name = "Doctor",
                Description = "Medical practitioner - provides patient care and manages medical records",
                IsSystemRole = false,
                IsTemplate = true,
                ClinicId = null,
                DisplayOrder = 11,
                ColorCode = "#0891B2", // Cyan
                IconClass = "fa-user-md"
            },
            new()
            {
                Name = "Nurse",
                Description = "Nursing staff - assists with patient care and record viewing",
                IsSystemRole = false,
                IsTemplate = true,
                ClinicId = null,
                DisplayOrder = 12,
                ColorCode = "#DB2777", // Pink
                IconClass = "fa-user-nurse"
            },
            new()
            {
                Name = "Receptionist",
                Description = "Front desk operations - manages appointments and basic billing",
                IsSystemRole = false,
                IsTemplate = true,
                ClinicId = null,
                DisplayOrder = 13,
                ColorCode = "#EA580C", // Orange
                IconClass = "fa-desktop"
            }
        };
    }
}
========================================
File: ./NabdCare.Infrastructure/Persistence/DataSeed/SuperAdminSeeder.cs
========================================
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Logging;
using NabdCare.Application.Interfaces;
using NabdCare.Domain.Entities.Clinics;
using NabdCare.Domain.Entities.Users;
using NabdCare.Domain.Enums;

namespace NabdCare.Infrastructure.Persistence.DataSeed;

/// <summary>
/// Seeds the SuperAdmin user and Ramallah Medical Center demo clinic.
/// Creates initial data for testing and development.
/// Author: Rabee-Qabaha
/// Updated: 2025-10-23 21:00:21 UTC
/// </summary>
public class SuperAdminSeeder : ISingleSeeder
{
    private readonly NabdCareDbContext _dbContext;
    private readonly IPasswordService _passwordService;
    private readonly ILogger<SuperAdminSeeder> _logger;

    public int Order => 4;

    public SuperAdminSeeder(
        NabdCareDbContext dbContext,
        IPasswordService passwordService,
        ILogger<SuperAdminSeeder> logger)
    {
        _dbContext = dbContext ?? throw new ArgumentNullException(nameof(dbContext));
        _passwordService = passwordService ?? throw new ArgumentNullException(nameof(passwordService));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }

    public async Task SeedAsync()
    {
        _logger.LogInformation("üå± Seeding SuperAdmin user and demo clinic...");

        try
        {
            await SeedSuperAdminUserAsync();
            await SeedDemoClinicAsync();
            
            _logger.LogInformation("‚úÖ SuperAdmin and demo clinic seeding completed");
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "‚ùå SuperAdmin seeding failed: {Message}", ex.Message);
            throw;
        }
    }

    private async Task SeedSuperAdminUserAsync()
    {
        var superAdminEmail = "sadmin@nabd.care";

        var exists = await _dbContext.Users
            .IgnoreQueryFilters()
            .AnyAsync(u => u.Email == superAdminEmail);

        if (exists)
        {
            _logger.LogInformation("‚úÖ SuperAdmin user already exists, skipping creation");
            return;
        }

        var superAdminRole = await _dbContext.Roles
            .IgnoreQueryFilters()
            .FirstOrDefaultAsync(r => r.Name == "SuperAdmin" && r.IsSystemRole);

        if (superAdminRole == null)
        {
            _logger.LogError("‚ùå SuperAdmin role not found. Ensure RolesSeeder runs first");
            throw new InvalidOperationException("SuperAdmin role must be seeded before creating SuperAdmin user");
        }

        var superAdmin = new User
        {
            Id = Guid.NewGuid(),
            Email = superAdminEmail,
            FullName = "Super Admin",
            RoleId = superAdminRole.Id,
            IsActive = true,
            ClinicId = null,
            CreatedAt = DateTime.UtcNow,
            CreatedBy = "System:Seeder",
            IsDeleted = false
        };

        superAdmin.PasswordHash = _passwordService.HashPassword(superAdmin, "Admin@123!");

        _dbContext.Users.Add(superAdmin);
        await _dbContext.SaveChangesAsync();

        _logger.LogInformation("‚úÖ SuperAdmin created: {Email}", superAdminEmail);
        _logger.LogWarning("‚ö†Ô∏è  IMPORTANT: Change default password immediately in production!");
        _logger.LogInformation("   Email: {Email}", superAdminEmail);
        _logger.LogInformation("   Password: Admin@123!");
    }

    private async Task SeedDemoClinicAsync()
    {
        var demoClinicEmail = "info@ramallahmedical.ps";

        // Check if clinic exists
        var clinic = await _dbContext.Clinics
            .IgnoreQueryFilters()
            .FirstOrDefaultAsync(c => c.Email == demoClinicEmail);

        if (clinic == null)
        {
            _logger.LogInformation("üîÑ Creating demo clinic...");
            
            // Create clinic if it doesn't exist
            var clinicId = Guid.NewGuid();
            var subscriptionId = Guid.NewGuid();

            clinic = new Clinic
            {
                Id = clinicId,
                Name = "Ramallah Medical Center",
                Email = demoClinicEmail,
                Phone = "+970-2-2987654",
                Address = "Al-Irsal Street, Downtown Ramallah, Palestine",
                Status = SubscriptionStatus.Active,
                BranchCount = 3,
                CreatedAt = DateTime.UtcNow,
                CreatedBy = "System:Seeder",
                IsDeleted = false,
                Subscriptions = new List<Subscription>
                {
                    new()
                    {
                        Id = subscriptionId,
                        ClinicId = clinicId,
                        StartDate = DateTime.UtcNow,
                        EndDate = DateTime.UtcNow.AddYears(1),
                        Type = SubscriptionType.Yearly,
                        Fee = 12000m,
                        Status = SubscriptionStatus.Active,
                        CreatedAt = DateTime.UtcNow,
                        CreatedBy = "System:Seeder",
                        IsDeleted = false
                    }
                }
            };

            _dbContext.Clinics.Add(clinic);
            await _dbContext.SaveChangesAsync();

            _logger.LogInformation("‚úÖ Demo clinic created: {ClinicName}", clinic.Name);
        }
        else
        {
            _logger.LogInformation("‚úÖ Demo clinic already exists: {ClinicName}", clinic.Name);
        }

        // Get required roles
        var clinicAdminRole = await _dbContext.Roles
            .IgnoreQueryFilters()
            .FirstOrDefaultAsync(r => r.Name == "Clinic Admin" && r.IsTemplate);

        var doctorRole = await _dbContext.Roles
            .IgnoreQueryFilters()
            .FirstOrDefaultAsync(r => r.Name == "Doctor" && r.IsTemplate);

        if (clinicAdminRole == null || doctorRole == null)
        {
            _logger.LogError("‚ùå Required roles not found. Clinic Admin: {CAFound}, Doctor: {DFound}", 
                clinicAdminRole != null, doctorRole != null);
            throw new InvalidOperationException("Clinic Admin and Doctor roles must be seeded first");
        }

        _logger.LogInformation("‚úÖ Found roles - Clinic Admin: {CAId}, Doctor: {DId}", 
            clinicAdminRole.Id, doctorRole.Id);

        // Create Clinic Admin if doesn't exist
        var clinicAdminExists = await _dbContext.Users
            .IgnoreQueryFilters()
            .AnyAsync(u => u.Email == "cadmin@nabd.care");

        if (!clinicAdminExists)
        {
            try
            {
                _logger.LogInformation("üîÑ Creating Clinic Admin user...");
                await CreateDemoUserAsync(
                    clinic.Id,
                    clinicAdminRole.Id,
                    "Admin User",
                    "cadmin@nabd.care",
                    "Admin@123!"
                );
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "‚ùå Failed to create Clinic Admin: {Message}", ex.Message);
                throw;
            }
        }
        else
        {
            _logger.LogInformation("‚úÖ Clinic admin already exists: cadmin@nabd.care");
        }

        // Create Doctor if doesn't exist
        var doctorExists = await _dbContext.Users
            .IgnoreQueryFilters()
            .AnyAsync(u => u.Email == "dadmin@nabd.care");

        if (!doctorExists)
        {
            try
            {
                _logger.LogInformation("üîÑ Creating Doctor user...");
                await CreateDemoUserAsync(
                    clinic.Id,
                    doctorRole.Id,
                    "Dr. Ahmad Hassan",
                    "dadmin@nabd.care",
                    "Doctor@123!"
                );
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "‚ùå Failed to create Doctor: {Message}", ex.Message);
                throw;
            }
        }
        else
        {
            _logger.LogInformation("‚úÖ Doctor already exists: dadmin@nabd.care");
        }
    }

    private async Task CreateDemoUserAsync(
        Guid clinicId,
        Guid roleId,
        string fullName,
        string email,
        string password)
    {
        try
        {
            _logger.LogInformation("  üîÑ Creating user {Email} with ClinicId: {ClinicId}, RoleId: {RoleId}", 
                email, clinicId, roleId);
            
            var user = new User
            {
                Id = Guid.NewGuid(),
                ClinicId = clinicId,
                RoleId = roleId,
                Email = email,
                FullName = fullName,
                IsActive = true,
                CreatedAt = DateTime.UtcNow,
                CreatedBy = "System:Seeder",
                IsDeleted = false
            };

            _logger.LogInformation("  üîÑ Hashing password for {Email}...", email);
            user.PasswordHash = _passwordService.HashPassword(user, password);
            
            _logger.LogInformation("  üîÑ Adding user {Email} to DbContext...", email);
            _dbContext.Users.Add(user);
            
            _logger.LogInformation("  üîÑ Saving user {Email} to database...", email);
            await _dbContext.SaveChangesAsync();

            _logger.LogInformation("  ‚úÖ Demo user created: {Email} ({FullName})", email, fullName);
            _logger.LogInformation("     Email: {Email}", email);
            _logger.LogInformation("     Password: {Password}", password);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "  ‚ùå EXCEPTION creating user {Email}: {Message}", email, ex.Message);
            _logger.LogError("  üìú Stack trace: {StackTrace}", ex.StackTrace);
            
            if (ex.InnerException != null)
            {
                _logger.LogError("  üí• Inner exception: {InnerMessage}", ex.InnerException.Message);
            }
            
            throw;
        }
    }
}
========================================
File: ./NabdCare.Infrastructure/Persistence/DataSeed/DbSeeder.cs
========================================
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Logging;
using NabdCare.Application.Interfaces;

namespace NabdCare.Infrastructure.Persistence.DataSeed;

public class DbSeeder
{
    private readonly IEnumerable<ISingleSeeder> _seeders;
    private readonly NabdCareDbContext _dbContext;
    private readonly ILogger<DbSeeder> _logger;

    public DbSeeder(
        NabdCareDbContext dbContext,
        IEnumerable<ISingleSeeder> seeders,
        ILogger<DbSeeder> logger)
    {
        _dbContext = dbContext;
        _seeders = seeders;
        _logger = logger;
    }

    public async Task SeedAsync()
    {
        _logger.LogInformation("üöÄ Starting database seeding...");

        // Apply migrations first
        await _dbContext.Database.MigrateAsync();
        _logger.LogInformation("‚úÖ Migrations applied.");

        // Run all seeders in order
        var orderedSeeders = _seeders.OrderBy(s => s.Order).ToList();
        
        _logger.LogInformation("üìã Running {Count} seeders...", orderedSeeders.Count);

        foreach (var seeder in orderedSeeders)
        {
            var seederName = seeder.GetType().Name;
            _logger.LogInformation("‚ñ∂Ô∏è  Running {Seeder} (Order: {Order})...", 
                seederName, seeder.Order);

            try
            {
                await seeder.SeedAsync();
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "‚ùå Error running seeder {Seeder}", seederName);
                throw;
            }
        }

        _logger.LogInformation("üéâ Database seeding completed successfully!");
    }
}
========================================
File: ./NabdCare.Infrastructure/Persistence/DataSeed/PermissionSeeder.cs
========================================
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Logging;
using NabdCare.Application.Interfaces;
using NabdCare.Domain.Entities.Permissions;

namespace NabdCare.Infrastructure.Persistence.DataSeed;

/// <summary>
/// Seeds application permissions into the database.
/// Defines all available permissions across the system.
/// Author: Rabee-Qabaha
/// Updated: 2025-10-23 18:46:03 UTC
/// </summary>
public class PermissionsSeeder : ISingleSeeder
{
    private readonly NabdCareDbContext _dbContext;
    private readonly ILogger<PermissionsSeeder> _logger;

    public int Order => 2;

    public PermissionsSeeder(
        NabdCareDbContext dbContext,
        ILogger<PermissionsSeeder> logger)
    {
        _dbContext = dbContext ?? throw new ArgumentNullException(nameof(dbContext));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }

    public async Task SeedAsync()
    {
        _logger.LogInformation("üå± Seeding permissions...");

        var permissions = GetGroupedPermissions();
        var addedCount = 0;

        foreach (var permission in permissions)
        {
            var exists = await _dbContext.AppPermissions
                .IgnoreQueryFilters()
                .AnyAsync(p => p.Name == permission.Name);

            if (!exists)
            {
                permission.Id = Guid.NewGuid();
                permission.CreatedAt = DateTime.UtcNow;
                permission.CreatedBy = "System:Seeder";
                permission.IsDeleted = false;

                _dbContext.AppPermissions.Add(permission);
                addedCount++;

                _logger.LogDebug("   ‚ûï Added permission: {Name}", permission.Name);
            }
        }

        if (addedCount > 0)
        {
            await _dbContext.SaveChangesAsync();
            _logger.LogInformation("‚úÖ {Count} permissions seeded successfully", addedCount);
        }
        else
        {
            _logger.LogInformation("‚úÖ All permissions already exist, skipping seed");
        }
    }

    private static List<AppPermission> GetGroupedPermissions()
    {
        return new List<AppPermission>
        {
            // ============================================
            // üè¢ CLINIC MANAGEMENT (SuperAdmin)
            // ============================================
            new() { Name = "Clinics.ViewAll", Description = "View all clinics in the system (SuperAdmin only)" },
            new() { Name = "Clinics.Create", Description = "Create new clinics (onboard new customers)" },
            new() { Name = "Clinics.Edit", Description = "Edit any clinic's information" },
            new() { Name = "Clinics.Delete", Description = "Soft delete clinics" },
            new() { Name = "Clinics.HardDelete", Description = "Permanently delete clinics (irreversible)" },
            new() { Name = "Clinics.ManageStatus", Description = "Activate/Suspend clinics" },
            new() { Name = "Clinics.ViewStats", Description = "View clinic statistics and metrics" },

            // ============================================
            // üè• OWN CLINIC MANAGEMENT (Clinic Admin)
            // ============================================
            new() { Name = "Clinic.View", Description = "View own clinic information" },
            new() { Name = "Clinic.Edit", Description = "Edit own clinic information" },
            new() { Name = "Clinic.ViewSettings", Description = "View clinic settings" },
            new() { Name = "Clinic.EditSettings", Description = "Edit clinic settings" },
            new() { Name = "Clinic.ManageBranches", Description = "Manage clinic branches" },

            // ============================================
            // üìã SUBSCRIPTION MANAGEMENT
            // ============================================
            new() { Name = "Subscriptions.ViewAll", Description = "View all subscriptions (SuperAdmin only)" },
            new() { Name = "Subscriptions.View", Description = "View own clinic subscription" },
            new() { Name = "Subscriptions.Create", Description = "Create subscription plans (SuperAdmin only)" },
            new() { Name = "Subscriptions.Edit", Description = "Edit subscription details (SuperAdmin only)" },
            new() { Name = "Subscriptions.Cancel", Description = "Cancel subscriptions (SuperAdmin only)" },
            new() { Name = "Subscriptions.Renew", Description = "Renew subscriptions" },

            // ============================================
            // üë• USER MANAGEMENT
            // ============================================
            new() { Name = "Users.View", Description = "View users list in own clinic" },
            new() { Name = "Users.ViewAll", Description = "View all users across all clinics (SuperAdmin only)" },
            new() { Name = "Users.ViewDetails", Description = "View detailed user information" },
            new() { Name = "Users.Create", Description = "Create new users" },
            new() { Name = "Users.Edit", Description = "Edit user information" },
            new() { Name = "Users.Delete", Description = "Delete users (soft delete)" },
            new() { Name = "Users.Activate", Description = "Activate/deactivate users" },
            new() { Name = "Users.ChangeRole", Description = "Change user roles" },
            new() { Name = "Users.ResetPassword", Description = "Reset user passwords" },
            new() { Name = "Users.ManagePermissions", Description = "Manage user-specific permissions" },

            // ============================================
            // üîê ROLE MANAGEMENT
            // ============================================
            new() { Name = "Roles.View", Description = "View roles in own clinic" },
            new() { Name = "Roles.ViewAll", Description = "View all roles including templates (SuperAdmin only)" },
            new() { Name = "Roles.Create", Description = "Create new roles" },
            new() { Name = "Roles.Edit", Description = "Edit role information" },
            new() { Name = "Roles.Delete", Description = "Delete roles" },
            new() { Name = "Roles.ManagePermissions", Description = "Assign/remove permissions from roles" },

            // ============================================
            // üîë PERMISSION MANAGEMENT
            // ============================================
            new() { Name = "Permissions.View", Description = "View all available permissions" },
            new() { Name = "Permissions.Assign", Description = "Assign permissions to roles/users" },
            new() { Name = "Permissions.Revoke", Description = "Revoke permissions from roles/users" },

            // ============================================
            // ü©∫ PATIENT MANAGEMENT
            // ============================================
            new() { Name = "Patients.View", Description = "View patients list" },
            new() { Name = "Patients.ViewDetails", Description = "View detailed patient information" },
            new() { Name = "Patients.Create", Description = "Register new patients" },
            new() { Name = "Patients.Edit", Description = "Edit patient information" },
            new() { Name = "Patients.Delete", Description = "Delete patient records" },
            new() { Name = "Patients.ViewMedicalHistory", Description = "View patient medical history" },
            new() { Name = "Patients.EditMedicalHistory", Description = "Edit patient medical history" },
            new() { Name = "Patients.ViewDocuments", Description = "View patient documents" },
            new() { Name = "Patients.UploadDocuments", Description = "Upload patient documents" },
            new() { Name = "Patients.Export", Description = "Export patient data" },

            // ============================================
            // üìÖ APPOINTMENTS
            // ============================================
            new() { Name = "Appointments.View", Description = "View appointments" },
            new() { Name = "Appointments.Create", Description = "Create new appointments" },
            new() { Name = "Appointments.Edit", Description = "Edit appointment details" },
            new() { Name = "Appointments.Cancel", Description = "Cancel appointments" },
            new() { Name = "Appointments.CheckIn", Description = "Check-in patients for appointments" },
            new() { Name = "Appointments.ViewCalendar", Description = "View appointment calendar" },

            // ============================================
            // üìã MEDICAL RECORDS
            // ============================================
            new() { Name = "MedicalRecords.View", Description = "View medical records" },
            new() { Name = "MedicalRecords.Create", Description = "Create medical records" },
            new() { Name = "MedicalRecords.Edit", Description = "Edit medical records" },
            new() { Name = "MedicalRecords.Delete", Description = "Delete medical records" },
            new() { Name = "MedicalRecords.Prescribe", Description = "Issue prescriptions" },
            new() { Name = "MedicalRecords.ViewPrescriptions", Description = "View prescriptions" },

            // ============================================
            // üí∞ BILLING & PAYMENTS
            // ============================================
            new() { Name = "Payments.View", Description = "View payment records" },
            new() { Name = "Payments.Create", Description = "Create payment records" },
            new() { Name = "Payments.Edit", Description = "Edit payment information" },
            new() { Name = "Payments.Delete", Description = "Delete payment records" },
            new() { Name = "Payments.Process", Description = "Process payments" },
            new() { Name = "Payments.Refund", Description = "Process refunds" },
            new() { Name = "Payments.ViewReports", Description = "View payment reports" },

            new() { Name = "Invoices.View", Description = "View invoices" },
            new() { Name = "Invoices.Create", Description = "Create invoices" },
            new() { Name = "Invoices.Edit", Description = "Edit invoices" },
            new() { Name = "Invoices.Send", Description = "Send invoices to patients" },
            new() { Name = "Invoices.ViewReports", Description = "View invoice reports" },

            // ============================================
            // üìä REPORTS & ANALYTICS
            // ============================================
            new() { Name = "Reports.ViewDashboard", Description = "View analytics dashboard" },
            new() { Name = "Reports.ViewPatientReports", Description = "View patient reports" },
            new() { Name = "Reports.ViewFinancialReports", Description = "View financial reports" },
            new() { Name = "Reports.ViewAppointmentReports", Description = "View appointment reports" },
            new() { Name = "Reports.Export", Description = "Export reports" },
            new() { Name = "Reports.Generate", Description = "Generate custom reports" },

            // ============================================
            // ‚öôÔ∏è SETTINGS
            // ============================================
            new() { Name = "Settings.View", Description = "View system settings" },
            new() { Name = "Settings.Edit", Description = "Edit system settings" },
            new() { Name = "Settings.ManageRoles", Description = "Manage all roles (SuperAdmin only)" }, // <-- ADDED LINE

            // ============================================
            // üìú AUDIT LOGS
            // ============================================
            new() { Name = "AuditLogs.View", Description = "View audit logs" },
            new() { Name = "AuditLogs.Export", Description = "Export audit logs" },

            // ============================================
            // ‚öôÔ∏è SYSTEM MANAGEMENT (SuperAdmin Only)
            // ============================================
            new() { Name = "System.ManageSettings", Description = "Manage system-wide settings (SuperAdmin only)" },
            new() { Name = "System.ViewLogs", Description = "View system logs (SuperAdmin only)" },
            new() { Name = "System.ManageRoles", Description = "Manage system roles and templates (SuperAdmin only)" }
        };
    }
}
========================================
File: ./NabdCare.Infrastructure/BackgroundJobs/BackgroundJobs.cs
========================================
// Infrastructure/BackgroundJobs/SubscriptionExpirationJob.cs
using Microsoft.Extensions.Logging;
using NabdCare.Application.Interfaces.Clinics;
using NabdCare.Domain.Enums;

namespace NabdCare.Infrastructure.BackgroundJobs;

/// <summary>
/// Background job to automatically expire subscriptions
/// Run daily at 00:00 UTC
/// </summary>
public class SubscriptionExpirationJob
{
    private readonly IClinicRepository _clinicRepository;
    private readonly ILogger<SubscriptionExpirationJob> _logger;

    public SubscriptionExpirationJob(
        IClinicRepository clinicRepository,
        ILogger<SubscriptionExpirationJob> logger)
    {
        _clinicRepository = clinicRepository;
        _logger = logger;
    }

    public async Task ExecuteAsync()
    {
        _logger.LogInformation("Starting subscription expiration check at {Time}", DateTime.UtcNow);

        var now = DateTime.UtcNow;
        var expiredClinics = await _clinicRepository.GetWithExpiredSubscriptionsAsync();
        
        var count = 0;
        foreach (var clinic in expiredClinics)
        {
            if (clinic.Status == SubscriptionStatus.Active)
            {
                clinic.Status = SubscriptionStatus.Expired;
                clinic.UpdatedAt = now;
                clinic.UpdatedBy = "System:ExpirationJob";

                var expiredSubscription = clinic.Subscriptions?
                    .Where(s => !s.IsDeleted && s.EndDate <= now)
                    .OrderByDescending(s => s.StartDate)
                    .FirstOrDefault();

                if (expiredSubscription != null)
                {
                    expiredSubscription.Status = SubscriptionStatus.Expired;
                    expiredSubscription.UpdatedAt = now;
                    expiredSubscription.UpdatedBy = "System:ExpirationJob";
                }

                await _clinicRepository.UpdateAsync(clinic);
                
                _logger.LogWarning("Clinic {ClinicId} ({ClinicName}) subscription expired automatically",
                    clinic.Id, clinic.Name);
                
                count++;
            }
        }

        _logger.LogInformation("Subscription expiration check completed. {Count} clinics expired", count);
    }
}
